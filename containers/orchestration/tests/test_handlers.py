import json
from pathlib import Path
from unittest.mock import MagicMock
from unittest.mock import Mock

from app.handlers import build_fhir_converter_request
from app.handlers import build_valiation_request
from app.handlers import unpack_fhir_converter_response
from app.handlers import unpack_validation_response


def test_build_fhir_converter_request():
    # Test case for an HL7 message
    message = open(
        Path(__file__).parent.parent.parent.parent
        / "tests"
        / "assets"
        / "fhir-converter"
        / "hl7v2"
        / "hl7_with_msh_3_set.hl7"
    ).read()
    orchestration_request = {
        "message_type": "elr",
        "data_type": "hl7",
        "config_file_name": "sample-hl7-test-config.json",
        "include_error_types": "error",
        "message": message,
    }
    result = build_fhir_converter_request(message, orchestration_request)
    assert result["input_type"] == "elr"
    assert result["root_template"] == "ORU_R01"
    assert result["input_data"] == message

    # Test case for an eCR message
    message = open(
        Path(__file__).parent.parent.parent.parent
        / "tests"
        / "assets"
        / "fhir-converter"
        / "ccda"
        / "ccda_sample.xml"
    ).read()
    orchestration_request = {
        "message_type": "ecr",
        "data_type": "ecr",
        "config_file_name": "sample-orchestration-config.json",
        "include_error_types": "error",
        "message": message,
    }
    result = build_fhir_converter_request(message, orchestration_request)
    assert result["input_type"] == "ecr"
    assert result["root_template"] == "EICR"


def test_build_validation_request():
    # Test case for an eCR message, since it's the only one currently
    # implemented
    message = open(
        Path(__file__).parent.parent.parent.parent
        / "tests"
        / "assets"
        / "fhir-converter"
        / "ccda"
        / "ccda_sample.xml"
    ).read()
    orchestration_request = {
        "message_type": "ecr",
        "data_type": "ecr",
        "config_file_name": "sample-orchestration-config.json",
        "include_error_types": "error",
        "message": message,
    }
    result = build_valiation_request(message, orchestration_request)
    assert result["message_type"] == "ecr"
    assert result["include_error_types"] == "error"
    assert result["message"] == message
    assert result["rr_data"] is None


def test_unpack_fhir_converter_response():
    # Case for a failed conversion
    # The Mock here represents a Response object generated by FastAPI, which
    # we can't auto-generate because we don't actually make a post request
    # when using a handler, and we can't manually give a real Response object
    # the `.json()` attribute
    converter_result = Mock()
    converter_result.status_code = 400
    converter_result.content = {"fhir_conversion_failed": True}
    response = Mock()
    response.json.return_value = {"response": converter_result}
    result = unpack_fhir_converter_response(response)
    assert result[0] == 400
    assert "FHIR Converter request failed" in result[1]

    # Successful conversion response
    sample_bundle = json.load(
        open(
            Path(__file__).parent.parent.parent.parent
            / "tests"
            / "assets"
            / "general"
            / "patient_bundle.json"
        )
    )
    converter_result = MagicMock()
    converter_result.status_code = 200
    actual_bundle = {"FhirResource": sample_bundle}
    converter_result.get.side_effect = actual_bundle.get
    response = Mock()
    response.json.return_value = {"response": converter_result}
    result = unpack_fhir_converter_response(response)
    assert result == (200, sample_bundle)


def test_unpack_validation_response():
    # Case when the service fails before validating
    # The Mock here represents a Response object generated by FastAPI, which
    # we can't auto-generate because we don't actually make a post request
    # when using a handler, and we can't manually give a real Response object
    # the `.json()` attribute
    validator_result = Mock()
    validator_result.status_code = 400
    validator_result.text = "validation didn't work"
    response = Mock()
    response.json.return_value = validator_result
    result = unpack_validation_response(response)
    assert result[0] == 400
    assert "Validation service failed" in result[1]

    # Case where an eCR message isn't valid but the service completes
    # with errors to report
    expected_result_for_bad_eCR = {
        "message_valid": False,
        "validation_results": {
            "fatal": ["eCR Message is not valid XML!"],
            "errors": [],
            "warnings": [],
            "information": [],
            "message_ids": {},
        },
    }
    validator_result = MagicMock()
    validator_result.status_code = 200
    validator_result.get.side_effect = expected_result_for_bad_eCR.get
    response = MagicMock()
    response.json.return_value = validator_result
    actual_result = unpack_validation_response(response)
    assert actual_result == (200, expected_result_for_bad_eCR.get("validation_results"))

    # Case where the eCR is valid and well_formatted
    expected_result_for_good_ecr = {
        "message_valid": True,
        "validation_results": {
            "fatal": [],
            "errors": [],
            "warnings": [],
            "information": [],
            "message_ids": {},
        },
    }
    validator_result = MagicMock()
    validator_result.status_code = 200
    validator_result.get.side_effect = expected_result_for_good_ecr.get
    response = MagicMock()
    response.json.return_value = validator_result
    actual_result = unpack_validation_response(response)
    assert actual_result == (200, True)
