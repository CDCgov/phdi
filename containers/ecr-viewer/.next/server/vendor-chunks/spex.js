"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/spex";
exports.ids = ["vendor-chunks/spex"];
exports.modules = {

/***/ "(rsc)/./node_modules/spex/lib/adapter.js":
/*!******************************************!*\
  !*** ./node_modules/spex/lib/adapter.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\r\n * @class PromiseAdapter\r\n * @description\r\n * Adapter for the primary promise operations.\r\n *\r\n * Provides compatibility with promise libraries that cannot be recognized automatically,\r\n * via functions that implement the primary operations with promises:\r\n *\r\n *  - construct a new promise with a callback function\r\n *  - resolve a promise with some result data\r\n *  - reject a promise with a reason\r\n *\r\n * #### Example\r\n *\r\n * Below is an example of setting up a [client-side]{@tutorial client} adapter for AngularJS $q.\r\n *\r\n * ```js\r\n * const spexLib = require('spex'); // or include client-side spex.js\r\n *\r\n * const adapter = new spexLib.PromiseAdapter(\r\n *    cb => $q(cb), // creating a new promise;\r\n *    data => $q.when(data), // resolving a promise;\r\n *    reason => $q.reject(reason) // rejecting a promise;\r\n *    );\r\n *\r\n * const spex = spexLib(adapter);\r\n * ```\r\n *\r\n * @param {Function} create\r\n * A function that takes a callback parameter and returns a new promise object.\r\n * The callback parameter is expected to be `function(resolve, reject)`.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to create a promise.`\r\n *\r\n * @param {Function} resolve\r\n * A function that takes an optional data parameter and resolves a promise with it.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to resolve a promise.`\r\n *\r\n * @param {Function} reject\r\n * A function that takes an optional error parameter and rejects a promise with it.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to reject a promise.`\r\n *\r\n * @see {@tutorial client}\r\n *\r\n */ \nclass PromiseAdapter {\n    constructor(create, resolve, reject){\n        this.create = create;\n        this.resolve = resolve;\n        this.reject = reject;\n        if (typeof create !== \"function\") {\n            throw new TypeError(\"Adapter requires a function to create a promise.\");\n        }\n        if (typeof resolve !== \"function\") {\n            throw new TypeError(\"Adapter requires a function to resolve a promise.\");\n        }\n        if (typeof reject !== \"function\") {\n            throw new TypeError(\"Adapter requires a function to reject a promise.\");\n        }\n    }\n}\nmodule.exports = PromiseAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThDQztBQUNELE1BQU1BO0lBQ0ZDLFlBQVlDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDakMsSUFBSSxDQUFDRixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBRWQsSUFBSSxPQUFPRixXQUFXLFlBQVk7WUFDOUIsTUFBTSxJQUFJRyxVQUFVO1FBQ3hCO1FBRUEsSUFBSSxPQUFPRixZQUFZLFlBQVk7WUFDL0IsTUFBTSxJQUFJRSxVQUFVO1FBQ3hCO1FBRUEsSUFBSSxPQUFPRCxXQUFXLFlBQVk7WUFDOUIsTUFBTSxJQUFJQyxVQUFVO1FBQ3hCO0lBQ0o7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvYWRhcHRlci5qcz9mZTlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAY2xhc3MgUHJvbWlzZUFkYXB0ZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFkYXB0ZXIgZm9yIHRoZSBwcmltYXJ5IHByb21pc2Ugb3BlcmF0aW9ucy5cclxuICpcclxuICogUHJvdmlkZXMgY29tcGF0aWJpbGl0eSB3aXRoIHByb21pc2UgbGlicmFyaWVzIHRoYXQgY2Fubm90IGJlIHJlY29nbml6ZWQgYXV0b21hdGljYWxseSxcclxuICogdmlhIGZ1bmN0aW9ucyB0aGF0IGltcGxlbWVudCB0aGUgcHJpbWFyeSBvcGVyYXRpb25zIHdpdGggcHJvbWlzZXM6XHJcbiAqXHJcbiAqICAtIGNvbnN0cnVjdCBhIG5ldyBwcm9taXNlIHdpdGggYSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiAgLSByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIHNvbWUgcmVzdWx0IGRhdGFcclxuICogIC0gcmVqZWN0IGEgcHJvbWlzZSB3aXRoIGEgcmVhc29uXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBCZWxvdyBpcyBhbiBleGFtcGxlIG9mIHNldHRpbmcgdXAgYSBbY2xpZW50LXNpZGVde0B0dXRvcmlhbCBjbGllbnR9IGFkYXB0ZXIgZm9yIEFuZ3VsYXJKUyAkcS5cclxuICpcclxuICogYGBganNcclxuICogY29uc3Qgc3BleExpYiA9IHJlcXVpcmUoJ3NwZXgnKTsgLy8gb3IgaW5jbHVkZSBjbGllbnQtc2lkZSBzcGV4LmpzXHJcbiAqXHJcbiAqIGNvbnN0IGFkYXB0ZXIgPSBuZXcgc3BleExpYi5Qcm9taXNlQWRhcHRlcihcclxuICogICAgY2IgPT4gJHEoY2IpLCAvLyBjcmVhdGluZyBhIG5ldyBwcm9taXNlO1xyXG4gKiAgICBkYXRhID0+ICRxLndoZW4oZGF0YSksIC8vIHJlc29sdmluZyBhIHByb21pc2U7XHJcbiAqICAgIHJlYXNvbiA9PiAkcS5yZWplY3QocmVhc29uKSAvLyByZWplY3RpbmcgYSBwcm9taXNlO1xyXG4gKiAgICApO1xyXG4gKlxyXG4gKiBjb25zdCBzcGV4ID0gc3BleExpYihhZGFwdGVyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNyZWF0ZVxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjayBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSBvYmplY3QuXHJcbiAqIFRoZSBjYWxsYmFjayBwYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gYmUgYGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdClgLlxyXG4gKlxyXG4gKiBQYXNzaW5nIGluIGFueXRoaW5nIG90aGVyIHRoYW4gYSBmdW5jdGlvbiB3aWxsIHRocm93IGBBZGFwdGVyIHJlcXVpcmVzIGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcHJvbWlzZS5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcclxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIG9wdGlvbmFsIGRhdGEgcGFyYW1ldGVyIGFuZCByZXNvbHZlcyBhIHByb21pc2Ugd2l0aCBpdC5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb24gd2lsbCB0aHJvdyBgQWRhcHRlciByZXF1aXJlcyBhIGZ1bmN0aW9uIHRvIHJlc29sdmUgYSBwcm9taXNlLmBcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XHJcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBlcnJvciBwYXJhbWV0ZXIgYW5kIHJlamVjdHMgYSBwcm9taXNlIHdpdGggaXQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYW55dGhpbmcgb3RoZXIgdGhhbiBhIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYEFkYXB0ZXIgcmVxdWlyZXMgYSBmdW5jdGlvbiB0byByZWplY3QgYSBwcm9taXNlLmBcclxuICpcclxuICogQHNlZSB7QHR1dG9yaWFsIGNsaWVudH1cclxuICpcclxuICovXHJcbmNsYXNzIFByb21pc2VBZGFwdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNyZWF0ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRhcHRlciByZXF1aXJlcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHByb21pc2UuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRhcHRlciByZXF1aXJlcyBhIGZ1bmN0aW9uIHRvIHJlc29sdmUgYSBwcm9taXNlLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWRhcHRlciByZXF1aXJlcyBhIGZ1bmN0aW9uIHRvIHJlamVjdCBhIHByb21pc2UuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VBZGFwdGVyO1xyXG4iXSwibmFtZXMiOlsiUHJvbWlzZUFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsInJlc29sdmUiLCJyZWplY3QiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/errors/batch.js":
/*!***********************************************!*\
  !*** ./node_modules/spex/lib/errors/batch.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    u: __webpack_require__(/*! util */ \"util\"),\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils/static */ \"(rsc)/./node_modules/spex/lib/utils/static.js\")\n};\n/**\r\n * @class errors.BatchError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link batch}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `BatchError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * It represents the message of the first error encountered in the batch, and is a safe\r\n * version of using `first.message`.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {array} data\r\n * Array of objects `{success, result, [origin]}`:\r\n * - `success` = true/false, indicates whether the corresponding value in the input array was resolved.\r\n * - `result` = resolved data, if `success`=`true`, or else the rejection reason.\r\n * - `origin` - set only when failed as a result of an unsuccessful call into the notification callback\r\n *    (parameter `cb` of method {@link batch})\r\n *\r\n * The array has the same size as the input one that was passed into method {@link batch}, providing direct mapping.\r\n *\r\n * @property {} stat\r\n * Resolution Statistics.\r\n *\r\n * @property {number} stat.total\r\n * Total number of elements in the batch.\r\n *\r\n * @property {number} stat.succeeded\r\n * Number of resolved values in the batch.\r\n *\r\n * @property {number} stat.failed\r\n * Number of rejected values in the batch.\r\n *\r\n * @property {number} stat.duration\r\n * Time in milliseconds it took to settle all values.\r\n *\r\n * @property {} first\r\n * The very first error within the batch, with support for nested batch results, it is also the same error\r\n * as $[promise.all] would provide.\r\n *\r\n * @see {@link batch}\r\n *\r\n */ class BatchError extends Error {\n    constructor(result, errors, duration){\n        function getErrors() {\n            const err = new Array(errors.length);\n            for(let i = 0; i < errors.length; i++){\n                err[i] = result[errors[i]].result;\n                if (err[i] instanceof BatchError) {\n                    err[i] = err[i].getErrors();\n                }\n            }\n            npm.utils.extend(err, \"$isErrorList\", true);\n            return err;\n        }\n        const e = getErrors();\n        let first = e[0];\n        while(first && first.$isErrorList){\n            first = first[0];\n        }\n        let message;\n        if (first instanceof Error) {\n            message = first.message;\n        } else {\n            if (typeof first !== \"string\") {\n                first = npm.u.inspect(first);\n            }\n            message = first;\n        }\n        super(message);\n        this.name = this.constructor.name;\n        this.data = result;\n        // we do not show it within the inspect, because when the error\n        // happens for a nested result, the output becomes a mess.\n        this.first = first;\n        this.stat = {\n            total: result.length,\n            succeeded: result.length - e.length,\n            failed: e.length,\n            duration: duration\n        };\n        this.getErrors = getErrors;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.BatchError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * The output is an abbreviated version of the error, because the complete error\r\n * is often too much for displaying or even logging, as a batch can be of any size.\r\n * Therefore, only errors are rendered from the `data` property, alongside their indexes,\r\n * and only up to the first 5, to avoid polluting the screen or the log file.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ BatchError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), gap2 = npm.utils.messageGap(level + 2), lines = [\n        \"BatchError {\",\n        gap1 + \"stat: { total: \" + this.stat.total + \", succeeded: \" + this.stat.succeeded + \", failed: \" + this.stat.failed + \", duration: \" + this.stat.duration + \" }\",\n        gap1 + \"errors: [\"\n    ];\n    // In order to avoid polluting the error log or the console, \n    // we limit the log output to the top 5 errors:\n    const maxErrors = 5;\n    let counter = 0;\n    this.data.forEach((d, index)=>{\n        if (!d.success && counter < maxErrors) {\n            lines.push(gap2 + index + \": \" + npm.utils.formatError(d.result, level + 2));\n            counter++;\n        }\n    });\n    lines.push(gap1 + \"]\");\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(BatchError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    BatchError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL2JhdGNoLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxNQUFNO0lBQ1JDLEdBQUdDLG1CQUFPQSxDQUFDO0lBQ1hDLElBQUlELG1CQUFPQSxDQUFDO0lBQ1pFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpREMsR0FDRCxNQUFNRyxtQkFBbUJDO0lBRXJCQyxZQUFZQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxDQUFFO1FBRWxDLFNBQVNDO1lBQ0wsTUFBTUMsTUFBTSxJQUFJQyxNQUFNSixPQUFPSyxNQUFNO1lBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixPQUFPSyxNQUFNLEVBQUVDLElBQUs7Z0JBQ3BDSCxHQUFHLENBQUNHLEVBQUUsR0FBR1AsTUFBTSxDQUFDQyxNQUFNLENBQUNNLEVBQUUsQ0FBQyxDQUFDUCxNQUFNO2dCQUNqQyxJQUFJSSxHQUFHLENBQUNHLEVBQUUsWUFBWVYsWUFBWTtvQkFDOUJPLEdBQUcsQ0FBQ0csRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUUsQ0FBQ0osU0FBUztnQkFDN0I7WUFDSjtZQUNBWCxJQUFJSSxLQUFLLENBQUNZLE1BQU0sQ0FBQ0osS0FBSyxnQkFBZ0I7WUFDdEMsT0FBT0E7UUFDWDtRQUVBLE1BQU1LLElBQUlOO1FBRVYsSUFBSU8sUUFBUUQsQ0FBQyxDQUFDLEVBQUU7UUFFaEIsTUFBT0MsU0FBU0EsTUFBTUMsWUFBWSxDQUFFO1lBQ2hDRCxRQUFRQSxLQUFLLENBQUMsRUFBRTtRQUNwQjtRQUVBLElBQUlFO1FBRUosSUFBSUYsaUJBQWlCWixPQUFPO1lBQ3hCYyxVQUFVRixNQUFNRSxPQUFPO1FBQzNCLE9BQU87WUFDSCxJQUFJLE9BQU9GLFVBQVUsVUFBVTtnQkFDM0JBLFFBQVFsQixJQUFJQyxDQUFDLENBQUNvQixPQUFPLENBQUNIO1lBQzFCO1lBQ0FFLFVBQVVGO1FBQ2Q7UUFFQSxLQUFLLENBQUNFO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUcsSUFBSSxDQUFDZixXQUFXLENBQUNlLElBQUk7UUFFakMsSUFBSSxDQUFDQyxJQUFJLEdBQUdmO1FBRVosK0RBQStEO1FBQy9ELDBEQUEwRDtRQUMxRCxJQUFJLENBQUNVLEtBQUssR0FBR0E7UUFFYixJQUFJLENBQUNNLElBQUksR0FBRztZQUNSQyxPQUFPakIsT0FBT00sTUFBTTtZQUNwQlksV0FBV2xCLE9BQU9NLE1BQU0sR0FBR0csRUFBRUgsTUFBTTtZQUNuQ2EsUUFBUVYsRUFBRUgsTUFBTTtZQUNoQkosVUFBVUE7UUFDZDtRQUVBLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUVqQkwsTUFBTXNCLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNyQixXQUFXO0lBQ2xEO0FBV0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNERixXQUFXd0IsU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBVUMsS0FBSztJQUMzQ0EsUUFBUUEsUUFBUSxJQUFJQyxTQUFTRCxTQUFTO0lBQ3RDLE1BQU1FLE9BQU9qQyxJQUFJSSxLQUFLLENBQUM4QixVQUFVLENBQUNILFFBQzlCSSxPQUFPbkMsSUFBSUksS0FBSyxDQUFDOEIsVUFBVSxDQUFDSCxRQUFRLElBQ3BDSyxPQUFPcEMsSUFBSUksS0FBSyxDQUFDOEIsVUFBVSxDQUFDSCxRQUFRLElBQ3BDTSxRQUFRO1FBQ0o7UUFDQUYsT0FBTyxvQkFBb0IsSUFBSSxDQUFDWCxJQUFJLENBQUNDLEtBQUssR0FBRyxrQkFBa0IsSUFBSSxDQUFDRCxJQUFJLENBQUNFLFNBQVMsR0FDbEYsZUFBZSxJQUFJLENBQUNGLElBQUksQ0FBQ0csTUFBTSxHQUFHLGlCQUFpQixJQUFJLENBQUNILElBQUksQ0FBQ2QsUUFBUSxHQUFHO1FBQ3hFeUIsT0FBTztLQUNWO0lBRUwsNkRBQTZEO0lBQzdELCtDQUErQztJQUMvQyxNQUFNRyxZQUFZO0lBQ2xCLElBQUlDLFVBQVU7SUFDZCxJQUFJLENBQUNoQixJQUFJLENBQUNpQixPQUFPLENBQUMsQ0FBQ0MsR0FBR0M7UUFDbEIsSUFBSSxDQUFDRCxFQUFFRSxPQUFPLElBQUlKLFVBQVVELFdBQVc7WUFDbkNELE1BQU1PLElBQUksQ0FBQ1IsT0FBT00sUUFBUSxPQUFPMUMsSUFBSUksS0FBSyxDQUFDeUMsV0FBVyxDQUFDSixFQUFFakMsTUFBTSxFQUFFdUIsUUFBUTtZQUN6RVE7UUFDSjtJQUNKO0lBQ0FGLE1BQU1PLElBQUksQ0FBQ1QsT0FBTztJQUNsQkUsTUFBTU8sSUFBSSxDQUFDWCxPQUFPO0lBQ2xCLE9BQU9JLE1BQU1TLElBQUksQ0FBQzlDLElBQUlHLEVBQUUsQ0FBQzRDLEdBQUc7QUFDaEM7QUFFQS9DLElBQUlJLEtBQUssQ0FBQzRDLGFBQWEsQ0FBQzNDLFlBQVk7SUFDaEMsT0FBTyxJQUFJLENBQUN5QixRQUFRO0FBQ3hCO0FBRUFtQixPQUFPQyxPQUFPLEdBQUc7SUFBQzdDO0FBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi9lcnJvcnMvYmF0Y2guanM/NTRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBucG0gPSB7XHJcbiAgICB1OiByZXF1aXJlKCd1dGlsJyksXHJcbiAgICBvczogcmVxdWlyZSgnb3MnKSxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuLi91dGlscy9zdGF0aWMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBlcnJvcnMuQmF0Y2hFcnJvclxyXG4gKiBAYXVnbWVudHMgZXh0ZXJuYWw6RXJyb3JcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCBlcnJvcnMgcmVqZWN0ZWQgYnkgbWV0aG9kIHtAbGluayBiYXRjaH0sIGV4Y2VwdCBmb3Ige0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9XHJcbiAqIHdoZW4gdGhlIG1ldGhvZCByZWNlaXZlcyBpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSBlcnJvciB0eXBlIG5hbWUgPSBgQmF0Y2hFcnJvcmAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogSXQgcmVwcmVzZW50cyB0aGUgbWVzc2FnZSBvZiB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgaW4gdGhlIGJhdGNoLCBhbmQgaXMgYSBzYWZlXHJcbiAqIHZlcnNpb24gb2YgdXNpbmcgYGZpcnN0Lm1lc3NhZ2VgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhY2tcclxuICogU3RhbmRhcmQge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSBwcm9wZXJ0eSAtIHRoZSBzdGFjayB0cmFjZS5cclxuICpcclxuICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxyXG4gKiBBcnJheSBvZiBvYmplY3RzIGB7c3VjY2VzcywgcmVzdWx0LCBbb3JpZ2luXX1gOlxyXG4gKiAtIGBzdWNjZXNzYCA9IHRydWUvZmFsc2UsIGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGluIHRoZSBpbnB1dCBhcnJheSB3YXMgcmVzb2x2ZWQuXHJcbiAqIC0gYHJlc3VsdGAgPSByZXNvbHZlZCBkYXRhLCBpZiBgc3VjY2Vzc2A9YHRydWVgLCBvciBlbHNlIHRoZSByZWplY3Rpb24gcmVhc29uLlxyXG4gKiAtIGBvcmlnaW5gIC0gc2V0IG9ubHkgd2hlbiBmYWlsZWQgYXMgYSByZXN1bHQgb2YgYW4gdW5zdWNjZXNzZnVsIGNhbGwgaW50byB0aGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXHJcbiAqICAgIChwYXJhbWV0ZXIgYGNiYCBvZiBtZXRob2Qge0BsaW5rIGJhdGNofSlcclxuICpcclxuICogVGhlIGFycmF5IGhhcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBpbnB1dCBvbmUgdGhhdCB3YXMgcGFzc2VkIGludG8gbWV0aG9kIHtAbGluayBiYXRjaH0sIHByb3ZpZGluZyBkaXJlY3QgbWFwcGluZy5cclxuICpcclxuICogQHByb3BlcnR5IHt9IHN0YXRcclxuICogUmVzb2x1dGlvbiBTdGF0aXN0aWNzLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhdC50b3RhbFxyXG4gKiBUb3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGJhdGNoLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhdC5zdWNjZWVkZWRcclxuICogTnVtYmVyIG9mIHJlc29sdmVkIHZhbHVlcyBpbiB0aGUgYmF0Y2guXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGF0LmZhaWxlZFxyXG4gKiBOdW1iZXIgb2YgcmVqZWN0ZWQgdmFsdWVzIGluIHRoZSBiYXRjaC5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXQuZHVyYXRpb25cclxuICogVGltZSBpbiBtaWxsaXNlY29uZHMgaXQgdG9vayB0byBzZXR0bGUgYWxsIHZhbHVlcy5cclxuICpcclxuICogQHByb3BlcnR5IHt9IGZpcnN0XHJcbiAqIFRoZSB2ZXJ5IGZpcnN0IGVycm9yIHdpdGhpbiB0aGUgYmF0Y2gsIHdpdGggc3VwcG9ydCBmb3IgbmVzdGVkIGJhdGNoIHJlc3VsdHMsIGl0IGlzIGFsc28gdGhlIHNhbWUgZXJyb3JcclxuICogYXMgJFtwcm9taXNlLmFsbF0gd291bGQgcHJvdmlkZS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgYmF0Y2h9XHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBCYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCwgZXJyb3JzLCBkdXJhdGlvbikge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRFcnJvcnMoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBBcnJheShlcnJvcnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVycltpXSA9IHJlc3VsdFtlcnJvcnNbaV1dLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJbaV0gaW5zdGFuY2VvZiBCYXRjaEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyW2ldID0gZXJyW2ldLmdldEVycm9ycygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5wbS51dGlscy5leHRlbmQoZXJyLCAnJGlzRXJyb3JMaXN0JywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlID0gZ2V0RXJyb3JzKCk7XHJcblxyXG4gICAgICAgIGxldCBmaXJzdCA9IGVbMF07XHJcblxyXG4gICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC4kaXNFcnJvckxpc3QpIHtcclxuICAgICAgICAgICAgZmlyc3QgPSBmaXJzdFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtZXNzYWdlO1xyXG5cclxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gZmlyc3QubWVzc2FnZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBucG0udS5pbnNwZWN0KGZpcnN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXNzYWdlID0gZmlyc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YSA9IHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gd2UgZG8gbm90IHNob3cgaXQgd2l0aGluIHRoZSBpbnNwZWN0LCBiZWNhdXNlIHdoZW4gdGhlIGVycm9yXHJcbiAgICAgICAgLy8gaGFwcGVucyBmb3IgYSBuZXN0ZWQgcmVzdWx0LCB0aGUgb3V0cHV0IGJlY29tZXMgYSBtZXNzLlxyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBmaXJzdDtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ID0ge1xyXG4gICAgICAgICAgICB0b3RhbDogcmVzdWx0Lmxlbmd0aCxcclxuICAgICAgICAgICAgc3VjY2VlZGVkOiByZXN1bHQubGVuZ3RoIC0gZS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGZhaWxlZDogZS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0RXJyb3JzID0gZ2V0RXJyb3JzO1xyXG5cclxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZXJyb3JzLkJhdGNoRXJyb3IuZ2V0RXJyb3JzXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgZXJyb3JzIG9ubHkuXHJcbiAgICAgKlxyXG4gICAgICogSXQgc3VwcG9ydHMgbmVzdGVkIGJhdGNoIHJlc3VsdHMsIHByZXNlbnRlZCBhcyBhIHN1Yi1hcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9XHJcbiAgICAgKi9cclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXJyb3JzLkJhdGNoRXJyb3IudG9TdHJpbmdcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB3ZWxsLWZvcm1hdHRlZCBtdWx0aS1saW5lIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGVycm9yLlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBUaGUgb3V0cHV0IGlzIGFuIGFiYnJldmlhdGVkIHZlcnNpb24gb2YgdGhlIGVycm9yLCBiZWNhdXNlIHRoZSBjb21wbGV0ZSBlcnJvclxyXG4gKiBpcyBvZnRlbiB0b28gbXVjaCBmb3IgZGlzcGxheWluZyBvciBldmVuIGxvZ2dpbmcsIGFzIGEgYmF0Y2ggY2FuIGJlIG9mIGFueSBzaXplLlxyXG4gKiBUaGVyZWZvcmUsIG9ubHkgZXJyb3JzIGFyZSByZW5kZXJlZCBmcm9tIHRoZSBgZGF0YWAgcHJvcGVydHksIGFsb25nc2lkZSB0aGVpciBpbmRleGVzLFxyXG4gKiBhbmQgb25seSB1cCB0byB0aGUgZmlyc3QgNSwgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBzY3JlZW4gb3IgdGhlIGxvZyBmaWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbkJhdGNoRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICBsZXZlbCA9IGxldmVsID4gMCA/IHBhcnNlSW50KGxldmVsKSA6IDA7XHJcbiAgICBjb25zdCBnYXAwID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwpLFxyXG4gICAgICAgIGdhcDEgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCArIDEpLFxyXG4gICAgICAgIGdhcDIgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCArIDIpLFxyXG4gICAgICAgIGxpbmVzID0gW1xyXG4gICAgICAgICAgICAnQmF0Y2hFcnJvciB7JyxcclxuICAgICAgICAgICAgZ2FwMSArICdzdGF0OiB7IHRvdGFsOiAnICsgdGhpcy5zdGF0LnRvdGFsICsgJywgc3VjY2VlZGVkOiAnICsgdGhpcy5zdGF0LnN1Y2NlZWRlZCArXHJcbiAgICAgICAgICAgICcsIGZhaWxlZDogJyArIHRoaXMuc3RhdC5mYWlsZWQgKyAnLCBkdXJhdGlvbjogJyArIHRoaXMuc3RhdC5kdXJhdGlvbiArICcgfScsXHJcbiAgICAgICAgICAgIGdhcDEgKyAnZXJyb3JzOiBbJ1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBlcnJvciBsb2cgb3IgdGhlIGNvbnNvbGUsIFxyXG4gICAgLy8gd2UgbGltaXQgdGhlIGxvZyBvdXRwdXQgdG8gdGhlIHRvcCA1IGVycm9yczpcclxuICAgIGNvbnN0IG1heEVycm9ycyA9IDU7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaCgoZCwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoIWQuc3VjY2VzcyAmJiBjb3VudGVyIDwgbWF4RXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2goZ2FwMiArIGluZGV4ICsgJzogJyArIG5wbS51dGlscy5mb3JtYXRFcnJvcihkLnJlc3VsdCwgbGV2ZWwgKyAyKSk7XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxpbmVzLnB1c2goZ2FwMSArICddJyk7XHJcbiAgICBsaW5lcy5wdXNoKGdhcDAgKyAnfScpO1xyXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obnBtLm9zLkVPTCk7XHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkSW5zcGVjdGlvbihCYXRjaEVycm9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge0JhdGNoRXJyb3J9O1xyXG5cclxuIl0sIm5hbWVzIjpbIm5wbSIsInUiLCJyZXF1aXJlIiwib3MiLCJ1dGlscyIsIkJhdGNoRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwicmVzdWx0IiwiZXJyb3JzIiwiZHVyYXRpb24iLCJnZXRFcnJvcnMiLCJlcnIiLCJBcnJheSIsImxlbmd0aCIsImkiLCJleHRlbmQiLCJlIiwiZmlyc3QiLCIkaXNFcnJvckxpc3QiLCJtZXNzYWdlIiwiaW5zcGVjdCIsIm5hbWUiLCJkYXRhIiwic3RhdCIsInRvdGFsIiwic3VjY2VlZGVkIiwiZmFpbGVkIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImxldmVsIiwicGFyc2VJbnQiLCJnYXAwIiwibWVzc2FnZUdhcCIsImdhcDEiLCJnYXAyIiwibGluZXMiLCJtYXhFcnJvcnMiLCJjb3VudGVyIiwiZm9yRWFjaCIsImQiLCJpbmRleCIsInN1Y2Nlc3MiLCJwdXNoIiwiZm9ybWF0RXJyb3IiLCJqb2luIiwiRU9MIiwiYWRkSW5zcGVjdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/errors/batch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/errors/index.js":
/*!***********************************************!*\
  !*** ./node_modules/spex/lib/errors/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { BatchError } = __webpack_require__(/*! ./batch */ \"(rsc)/./node_modules/spex/lib/errors/batch.js\");\nconst { PageError } = __webpack_require__(/*! ./page */ \"(rsc)/./node_modules/spex/lib/errors/page.js\");\nconst { SequenceError } = __webpack_require__(/*! ./sequence */ \"(rsc)/./node_modules/spex/lib/errors/sequence.js\");\n/**\r\n * @namespace errors\r\n * @description\r\n * Namespace for all custom error types supported by the library.\r\n *\r\n * In addition to the custom error type used by each method (regular error), they can also reject with\r\n * {@link external:TypeError TypeError} when receiving invalid input parameters.\r\n *\r\n * @property {function} BatchError\r\n * {@link errors.BatchError BatchError} class.\r\n *\r\n * Represents regular errors that can be reported by method {@link batch}.\r\n *\r\n * @property {function} PageError\r\n * {@link errors.PageError PageError} class.\r\n *\r\n * Represents regular errors that can be reported by method {@link page}.\r\n *\r\n * @property {function} SequenceError\r\n * {@link errors.SequenceError SequenceError} class.\r\n *\r\n * Represents regular errors that can be reported by method {@link sequence}.\r\n *\r\n */ module.exports = {\n    BatchError,\n    PageError,\n    SequenceError\n};\nObject.freeze(module.exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUNBLFVBQVUsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUNDLFNBQVMsRUFBQyxHQUFHRCxtQkFBT0EsQ0FBQztBQUM1QixNQUFNLEVBQUNFLGFBQWEsRUFBQyxHQUFHRixtQkFBT0EsQ0FBQztBQUdoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDREcsT0FBT0MsT0FBTyxHQUFHO0lBQ2JMO0lBQ0FFO0lBQ0FDO0FBQ0o7QUFFQUcsT0FBT0MsTUFBTSxDQUFDSCxPQUFPQyxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL2luZGV4LmpzPzc1ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge0JhdGNoRXJyb3J9ID0gcmVxdWlyZSgnLi9iYXRjaCcpO1xyXG5jb25zdCB7UGFnZUVycm9yfSA9IHJlcXVpcmUoJy4vcGFnZScpO1xyXG5jb25zdCB7U2VxdWVuY2VFcnJvcn0gPSByZXF1aXJlKCcuL3NlcXVlbmNlJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgZXJyb3JzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBOYW1lc3BhY2UgZm9yIGFsbCBjdXN0b20gZXJyb3IgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgY3VzdG9tIGVycm9yIHR5cGUgdXNlZCBieSBlYWNoIG1ldGhvZCAocmVndWxhciBlcnJvciksIHRoZXkgY2FuIGFsc28gcmVqZWN0IHdpdGhcclxuICoge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9IHdoZW4gcmVjZWl2aW5nIGludmFsaWQgaW5wdXQgcGFyYW1ldGVycy5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gQmF0Y2hFcnJvclxyXG4gKiB7QGxpbmsgZXJyb3JzLkJhdGNoRXJyb3IgQmF0Y2hFcnJvcn0gY2xhc3MuXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgcmVndWxhciBlcnJvcnMgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgbWV0aG9kIHtAbGluayBiYXRjaH0uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFBhZ2VFcnJvclxyXG4gKiB7QGxpbmsgZXJyb3JzLlBhZ2VFcnJvciBQYWdlRXJyb3J9IGNsYXNzLlxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIHJlZ3VsYXIgZXJyb3JzIHRoYXQgY2FuIGJlIHJlcG9ydGVkIGJ5IG1ldGhvZCB7QGxpbmsgcGFnZX0uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFNlcXVlbmNlRXJyb3JcclxuICoge0BsaW5rIGVycm9ycy5TZXF1ZW5jZUVycm9yIFNlcXVlbmNlRXJyb3J9IGNsYXNzLlxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIHJlZ3VsYXIgZXJyb3JzIHRoYXQgY2FuIGJlIHJlcG9ydGVkIGJ5IG1ldGhvZCB7QGxpbmsgc2VxdWVuY2V9LlxyXG4gKlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBCYXRjaEVycm9yLFxyXG4gICAgUGFnZUVycm9yLFxyXG4gICAgU2VxdWVuY2VFcnJvclxyXG59O1xyXG5cclxuT2JqZWN0LmZyZWV6ZShtb2R1bGUuZXhwb3J0cyk7XHJcbiJdLCJuYW1lcyI6WyJCYXRjaEVycm9yIiwicmVxdWlyZSIsIlBhZ2VFcnJvciIsIlNlcXVlbmNlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/errors/page.js":
/*!**********************************************!*\
  !*** ./node_modules/spex/lib/errors/page.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    u: __webpack_require__(/*! util */ \"util\"),\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils/static */ \"(rsc)/./node_modules/spex/lib/utils/static.js\")\n};\nconst errorReasons = {\n    0: \"Page with index %d rejected.\",\n    1: \"Source %s returned a rejection at index %d.\",\n    2: \"Source %s threw an error at index %d.\",\n    3: \"Destination %s returned a rejection at index %d.\",\n    4: \"Destination %s threw an error at index %d.\",\n    5: \"Source %s returned a non-array value at index %d.\"\n};\n/**\r\n * @class errors.PageError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link page}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `PageError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {} error\r\n * The error that was thrown, or the rejection reason.\r\n *\r\n * @property {number} index\r\n * Index of the element in the sequence for which the error/rejection occurred.\r\n *\r\n * @property {number} duration\r\n * Duration (in milliseconds) of processing until the error/rejection occurred.\r\n *\r\n * @property {string} reason\r\n * Textual explanation of why the method failed.\r\n *\r\n * @property {} source\r\n * Resolved `data` parameter that was passed into the `source` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `source` function.\r\n *\r\n * @property {} dest\r\n * Resolved `data` parameter that was passed into the `dest` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `dest` function.\r\n *\r\n * @see\r\n * {@link page},\r\n * {@link batch}\r\n *\r\n */ class PageError extends Error {\n    constructor(e, code, cbName, duration){\n        let message;\n        if (e.error instanceof Error) {\n            message = e.error.message;\n        } else {\n            message = e.error;\n            if (typeof message !== \"string\") {\n                message = npm.u.inspect(message);\n            }\n        }\n        super(message);\n        this.name = this.constructor.name;\n        this.index = e.index;\n        this.duration = duration;\n        this.error = e.error;\n        if (\"source\" in e) {\n            this.source = e.source;\n        }\n        if (\"dest\" in e) {\n            this.dest = e.dest;\n        }\n        if (code) {\n            cbName = cbName ? \"'\" + cbName + \"'\" : \"<anonymous>\";\n            this.reason = npm.u.format(errorReasons[code], cbName, e.index);\n        } else {\n            this.reason = npm.u.format(errorReasons[code], e.index);\n        }\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.PageError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ PageError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        \"PageError {\",\n        gap1 + \"message: \" + JSON.stringify(this.message),\n        gap1 + \"reason: \" + this.reason,\n        gap1 + \"index: \" + this.index,\n        gap1 + \"duration: \" + this.duration\n    ];\n    lines.push(gap1 + \"error: \" + npm.utils.formatError(this.error, level + 1));\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(PageError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    PageError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL3BhZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU07SUFDUkMsR0FBR0MsbUJBQU9BLENBQUM7SUFDWEMsSUFBSUQsbUJBQU9BLENBQUM7SUFDWkUsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkI7QUFFQSxNQUFNRyxlQUFlO0lBQ2pCLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztBQUNQO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBDQyxHQUNELE1BQU1DLGtCQUFrQkM7SUFFcEJDLFlBQVlDLENBQUMsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsQ0FBRTtRQUVuQyxJQUFJQztRQUNKLElBQUlKLEVBQUVLLEtBQUssWUFBWVAsT0FBTztZQUMxQk0sVUFBVUosRUFBRUssS0FBSyxDQUFDRCxPQUFPO1FBQzdCLE9BQU87WUFDSEEsVUFBVUosRUFBRUssS0FBSztZQUNqQixJQUFJLE9BQU9ELFlBQVksVUFBVTtnQkFDN0JBLFVBQVViLElBQUlDLENBQUMsQ0FBQ2MsT0FBTyxDQUFDRjtZQUM1QjtRQUNKO1FBQ0EsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0csSUFBSSxHQUFHLElBQUksQ0FBQ1IsV0FBVyxDQUFDUSxJQUFJO1FBRWpDLElBQUksQ0FBQ0MsS0FBSyxHQUFHUixFQUFFUSxLQUFLO1FBQ3BCLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNFLEtBQUssR0FBR0wsRUFBRUssS0FBSztRQUVwQixJQUFJLFlBQVlMLEdBQUc7WUFDZixJQUFJLENBQUNTLE1BQU0sR0FBR1QsRUFBRVMsTUFBTTtRQUMxQjtRQUVBLElBQUksVUFBVVQsR0FBRztZQUNiLElBQUksQ0FBQ1UsSUFBSSxHQUFHVixFQUFFVSxJQUFJO1FBQ3RCO1FBRUEsSUFBSVQsTUFBTTtZQUNOQyxTQUFTQSxTQUFVLE1BQU9BLFNBQVMsTUFBUTtZQUMzQyxJQUFJLENBQUNTLE1BQU0sR0FBR3BCLElBQUlDLENBQUMsQ0FBQ29CLE1BQU0sQ0FBQ2hCLFlBQVksQ0FBQ0ssS0FBSyxFQUFFQyxRQUFRRixFQUFFUSxLQUFLO1FBQ2xFLE9BQU87WUFDSCxJQUFJLENBQUNHLE1BQU0sR0FBR3BCLElBQUlDLENBQUMsQ0FBQ29CLE1BQU0sQ0FBQ2hCLFlBQVksQ0FBQ0ssS0FBSyxFQUFFRCxFQUFFUSxLQUFLO1FBQzFEO1FBRUFWLE1BQU1lLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNkLFdBQVc7SUFDbEQ7QUFFSjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0RGLFVBQVVpQixTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFVQyxLQUFLO0lBRTFDQSxRQUFRQSxRQUFRLElBQUlDLFNBQVNELFNBQVM7SUFFdEMsTUFBTUUsT0FBTzNCLElBQUlJLEtBQUssQ0FBQ3dCLFVBQVUsQ0FBQ0gsUUFDOUJJLE9BQU83QixJQUFJSSxLQUFLLENBQUN3QixVQUFVLENBQUNILFFBQVEsSUFDcENLLFFBQVE7UUFDSjtRQUNBRCxPQUFPLGNBQWNFLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNuQixPQUFPO1FBQ2hEZ0IsT0FBTyxhQUFhLElBQUksQ0FBQ1QsTUFBTTtRQUMvQlMsT0FBTyxZQUFZLElBQUksQ0FBQ1osS0FBSztRQUM3QlksT0FBTyxlQUFlLElBQUksQ0FBQ2pCLFFBQVE7S0FDdEM7SUFFTGtCLE1BQU1HLElBQUksQ0FBQ0osT0FBTyxZQUFZN0IsSUFBSUksS0FBSyxDQUFDOEIsV0FBVyxDQUFDLElBQUksQ0FBQ3BCLEtBQUssRUFBRVcsUUFBUTtJQUN4RUssTUFBTUcsSUFBSSxDQUFDTixPQUFPO0lBQ2xCLE9BQU9HLE1BQU1LLElBQUksQ0FBQ25DLElBQUlHLEVBQUUsQ0FBQ2lDLEdBQUc7QUFDaEM7QUFFQXBDLElBQUlJLEtBQUssQ0FBQ2lDLGFBQWEsQ0FBQy9CLFdBQVc7SUFDL0IsT0FBTyxJQUFJLENBQUNrQixRQUFRO0FBQ3hCO0FBRUFjLE9BQU9DLE9BQU8sR0FBRztJQUFDakM7QUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3NwZXgvbGliL2Vycm9ycy9wYWdlLmpzPzg1YmYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbnBtID0ge1xyXG4gICAgdTogcmVxdWlyZSgndXRpbCcpLFxyXG4gICAgb3M6IHJlcXVpcmUoJ29zJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vdXRpbHMvc3RhdGljJylcclxufTtcclxuXHJcbmNvbnN0IGVycm9yUmVhc29ucyA9IHtcclxuICAgIDA6ICdQYWdlIHdpdGggaW5kZXggJWQgcmVqZWN0ZWQuJyxcclxuICAgIDE6ICdTb3VyY2UgJXMgcmV0dXJuZWQgYSByZWplY3Rpb24gYXQgaW5kZXggJWQuJyxcclxuICAgIDI6ICdTb3VyY2UgJXMgdGhyZXcgYW4gZXJyb3IgYXQgaW5kZXggJWQuJyxcclxuICAgIDM6ICdEZXN0aW5hdGlvbiAlcyByZXR1cm5lZCBhIHJlamVjdGlvbiBhdCBpbmRleCAlZC4nLFxyXG4gICAgNDogJ0Rlc3RpbmF0aW9uICVzIHRocmV3IGFuIGVycm9yIGF0IGluZGV4ICVkLicsXHJcbiAgICA1OiAnU291cmNlICVzIHJldHVybmVkIGEgbm9uLWFycmF5IHZhbHVlIGF0IGluZGV4ICVkLidcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgZXJyb3JzLlBhZ2VFcnJvclxyXG4gKiBAYXVnbWVudHMgZXh0ZXJuYWw6RXJyb3JcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCBlcnJvcnMgcmVqZWN0ZWQgYnkgbWV0aG9kIHtAbGluayBwYWdlfSwgZXhjZXB0IGZvciB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn1cclxuICogd2hlbiB0aGUgbWV0aG9kIHJlY2VpdmVzIGludmFsaWQgaW5wdXQgcGFyYW1ldGVycy5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcclxuICogU3RhbmRhcmQge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSBwcm9wZXJ0eSAtIGVycm9yIHR5cGUgbmFtZSA9IGBQYWdlRXJyb3JgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZVxyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFja1xyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIHN0YWNrIHRyYWNlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge30gZXJyb3JcclxuICogVGhlIGVycm9yIHRoYXQgd2FzIHRocm93biwgb3IgdGhlIHJlamVjdGlvbiByZWFzb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxyXG4gKiBJbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UgZm9yIHdoaWNoIHRoZSBlcnJvci9yZWplY3Rpb24gb2NjdXJyZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblxyXG4gKiBEdXJhdGlvbiAoaW4gbWlsbGlzZWNvbmRzKSBvZiBwcm9jZXNzaW5nIHVudGlsIHRoZSBlcnJvci9yZWplY3Rpb24gb2NjdXJyZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZWFzb25cclxuICogVGV4dHVhbCBleHBsYW5hdGlvbiBvZiB3aHkgdGhlIG1ldGhvZCBmYWlsZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7fSBzb3VyY2VcclxuICogUmVzb2x2ZWQgYGRhdGFgIHBhcmFtZXRlciB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgYHNvdXJjZWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEl0IGlzIG9ubHkgc2V0IHdoZW4gdGhlIGVycm9yL3JlamVjdGlvbiBvY2N1cnJlZCBpbnNpZGUgdGhlIGBzb3VyY2VgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge30gZGVzdFxyXG4gKiBSZXNvbHZlZCBgZGF0YWAgcGFyYW1ldGVyIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBgZGVzdGAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEl0IGlzIG9ubHkgc2V0IHdoZW4gdGhlIGVycm9yL3JlamVjdGlvbiBvY2N1cnJlZCBpbnNpZGUgdGhlIGBkZXN0YCBmdW5jdGlvbi5cclxuICpcclxuICogQHNlZVxyXG4gKiB7QGxpbmsgcGFnZX0sXHJcbiAqIHtAbGluayBiYXRjaH1cclxuICpcclxuICovXHJcbmNsYXNzIFBhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlLCBjb2RlLCBjYk5hbWUsIGR1cmF0aW9uKSB7XHJcblxyXG4gICAgICAgIGxldCBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChlLmVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGUuZXJyb3IubWVzc2FnZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gZS5lcnJvcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG5wbS51Lmluc3BlY3QobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cclxuICAgICAgICB0aGlzLmluZGV4ID0gZS5pbmRleDtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGUuZXJyb3I7XHJcblxyXG4gICAgICAgIGlmICgnc291cmNlJyBpbiBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gZS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ2Rlc3QnIGluIGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXN0ID0gZS5kZXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvZGUpIHtcclxuICAgICAgICAgICAgY2JOYW1lID0gY2JOYW1lID8gKCdcXCcnICsgY2JOYW1lICsgJ1xcJycpIDogJzxhbm9ueW1vdXM+JztcclxuICAgICAgICAgICAgdGhpcy5yZWFzb24gPSBucG0udS5mb3JtYXQoZXJyb3JSZWFzb25zW2NvZGVdLCBjYk5hbWUsIGUuaW5kZXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhc29uID0gbnBtLnUuZm9ybWF0KGVycm9yUmVhc29uc1tjb2RlXSwgZS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGVycm9ycy5QYWdlRXJyb3IudG9TdHJpbmdcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB3ZWxsLWZvcm1hdHRlZCBtdWx0aS1saW5lIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGVycm9yLlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblBhZ2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuXHJcbiAgICBsZXZlbCA9IGxldmVsID4gMCA/IHBhcnNlSW50KGxldmVsKSA6IDA7XHJcblxyXG4gICAgY29uc3QgZ2FwMCA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsKSxcclxuICAgICAgICBnYXAxID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwgKyAxKSxcclxuICAgICAgICBsaW5lcyA9IFtcclxuICAgICAgICAgICAgJ1BhZ2VFcnJvciB7JyxcclxuICAgICAgICAgICAgZ2FwMSArICdtZXNzYWdlOiAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5tZXNzYWdlKSxcclxuICAgICAgICAgICAgZ2FwMSArICdyZWFzb246ICcgKyB0aGlzLnJlYXNvbixcclxuICAgICAgICAgICAgZ2FwMSArICdpbmRleDogJyArIHRoaXMuaW5kZXgsXHJcbiAgICAgICAgICAgIGdhcDEgKyAnZHVyYXRpb246ICcgKyB0aGlzLmR1cmF0aW9uXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICBsaW5lcy5wdXNoKGdhcDEgKyAnZXJyb3I6ICcgKyBucG0udXRpbHMuZm9ybWF0RXJyb3IodGhpcy5lcnJvciwgbGV2ZWwgKyAxKSk7XHJcbiAgICBsaW5lcy5wdXNoKGdhcDAgKyAnfScpO1xyXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obnBtLm9zLkVPTCk7XHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkSW5zcGVjdGlvbihQYWdlRXJyb3IsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7UGFnZUVycm9yfTtcclxuXHJcbiJdLCJuYW1lcyI6WyJucG0iLCJ1IiwicmVxdWlyZSIsIm9zIiwidXRpbHMiLCJlcnJvclJlYXNvbnMiLCJQYWdlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiZSIsImNvZGUiLCJjYk5hbWUiLCJkdXJhdGlvbiIsIm1lc3NhZ2UiLCJlcnJvciIsImluc3BlY3QiLCJuYW1lIiwiaW5kZXgiLCJzb3VyY2UiLCJkZXN0IiwicmVhc29uIiwiZm9ybWF0IiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImxldmVsIiwicGFyc2VJbnQiLCJnYXAwIiwibWVzc2FnZUdhcCIsImdhcDEiLCJsaW5lcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwdXNoIiwiZm9ybWF0RXJyb3IiLCJqb2luIiwiRU9MIiwiYWRkSW5zcGVjdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/errors/page.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/errors/sequence.js":
/*!**************************************************!*\
  !*** ./node_modules/spex/lib/errors/sequence.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    u: __webpack_require__(/*! util */ \"util\"),\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils/static */ \"(rsc)/./node_modules/spex/lib/utils/static.js\")\n};\nconst errorReasons = {\n    0: \"Source %s returned a rejection at index %d.\",\n    1: \"Source %s threw an error at index %d.\",\n    2: \"Destination %s returned a rejection at index %d.\",\n    3: \"Destination %s threw an error at index %d.\"\n};\n/**\r\n * @class errors.SequenceError\r\n * @augments external:Error\r\n * @description\r\n * This type represents all errors rejected by method {@link sequence}, except for {@link external:TypeError TypeError}\r\n * when the method receives invalid input parameters.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `SequenceError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {} error\r\n * The error that was thrown or the rejection reason.\r\n *\r\n * @property {number} index\r\n * Index of the element in the sequence for which the error/rejection occurred.\r\n *\r\n * @property {number} duration\r\n * Duration (in milliseconds) of processing until the error/rejection occurred.\r\n *\r\n * @property {string} reason\r\n * Textual explanation of why the method failed.\r\n *\r\n * @property {} source\r\n * Resolved `data` parameter that was passed into the `source` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `source` function.\r\n *\r\n * @property {} dest\r\n * Resolved `data` parameter that was passed into the `dest` function.\r\n *\r\n * It is only set when the error/rejection occurred inside the `dest` function.\r\n *\r\n * @see {@link sequence}\r\n *\r\n */ class SequenceError extends Error {\n    constructor(e, code, cbName, duration){\n        let message;\n        if (e.error instanceof Error) {\n            message = e.error.message;\n        } else {\n            message = e.error;\n            if (typeof message !== \"string\") {\n                message = npm.u.inspect(message);\n            }\n        }\n        super(message);\n        this.name = this.constructor.name;\n        this.index = e.index;\n        this.duration = duration;\n        this.error = e.error;\n        if (\"source\" in e) {\n            this.source = e.source;\n        } else {\n            this.dest = e.dest;\n        }\n        cbName = cbName ? \"'\" + cbName + \"'\" : \"<anonymous>\";\n        this.reason = npm.u.format(errorReasons[code], cbName, e.index);\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.SequenceError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ SequenceError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        \"SequenceError {\",\n        gap1 + \"message: \" + JSON.stringify(this.message),\n        gap1 + \"reason: \" + this.reason,\n        gap1 + \"index: \" + this.index,\n        gap1 + \"duration: \" + this.duration\n    ];\n    lines.push(gap1 + \"error: \" + npm.utils.formatError(this.error, level + 1));\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(SequenceError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    SequenceError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL3NlcXVlbmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxNQUFNO0lBQ1JDLEdBQUdDLG1CQUFPQSxDQUFDO0lBQ1hDLElBQUlELG1CQUFPQSxDQUFDO0lBQ1pFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUEsTUFBTUcsZUFBZTtJQUNqQixHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0FBQ1A7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdDQyxHQUNELE1BQU1DLHNCQUFzQkM7SUFFeEJDLFlBQVlDLENBQUMsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsQ0FBRTtRQUVuQyxJQUFJQztRQUNKLElBQUlKLEVBQUVLLEtBQUssWUFBWVAsT0FBTztZQUMxQk0sVUFBVUosRUFBRUssS0FBSyxDQUFDRCxPQUFPO1FBQzdCLE9BQU87WUFDSEEsVUFBVUosRUFBRUssS0FBSztZQUNqQixJQUFJLE9BQU9ELFlBQVksVUFBVTtnQkFDN0JBLFVBQVViLElBQUlDLENBQUMsQ0FBQ2MsT0FBTyxDQUFDRjtZQUM1QjtRQUNKO1FBRUEsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0csSUFBSSxHQUFHLElBQUksQ0FBQ1IsV0FBVyxDQUFDUSxJQUFJO1FBRWpDLElBQUksQ0FBQ0MsS0FBSyxHQUFHUixFQUFFUSxLQUFLO1FBQ3BCLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNFLEtBQUssR0FBR0wsRUFBRUssS0FBSztRQUVwQixJQUFJLFlBQVlMLEdBQUc7WUFDZixJQUFJLENBQUNTLE1BQU0sR0FBR1QsRUFBRVMsTUFBTTtRQUMxQixPQUFPO1lBQ0gsSUFBSSxDQUFDQyxJQUFJLEdBQUdWLEVBQUVVLElBQUk7UUFDdEI7UUFFQVIsU0FBU0EsU0FBVSxNQUFPQSxTQUFTLE1BQVE7UUFDM0MsSUFBSSxDQUFDUyxNQUFNLEdBQUdwQixJQUFJQyxDQUFDLENBQUNvQixNQUFNLENBQUNoQixZQUFZLENBQUNLLEtBQUssRUFBRUMsUUFBUUYsRUFBRVEsS0FBSztRQUU5RFYsTUFBTWUsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ2QsV0FBVztJQUNsRDtBQUNKO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDREYsY0FBY2lCLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVVDLEtBQUs7SUFFOUNBLFFBQVFBLFFBQVEsSUFBSUMsU0FBU0QsU0FBUztJQUV0QyxNQUFNRSxPQUFPM0IsSUFBSUksS0FBSyxDQUFDd0IsVUFBVSxDQUFDSCxRQUM5QkksT0FBTzdCLElBQUlJLEtBQUssQ0FBQ3dCLFVBQVUsQ0FBQ0gsUUFBUSxJQUNwQ0ssUUFBUTtRQUNKO1FBQ0FELE9BQU8sY0FBY0UsS0FBS0MsU0FBUyxDQUFDLElBQUksQ0FBQ25CLE9BQU87UUFDaERnQixPQUFPLGFBQWEsSUFBSSxDQUFDVCxNQUFNO1FBQy9CUyxPQUFPLFlBQVksSUFBSSxDQUFDWixLQUFLO1FBQzdCWSxPQUFPLGVBQWUsSUFBSSxDQUFDakIsUUFBUTtLQUN0QztJQUVMa0IsTUFBTUcsSUFBSSxDQUFDSixPQUFPLFlBQVk3QixJQUFJSSxLQUFLLENBQUM4QixXQUFXLENBQUMsSUFBSSxDQUFDcEIsS0FBSyxFQUFFVyxRQUFRO0lBQ3hFSyxNQUFNRyxJQUFJLENBQUNOLE9BQU87SUFDbEIsT0FBT0csTUFBTUssSUFBSSxDQUFDbkMsSUFBSUcsRUFBRSxDQUFDaUMsR0FBRztBQUNoQztBQUVBcEMsSUFBSUksS0FBSyxDQUFDaUMsYUFBYSxDQUFDL0IsZUFBZTtJQUNuQyxPQUFPLElBQUksQ0FBQ2tCLFFBQVE7QUFDeEI7QUFFQWMsT0FBT0MsT0FBTyxHQUFHO0lBQUNqQztBQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXJyb3JzL3NlcXVlbmNlLmpzP2Q2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbnBtID0ge1xyXG4gICAgdTogcmVxdWlyZSgndXRpbCcpLFxyXG4gICAgb3M6IHJlcXVpcmUoJ29zJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vdXRpbHMvc3RhdGljJylcclxufTtcclxuXHJcbmNvbnN0IGVycm9yUmVhc29ucyA9IHtcclxuICAgIDA6ICdTb3VyY2UgJXMgcmV0dXJuZWQgYSByZWplY3Rpb24gYXQgaW5kZXggJWQuJyxcclxuICAgIDE6ICdTb3VyY2UgJXMgdGhyZXcgYW4gZXJyb3IgYXQgaW5kZXggJWQuJyxcclxuICAgIDI6ICdEZXN0aW5hdGlvbiAlcyByZXR1cm5lZCBhIHJlamVjdGlvbiBhdCBpbmRleCAlZC4nLFxyXG4gICAgMzogJ0Rlc3RpbmF0aW9uICVzIHRocmV3IGFuIGVycm9yIGF0IGluZGV4ICVkLidcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgZXJyb3JzLlNlcXVlbmNlRXJyb3JcclxuICogQGF1Z21lbnRzIGV4dGVybmFsOkVycm9yXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbGwgZXJyb3JzIHJlamVjdGVkIGJ5IG1ldGhvZCB7QGxpbmsgc2VxdWVuY2V9LCBleGNlcHQgZm9yIHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfVxyXG4gKiB3aGVuIHRoZSBtZXRob2QgcmVjZWl2ZXMgaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gZXJyb3IgdHlwZSBuYW1lID0gYFNlcXVlbmNlRXJyb3JgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZVxyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFja1xyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIHN0YWNrIHRyYWNlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge30gZXJyb3JcclxuICogVGhlIGVycm9yIHRoYXQgd2FzIHRocm93biBvciB0aGUgcmVqZWN0aW9uIHJlYXNvbi5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XHJcbiAqIEluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZSBmb3Igd2hpY2ggdGhlIGVycm9yL3JlamVjdGlvbiBvY2N1cnJlZC5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAqIER1cmF0aW9uIChpbiBtaWxsaXNlY29uZHMpIG9mIHByb2Nlc3NpbmcgdW50aWwgdGhlIGVycm9yL3JlamVjdGlvbiBvY2N1cnJlZC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlYXNvblxyXG4gKiBUZXh0dWFsIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGUgbWV0aG9kIGZhaWxlZC5cclxuICpcclxuICogQHByb3BlcnR5IHt9IHNvdXJjZVxyXG4gKiBSZXNvbHZlZCBgZGF0YWAgcGFyYW1ldGVyIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBgc291cmNlYCBmdW5jdGlvbi5cclxuICpcclxuICogSXQgaXMgb25seSBzZXQgd2hlbiB0aGUgZXJyb3IvcmVqZWN0aW9uIG9jY3VycmVkIGluc2lkZSB0aGUgYHNvdXJjZWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7fSBkZXN0XHJcbiAqIFJlc29sdmVkIGBkYXRhYCBwYXJhbWV0ZXIgdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIGBkZXN0YCBmdW5jdGlvbi5cclxuICpcclxuICogSXQgaXMgb25seSBzZXQgd2hlbiB0aGUgZXJyb3IvcmVqZWN0aW9uIG9jY3VycmVkIGluc2lkZSB0aGUgYGRlc3RgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBzZXF1ZW5jZX1cclxuICpcclxuICovXHJcbmNsYXNzIFNlcXVlbmNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZSwgY29kZSwgY2JOYW1lLCBkdXJhdGlvbikge1xyXG5cclxuICAgICAgICBsZXQgbWVzc2FnZTtcclxuICAgICAgICBpZiAoZS5lcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlLmVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGUuZXJyb3I7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBucG0udS5pbnNwZWN0KG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXggPSBlLmluZGV4O1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLmVycm9yID0gZS5lcnJvcjtcclxuXHJcbiAgICAgICAgaWYgKCdzb3VyY2UnIGluIGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBlLnNvdXJjZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRlc3QgPSBlLmRlc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYk5hbWUgPSBjYk5hbWUgPyAoJ1xcJycgKyBjYk5hbWUgKyAnXFwnJykgOiAnPGFub255bW91cz4nO1xyXG4gICAgICAgIHRoaXMucmVhc29uID0gbnBtLnUuZm9ybWF0KGVycm9yUmVhc29uc1tjb2RlXSwgY2JOYW1lLCBlLmluZGV4KTtcclxuXHJcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGVycm9ycy5TZXF1ZW5jZUVycm9yLnRvU3RyaW5nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgd2VsbC1mb3JtYXR0ZWQgbXVsdGktbGluZSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBlcnJvci5cclxuICpcclxuICogSXQgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB3cml0aW5nIHRoZSBvYmplY3QgaW50byB0aGUgY29uc29sZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbD0wXVxyXG4gKiBOZXN0ZWQgb3V0cHV0IGxldmVsLCB0byBwcm92aWRlIHZpc3VhbCBvZmZzZXQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5TZXF1ZW5jZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChsZXZlbCkge1xyXG5cclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuXHJcbiAgICBjb25zdCBnYXAwID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwpLFxyXG4gICAgICAgIGdhcDEgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCArIDEpLFxyXG4gICAgICAgIGxpbmVzID0gW1xyXG4gICAgICAgICAgICAnU2VxdWVuY2VFcnJvciB7JyxcclxuICAgICAgICAgICAgZ2FwMSArICdtZXNzYWdlOiAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5tZXNzYWdlKSxcclxuICAgICAgICAgICAgZ2FwMSArICdyZWFzb246ICcgKyB0aGlzLnJlYXNvbixcclxuICAgICAgICAgICAgZ2FwMSArICdpbmRleDogJyArIHRoaXMuaW5kZXgsXHJcbiAgICAgICAgICAgIGdhcDEgKyAnZHVyYXRpb246ICcgKyB0aGlzLmR1cmF0aW9uXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICBsaW5lcy5wdXNoKGdhcDEgKyAnZXJyb3I6ICcgKyBucG0udXRpbHMuZm9ybWF0RXJyb3IodGhpcy5lcnJvciwgbGV2ZWwgKyAxKSk7XHJcbiAgICBsaW5lcy5wdXNoKGdhcDAgKyAnfScpO1xyXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obnBtLm9zLkVPTCk7XHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkSW5zcGVjdGlvbihTZXF1ZW5jZUVycm9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1NlcXVlbmNlRXJyb3J9O1xyXG5cclxuIl0sIm5hbWVzIjpbIm5wbSIsInUiLCJyZXF1aXJlIiwib3MiLCJ1dGlscyIsImVycm9yUmVhc29ucyIsIlNlcXVlbmNlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiZSIsImNvZGUiLCJjYk5hbWUiLCJkdXJhdGlvbiIsIm1lc3NhZ2UiLCJlcnJvciIsImluc3BlY3QiLCJuYW1lIiwiaW5kZXgiLCJzb3VyY2UiLCJkZXN0IiwicmVhc29uIiwiZm9ybWF0IiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImxldmVsIiwicGFyc2VJbnQiLCJnYXAwIiwibWVzc2FnZUdhcCIsImdhcDEiLCJsaW5lcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwdXNoIiwiZm9ybWF0RXJyb3IiLCJqb2luIiwiRU9MIiwiYWRkSW5zcGVjdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/errors/sequence.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/ext/batch.js":
/*!********************************************!*\
  !*** ./node_modules/spex/lib/ext/batch.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { BatchError } = __webpack_require__(/*! ../errors/batch */ \"(rsc)/./node_modules/spex/lib/errors/batch.js\");\n/**\r\n * @method batch\r\n * @description\r\n * Settles (resolves or rejects) every [mixed value]{@tutorial mixed} in the input array.\r\n *\r\n * The method resolves with an array of results, the same as the standard $[promise.all],\r\n * while providing comprehensive error details in case of a reject, in the form of\r\n * type {@link errors.BatchError BatchError}.\r\n *\r\n * @param {Array} values\r\n * Array of [mixed values]{@tutorial mixed} (it can be empty), to be resolved asynchronously, in no particular order.\r\n *\r\n * Passing in anything other than an array will reject with {@link external:TypeError TypeError} =\r\n * `Method 'batch' requires an array of values.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.cb]\r\n * Optional callback (or generator) to receive the result for each settled value.\r\n *\r\n * Callback Parameters:\r\n *  - `index` = index of the value in the source array\r\n *  - `success` - indicates whether the value was resolved (`true`), or rejected (`false`)\r\n *  - `result` = resolved data, if `success`=`true`, or else the rejection reason\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise to indicate that notifications are handled asynchronously.\r\n * And if the returned promise resolves, it signals a successful handling, while any resolved\r\n * data is ignored.\r\n *\r\n * If the function returns a rejected promise or throws an error, the entire method rejects\r\n * with {@link errors.BatchError BatchError} where the corresponding value in property `data`\r\n * is set to `{success, result, origin}`:\r\n *  - `success` = `false`\r\n *  - `result` = the rejection reason or the error thrown by the notification callback\r\n *  - `origin` = the original data passed into the callback as object `{success, result}`\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * The method resolves with an array of individual resolved results, the same as the standard $[promise.all].\r\n * In addition, the array is extended with a hidden read-only property `duration` - number of milliseconds\r\n * spent resolving all the data.\r\n *\r\n * The method rejects with {@link errors.BatchError BatchError} when any of the following occurs:\r\n *  - one or more values rejected or threw an error while being resolved as a [mixed value]{@tutorial mixed}\r\n *  - notification callback `cb` returned a rejected promise or threw an error\r\n *\r\n */ function batch(values, options, config) {\n    const $p = config.promise, utils = config.utils;\n    if (!Array.isArray(values)) {\n        return $p.reject(new TypeError(\"Method 'batch' requires an array of values.\"));\n    }\n    if (!values.length) {\n        const empty = [];\n        utils.extend(empty, \"duration\", 0);\n        return $p.resolve(empty);\n    }\n    options = options || {};\n    const cb = utils.wrap(options.cb), self = this, start = Date.now();\n    return $p((resolve, reject)=>{\n        let cbTime, remaining = values.length;\n        const errors = [], result = new Array(remaining);\n        values.forEach((item, i)=>{\n            utils.resolve.call(self, item, null, (data)=>{\n                result[i] = data;\n                step(i, true, data);\n            }, (reason)=>{\n                result[i] = {\n                    success: false,\n                    result: reason\n                };\n                errors.push(i);\n                step(i, false, reason);\n            });\n        });\n        function step(idx, pass, data) {\n            if (cb) {\n                const cbNow = Date.now(), cbDelay = idx ? cbNow - cbTime : undefined;\n                let cbResult;\n                cbTime = cbNow;\n                try {\n                    cbResult = cb.call(self, idx, pass, data, cbDelay);\n                } catch (e) {\n                    setError(e);\n                }\n                if (utils.isPromise(cbResult)) {\n                    cbResult.then(check).catch((error)=>{\n                        setError(error);\n                        check();\n                    });\n                } else {\n                    check();\n                }\n            } else {\n                check();\n            }\n            function setError(e) {\n                const r = pass ? {\n                    success: false\n                } : result[idx];\n                if (pass) {\n                    result[idx] = r;\n                    errors.push(idx);\n                }\n                r.result = e;\n                r.origin = {\n                    success: pass,\n                    result: data\n                };\n            }\n            function check() {\n                if (!--remaining) {\n                    if (errors.length) {\n                        errors.sort();\n                        if (errors.length < result.length) {\n                            for(let i = 0, k = 0; i < result.length; i++){\n                                if (i === errors[k]) {\n                                    k++;\n                                } else {\n                                    result[i] = {\n                                        success: true,\n                                        result: result[i]\n                                    };\n                                }\n                            }\n                        }\n                        reject(new BatchError(result, errors, Date.now() - start));\n                    } else {\n                        utils.extend(result, \"duration\", Date.now() - start);\n                        resolve(result);\n                    }\n                }\n                return null; // this dummy return is just to prevent Bluebird warnings;\n            }\n        }\n    });\n}\nmodule.exports = function(config) {\n    return function(values, options) {\n        return batch.call(this, values, options, config);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXh0L2JhdGNoLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUNBLFVBQVUsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrREMsR0FDRCxTQUFTQyxNQUFNQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTTtJQUVsQyxNQUFNQyxLQUFLRCxPQUFPRSxPQUFPLEVBQUVDLFFBQVFILE9BQU9HLEtBQUs7SUFFL0MsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNQLFNBQVM7UUFDeEIsT0FBT0csR0FBR0ssTUFBTSxDQUFDLElBQUlDLFVBQVU7SUFDbkM7SUFFQSxJQUFJLENBQUNULE9BQU9VLE1BQU0sRUFBRTtRQUNoQixNQUFNQyxRQUFRLEVBQUU7UUFDaEJOLE1BQU1PLE1BQU0sQ0FBQ0QsT0FBTyxZQUFZO1FBQ2hDLE9BQU9SLEdBQUdVLE9BQU8sQ0FBQ0Y7SUFDdEI7SUFFQVYsVUFBVUEsV0FBVyxDQUFDO0lBRXRCLE1BQU1hLEtBQUtULE1BQU1VLElBQUksQ0FBQ2QsUUFBUWEsRUFBRSxHQUM1QkUsT0FBTyxJQUFJLEVBQUVDLFFBQVFDLEtBQUtDLEdBQUc7SUFFakMsT0FBT2hCLEdBQUcsQ0FBQ1UsU0FBU0w7UUFDaEIsSUFBSVksUUFBUUMsWUFBWXJCLE9BQU9VLE1BQU07UUFDckMsTUFBTVksU0FBUyxFQUFFLEVBQUVDLFNBQVMsSUFBSWpCLE1BQU1lO1FBQ3RDckIsT0FBT3dCLE9BQU8sQ0FBQyxDQUFDQyxNQUFNQztZQUNsQnJCLE1BQU1RLE9BQU8sQ0FBQ2MsSUFBSSxDQUFDWCxNQUFNUyxNQUFNLE1BQU1HLENBQUFBO2dCQUNqQ0wsTUFBTSxDQUFDRyxFQUFFLEdBQUdFO2dCQUNaQyxLQUFLSCxHQUFHLE1BQU1FO1lBQ2xCLEdBQUdFLENBQUFBO2dCQUNDUCxNQUFNLENBQUNHLEVBQUUsR0FBRztvQkFBQ0ssU0FBUztvQkFBT1IsUUFBUU87Z0JBQU07Z0JBQzNDUixPQUFPVSxJQUFJLENBQUNOO2dCQUNaRyxLQUFLSCxHQUFHLE9BQU9JO1lBQ25CO1FBQ0o7UUFFQSxTQUFTRCxLQUFLSSxHQUFHLEVBQUVDLElBQUksRUFBRU4sSUFBSTtZQUN6QixJQUFJZCxJQUFJO2dCQUNKLE1BQU1xQixRQUFRakIsS0FBS0MsR0FBRyxJQUNsQmlCLFVBQVVILE1BQU9FLFFBQVFmLFNBQVVpQjtnQkFDdkMsSUFBSUM7Z0JBQ0psQixTQUFTZTtnQkFDVCxJQUFJO29CQUNBRyxXQUFXeEIsR0FBR2EsSUFBSSxDQUFDWCxNQUFNaUIsS0FBS0MsTUFBTU4sTUFBTVE7Z0JBQzlDLEVBQUUsT0FBT0csR0FBRztvQkFDUkMsU0FBU0Q7Z0JBQ2I7Z0JBQ0EsSUFBSWxDLE1BQU1vQyxTQUFTLENBQUNILFdBQVc7b0JBQzNCQSxTQUNLSSxJQUFJLENBQUNDLE9BQ0xDLEtBQUssQ0FBQ0MsQ0FBQUE7d0JBQ0hMLFNBQVNLO3dCQUNURjtvQkFDSjtnQkFDUixPQUFPO29CQUNIQTtnQkFDSjtZQUNKLE9BQU87Z0JBQ0hBO1lBQ0o7WUFFQSxTQUFTSCxTQUFTRCxDQUFDO2dCQUNmLE1BQU1PLElBQUlaLE9BQU87b0JBQUNILFNBQVM7Z0JBQUssSUFBSVIsTUFBTSxDQUFDVSxJQUFJO2dCQUMvQyxJQUFJQyxNQUFNO29CQUNOWCxNQUFNLENBQUNVLElBQUksR0FBR2E7b0JBQ2R4QixPQUFPVSxJQUFJLENBQUNDO2dCQUNoQjtnQkFDQWEsRUFBRXZCLE1BQU0sR0FBR2dCO2dCQUNYTyxFQUFFQyxNQUFNLEdBQUc7b0JBQUNoQixTQUFTRztvQkFBTVgsUUFBUUs7Z0JBQUk7WUFDM0M7WUFFQSxTQUFTZTtnQkFDTCxJQUFJLENBQUMsRUFBRXRCLFdBQVc7b0JBQ2QsSUFBSUMsT0FBT1osTUFBTSxFQUFFO3dCQUNmWSxPQUFPMEIsSUFBSTt3QkFDWCxJQUFJMUIsT0FBT1osTUFBTSxHQUFHYSxPQUFPYixNQUFNLEVBQUU7NEJBQy9CLElBQUssSUFBSWdCLElBQUksR0FBR3VCLElBQUksR0FBR3ZCLElBQUlILE9BQU9iLE1BQU0sRUFBRWdCLElBQUs7Z0NBQzNDLElBQUlBLE1BQU1KLE1BQU0sQ0FBQzJCLEVBQUUsRUFBRTtvQ0FDakJBO2dDQUNKLE9BQU87b0NBQ0gxQixNQUFNLENBQUNHLEVBQUUsR0FBRzt3Q0FBQ0ssU0FBUzt3Q0FBTVIsUUFBUUEsTUFBTSxDQUFDRyxFQUFFO29DQUFBO2dDQUNqRDs0QkFDSjt3QkFDSjt3QkFDQWxCLE9BQU8sSUFBSVgsV0FBVzBCLFFBQVFELFFBQVFKLEtBQUtDLEdBQUcsS0FBS0Y7b0JBQ3ZELE9BQU87d0JBQ0haLE1BQU1PLE1BQU0sQ0FBQ1csUUFBUSxZQUFZTCxLQUFLQyxHQUFHLEtBQUtGO3dCQUM5Q0osUUFBUVU7b0JBQ1o7Z0JBQ0o7Z0JBQ0EsT0FBTyxNQUFNLDBEQUEwRDtZQUMzRTtRQUNKO0lBQ0o7QUFDSjtBQUVBMkIsT0FBT0MsT0FBTyxHQUFHLFNBQVVqRCxNQUFNO0lBQzdCLE9BQU8sU0FBVUYsTUFBTSxFQUFFQyxPQUFPO1FBQzVCLE9BQU9GLE1BQU00QixJQUFJLENBQUMsSUFBSSxFQUFFM0IsUUFBUUMsU0FBU0M7SUFDN0M7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3NwZXgvbGliL2V4dC9iYXRjaC5qcz83ZGQwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtCYXRjaEVycm9yfSA9IHJlcXVpcmUoJy4uL2Vycm9ycy9iYXRjaCcpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYmF0Y2hcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNldHRsZXMgKHJlc29sdmVzIG9yIHJlamVjdHMpIGV2ZXJ5IFttaXhlZCB2YWx1ZV17QHR1dG9yaWFsIG1peGVkfSBpbiB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqXHJcbiAqIFRoZSBtZXRob2QgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiByZXN1bHRzLCB0aGUgc2FtZSBhcyB0aGUgc3RhbmRhcmQgJFtwcm9taXNlLmFsbF0sXHJcbiAqIHdoaWxlIHByb3ZpZGluZyBjb21wcmVoZW5zaXZlIGVycm9yIGRldGFpbHMgaW4gY2FzZSBvZiBhIHJlamVjdCwgaW4gdGhlIGZvcm0gb2ZcclxuICogdHlwZSB7QGxpbmsgZXJyb3JzLkJhdGNoRXJyb3IgQmF0Y2hFcnJvcn0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xyXG4gKiBBcnJheSBvZiBbbWl4ZWQgdmFsdWVzXXtAdHV0b3JpYWwgbWl4ZWR9IChpdCBjYW4gYmUgZW1wdHkpLCB0byBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseSwgaW4gbm8gcGFydGljdWxhciBvcmRlci5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGFuIGFycmF5IHdpbGwgcmVqZWN0IHdpdGgge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID1cclxuICogYE1ldGhvZCAnYmF0Y2gnIHJlcXVpcmVzIGFuIGFycmF5IG9mIHZhbHVlcy5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogT3B0aW9uYWwgUGFyYW1ldGVycy5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbnxnZW5lcmF0b3J9IFtvcHRpb25zLmNiXVxyXG4gKiBPcHRpb25hbCBjYWxsYmFjayAob3IgZ2VuZXJhdG9yKSB0byByZWNlaXZlIHRoZSByZXN1bHQgZm9yIGVhY2ggc2V0dGxlZCB2YWx1ZS5cclxuICpcclxuICogQ2FsbGJhY2sgUGFyYW1ldGVyczpcclxuICogIC0gYGluZGV4YCA9IGluZGV4IG9mIHRoZSB2YWx1ZSBpbiB0aGUgc291cmNlIGFycmF5XHJcbiAqICAtIGBzdWNjZXNzYCAtIGluZGljYXRlcyB3aGV0aGVyIHRoZSB2YWx1ZSB3YXMgcmVzb2x2ZWQgKGB0cnVlYCksIG9yIHJlamVjdGVkIChgZmFsc2VgKVxyXG4gKiAgLSBgcmVzdWx0YCA9IHJlc29sdmVkIGRhdGEsIGlmIGBzdWNjZXNzYD1gdHJ1ZWAsIG9yIGVsc2UgdGhlIHJlamVjdGlvbiByZWFzb25cclxuICogIC0gYGRlbGF5YCA9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgY2FsbCAoYHVuZGVmaW5lZGAgd2hlbiBgaW5kZXg9MGApXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBpbmhlcml0cyBgdGhpc2AgY29udGV4dCBmcm9tIHRoZSBjYWxsaW5nIG1ldGhvZC5cclxuICpcclxuICogSXQgY2FuIG9wdGlvbmFsbHkgcmV0dXJuIGEgcHJvbWlzZSB0byBpbmRpY2F0ZSB0aGF0IG5vdGlmaWNhdGlvbnMgYXJlIGhhbmRsZWQgYXN5bmNocm9ub3VzbHkuXHJcbiAqIEFuZCBpZiB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcywgaXQgc2lnbmFscyBhIHN1Y2Nlc3NmdWwgaGFuZGxpbmcsIHdoaWxlIGFueSByZXNvbHZlZFxyXG4gKiBkYXRhIGlzIGlnbm9yZWQuXHJcbiAqXHJcbiAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZSBvciB0aHJvd3MgYW4gZXJyb3IsIHRoZSBlbnRpcmUgbWV0aG9kIHJlamVjdHNcclxuICogd2l0aCB7QGxpbmsgZXJyb3JzLkJhdGNoRXJyb3IgQmF0Y2hFcnJvcn0gd2hlcmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgaW4gcHJvcGVydHkgYGRhdGFgXHJcbiAqIGlzIHNldCB0byBge3N1Y2Nlc3MsIHJlc3VsdCwgb3JpZ2lufWA6XHJcbiAqICAtIGBzdWNjZXNzYCA9IGBmYWxzZWBcclxuICogIC0gYHJlc3VsdGAgPSB0aGUgcmVqZWN0aW9uIHJlYXNvbiBvciB0aGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBub3RpZmljYXRpb24gY2FsbGJhY2tcclxuICogIC0gYG9yaWdpbmAgPSB0aGUgb3JpZ2luYWwgZGF0YSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2sgYXMgb2JqZWN0IGB7c3VjY2VzcywgcmVzdWx0fWBcclxuICpcclxuICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAqXHJcbiAqIFRoZSBtZXRob2QgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBpbmRpdmlkdWFsIHJlc29sdmVkIHJlc3VsdHMsIHRoZSBzYW1lIGFzIHRoZSBzdGFuZGFyZCAkW3Byb21pc2UuYWxsXS5cclxuICogSW4gYWRkaXRpb24sIHRoZSBhcnJheSBpcyBleHRlbmRlZCB3aXRoIGEgaGlkZGVuIHJlYWQtb25seSBwcm9wZXJ0eSBgZHVyYXRpb25gIC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xyXG4gKiBzcGVudCByZXNvbHZpbmcgYWxsIHRoZSBkYXRhLlxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIHJlamVjdHMgd2l0aCB7QGxpbmsgZXJyb3JzLkJhdGNoRXJyb3IgQmF0Y2hFcnJvcn0gd2hlbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBvY2N1cnM6XHJcbiAqICAtIG9uZSBvciBtb3JlIHZhbHVlcyByZWplY3RlZCBvciB0aHJldyBhbiBlcnJvciB3aGlsZSBiZWluZyByZXNvbHZlZCBhcyBhIFttaXhlZCB2YWx1ZV17QHR1dG9yaWFsIG1peGVkfVxyXG4gKiAgLSBub3RpZmljYXRpb24gY2FsbGJhY2sgYGNiYCByZXR1cm5lZCBhIHJlamVjdGVkIHByb21pc2Ugb3IgdGhyZXcgYW4gZXJyb3JcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGJhdGNoKHZhbHVlcywgb3B0aW9ucywgY29uZmlnKSB7XHJcblxyXG4gICAgY29uc3QgJHAgPSBjb25maWcucHJvbWlzZSwgdXRpbHMgPSBjb25maWcudXRpbHM7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICByZXR1cm4gJHAucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ01ldGhvZCBcXCdiYXRjaFxcJyByZXF1aXJlcyBhbiBhcnJheSBvZiB2YWx1ZXMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gW107XHJcbiAgICAgICAgdXRpbHMuZXh0ZW5kKGVtcHR5LCAnZHVyYXRpb24nLCAwKTtcclxuICAgICAgICByZXR1cm4gJHAucmVzb2x2ZShlbXB0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgY29uc3QgY2IgPSB1dGlscy53cmFwKG9wdGlvbnMuY2IpLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzLCBzdGFydCA9IERhdGUubm93KCk7XHJcblxyXG4gICAgcmV0dXJuICRwKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgY2JUaW1lLCByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdLCByZXN1bHQgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcclxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgICAgICB1dGlscy5yZXNvbHZlLmNhbGwoc2VsZiwgaXRlbSwgbnVsbCwgZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgc3RlcChpLCB0cnVlLCBkYXRhKTtcclxuICAgICAgICAgICAgfSwgcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHtzdWNjZXNzOiBmYWxzZSwgcmVzdWx0OiByZWFzb259O1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBzdGVwKGksIGZhbHNlLCByZWFzb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChpZHgsIHBhc3MsIGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYk5vdyA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgY2JEZWxheSA9IGlkeCA/IChjYk5vdyAtIGNiVGltZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2JSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBjYlRpbWUgPSBjYk5vdztcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JSZXN1bHQgPSBjYi5jYWxsKHNlbGYsIGlkeCwgcGFzcywgZGF0YSwgY2JEZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNQcm9taXNlKGNiUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGNoZWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGVjaygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRFcnJvcihlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gcGFzcyA/IHtzdWNjZXNzOiBmYWxzZX0gOiByZXN1bHRbaWR4XTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGlkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByLnJlc3VsdCA9IGU7XHJcbiAgICAgICAgICAgICAgICByLm9yaWdpbiA9IHtzdWNjZXNzOiBwYXNzLCByZXN1bHQ6IGRhdGF9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVjaygpIHtcclxuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA8IHJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBrID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBlcnJvcnNba10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHtzdWNjZXNzOiB0cnVlLCByZXN1bHQ6IHJlc3VsdFtpXX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQmF0Y2hFcnJvcihyZXN1bHQsIGVycm9ycywgRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuZXh0ZW5kKHJlc3VsdCwgJ2R1cmF0aW9uJywgRGF0ZS5ub3coKSAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIGR1bW15IHJldHVybiBpcyBqdXN0IHRvIHByZXZlbnQgQmx1ZWJpcmQgd2FybmluZ3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBiYXRjaC5jYWxsKHRoaXMsIHZhbHVlcywgb3B0aW9ucywgY29uZmlnKTtcclxuICAgIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJCYXRjaEVycm9yIiwicmVxdWlyZSIsImJhdGNoIiwidmFsdWVzIiwib3B0aW9ucyIsImNvbmZpZyIsIiRwIiwicHJvbWlzZSIsInV0aWxzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiVHlwZUVycm9yIiwibGVuZ3RoIiwiZW1wdHkiLCJleHRlbmQiLCJyZXNvbHZlIiwiY2IiLCJ3cmFwIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsImNiVGltZSIsInJlbWFpbmluZyIsImVycm9ycyIsInJlc3VsdCIsImZvckVhY2giLCJpdGVtIiwiaSIsImNhbGwiLCJkYXRhIiwic3RlcCIsInJlYXNvbiIsInN1Y2Nlc3MiLCJwdXNoIiwiaWR4IiwicGFzcyIsImNiTm93IiwiY2JEZWxheSIsInVuZGVmaW5lZCIsImNiUmVzdWx0IiwiZSIsInNldEVycm9yIiwiaXNQcm9taXNlIiwidGhlbiIsImNoZWNrIiwiY2F0Y2giLCJlcnJvciIsInIiLCJvcmlnaW4iLCJzb3J0IiwiayIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/ext/batch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/ext/page.js":
/*!*******************************************!*\
  !*** ./node_modules/spex/lib/ext/page.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { PageError } = __webpack_require__(/*! ../errors/page */ \"(rsc)/./node_modules/spex/lib/errors/page.js\");\n/**\r\n * @method page\r\n * @description\r\n * Resolves a dynamic sequence of pages/arrays with [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires pages (arrays of [mixed values]{@tutorial mixed}) from the `source` function, one by one,\r\n * and resolves each page as a {@link batch}, till no more pages left or an error/reject occurs.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return a [mixed value]{@tutorial mixed} that resolves with the next page of data (array of [mixed values]{@tutorial mixed}).\r\n * Returning or resolving with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the page being requested\r\n *  - `data` = previously returned page, resolved as a {@link batch} (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects with\r\n * {@link errors.PageError PageError}, which will have property `source` set.\r\n *\r\n * And if the function returns or resolves with anything other than an array or `undefined`,\r\n * the method rejects with the same {@link errors.PageError PageError}, but with `error` set to\r\n * `Unexpected data returned from the source.`\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest]\r\n * Optional destination function (or generator), to receive a resolved {@link batch} of data\r\n * for each page, process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = page index in the sequence\r\n *  - `data` = page data resolved as a {@link batch}\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if notifications are handled asynchronously.\r\n * And if a promise is returned, the method will not request another page from the `source`\r\n * function until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.PageError PageError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum number of pages to be requested from the `source`. If the value is greater\r\n * than 0, the method will successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` returns or resolves with `undefined` or an invalid value (non-array)\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the method resolves with object `{pages, total, duration}`:\r\n *  - `pages` = number of pages resolved\r\n *  - `total` = the sum of all page sizes (total number of values resolved)\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When the method fails, it rejects with {@link errors.PageError PageError}.\r\n *\r\n */ function page(source, options, config) {\n    const $p = config.promise, spex = config.spex, utils = config.utils;\n    if (typeof source !== \"function\") {\n        return $p.reject(new TypeError(\"Parameter 'source' must be a function.\"));\n    }\n    options = options || {};\n    source = utils.wrap(source);\n    const limit = options.limit > 0 ? parseInt(options.limit) : 0, dest = utils.wrap(options.dest), self = this, start = Date.now();\n    let request, srcTime, destTime, total = 0;\n    return $p((resolve, reject)=>{\n        function loop(idx) {\n            const srcNow = Date.now(), srcDelay = idx ? srcNow - srcTime : undefined;\n            srcTime = srcNow;\n            utils.resolve.call(self, source, [\n                idx,\n                request,\n                srcDelay\n            ], (value)=>{\n                if (value === undefined) {\n                    success();\n                } else {\n                    if (value instanceof Array) {\n                        spex.batch(value).then((data)=>{\n                            request = data;\n                            total += data.length;\n                            if (dest) {\n                                const destNow = Date.now(), destDelay = idx ? destNow - destTime : undefined;\n                                let destResult;\n                                destTime = destNow;\n                                try {\n                                    destResult = dest.call(self, idx, data, destDelay);\n                                } catch (err) {\n                                    fail({\n                                        error: err,\n                                        dest: data\n                                    }, 4, dest.name);\n                                    return;\n                                }\n                                if (utils.isPromise(destResult)) {\n                                    destResult.then(next).catch((error)=>{\n                                        fail({\n                                            error: error,\n                                            dest: data\n                                        }, 3, dest.name);\n                                    });\n                                } else {\n                                    next();\n                                }\n                            } else {\n                                next();\n                            }\n                            return null; // this dummy return is just to prevent Bluebird warnings;\n                        }).catch((error)=>{\n                            fail({\n                                error: error\n                            }, 0);\n                        });\n                    } else {\n                        fail({\n                            error: new Error(\"Unexpected data returned from the source.\"),\n                            source: request\n                        }, 5, source.name);\n                    }\n                }\n            }, (reason, isRej)=>{\n                fail({\n                    error: reason,\n                    source: request\n                }, isRej ? 1 : 2, source.name);\n            });\n            function next() {\n                if (limit === ++idx) {\n                    success();\n                } else {\n                    loop(idx);\n                }\n                return null; // this dummy return is just to prevent Bluebird warnings;\n            }\n            function success() {\n                resolve({\n                    pages: idx,\n                    total: total,\n                    duration: Date.now() - start\n                });\n            }\n            function fail(reason, code, cbName) {\n                reason.index = idx;\n                reject(new PageError(reason, code, cbName, Date.now() - start));\n            }\n        }\n        loop(0);\n    });\n}\nmodule.exports = function(config) {\n    return function(source, options) {\n        return page.call(this, source, options, config);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXh0L3BhZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sRUFBQ0EsU0FBUyxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUVDLEdBQ0QsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU07SUFFakMsTUFBTUMsS0FBS0QsT0FBT0UsT0FBTyxFQUFFQyxPQUFPSCxPQUFPRyxJQUFJLEVBQUVDLFFBQVFKLE9BQU9JLEtBQUs7SUFFbkUsSUFBSSxPQUFPTixXQUFXLFlBQVk7UUFDOUIsT0FBT0csR0FBR0ksTUFBTSxDQUFDLElBQUlDLFVBQVU7SUFDbkM7SUFFQVAsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCRCxTQUFTTSxNQUFNRyxJQUFJLENBQUNUO0lBRXBCLE1BQU1VLFFBQVEsUUFBU0EsS0FBSyxHQUFHLElBQUtDLFNBQVNWLFFBQVFTLEtBQUssSUFBSSxHQUMxREUsT0FBT04sTUFBTUcsSUFBSSxDQUFDUixRQUFRVyxJQUFJLEdBQUdDLE9BQU8sSUFBSSxFQUFFQyxRQUFRQyxLQUFLQyxHQUFHO0lBQ2xFLElBQUlDLFNBQVNDLFNBQVNDLFVBQVVDLFFBQVE7SUFFeEMsT0FBT2pCLEdBQUcsQ0FBQ2tCLFNBQVNkO1FBRWhCLFNBQVNlLEtBQUtDLEdBQUc7WUFDYixNQUFNQyxTQUFTVCxLQUFLQyxHQUFHLElBQ25CUyxXQUFXRixNQUFPQyxTQUFTTixVQUFXUTtZQUMxQ1IsVUFBVU07WUFDVmxCLE1BQU1lLE9BQU8sQ0FBQ00sSUFBSSxDQUFDZCxNQUFNYixRQUFRO2dCQUFDdUI7Z0JBQUtOO2dCQUFTUTthQUFTLEVBQUVHLENBQUFBO2dCQUN2RCxJQUFJQSxVQUFVRixXQUFXO29CQUNyQkc7Z0JBQ0osT0FBTztvQkFDSCxJQUFJRCxpQkFBaUJFLE9BQU87d0JBQ3hCekIsS0FBSzBCLEtBQUssQ0FBQ0gsT0FDTkksSUFBSSxDQUFDQyxDQUFBQTs0QkFDRmhCLFVBQVVnQjs0QkFDVmIsU0FBU2EsS0FBS0MsTUFBTTs0QkFDcEIsSUFBSXRCLE1BQU07Z0NBQ04sTUFBTXVCLFVBQVVwQixLQUFLQyxHQUFHLElBQ3BCb0IsWUFBWWIsTUFBT1ksVUFBVWhCLFdBQVlPO2dDQUM3QyxJQUFJVztnQ0FDSmxCLFdBQVdnQjtnQ0FDWCxJQUFJO29DQUNBRSxhQUFhekIsS0FBS2UsSUFBSSxDQUFDZCxNQUFNVSxLQUFLVSxNQUFNRztnQ0FDNUMsRUFBRSxPQUFPRSxLQUFLO29DQUNWQyxLQUFLO3dDQUNEQyxPQUFPRjt3Q0FDUDFCLE1BQU1xQjtvQ0FDVixHQUFHLEdBQUdyQixLQUFLNkIsSUFBSTtvQ0FDZjtnQ0FDSjtnQ0FDQSxJQUFJbkMsTUFBTW9DLFNBQVMsQ0FBQ0wsYUFBYTtvQ0FDN0JBLFdBQ0tMLElBQUksQ0FBQ1csTUFDTEMsS0FBSyxDQUFDSixDQUFBQTt3Q0FDSEQsS0FBSzs0Q0FDREMsT0FBT0E7NENBQ1A1QixNQUFNcUI7d0NBQ1YsR0FBRyxHQUFHckIsS0FBSzZCLElBQUk7b0NBQ25CO2dDQUNSLE9BQU87b0NBQ0hFO2dDQUNKOzRCQUNKLE9BQU87Z0NBQ0hBOzRCQUNKOzRCQUNBLE9BQU8sTUFBTSwwREFBMEQ7d0JBQzNFLEdBQ0NDLEtBQUssQ0FBQ0osQ0FBQUE7NEJBQ0hELEtBQUs7Z0NBQ0RDLE9BQU9BOzRCQUNYLEdBQUc7d0JBQ1A7b0JBQ1IsT0FBTzt3QkFDSEQsS0FBSzs0QkFDREMsT0FBTyxJQUFJSyxNQUFNOzRCQUNqQjdDLFFBQVFpQjt3QkFDWixHQUFHLEdBQUdqQixPQUFPeUMsSUFBSTtvQkFDckI7Z0JBQ0o7WUFDSixHQUFHLENBQUNLLFFBQVFDO2dCQUNSUixLQUFLO29CQUNEQyxPQUFPTTtvQkFDUDlDLFFBQVFpQjtnQkFDWixHQUFHOEIsUUFBUSxJQUFJLEdBQUcvQyxPQUFPeUMsSUFBSTtZQUNqQztZQUVBLFNBQVNFO2dCQUNMLElBQUlqQyxVQUFVLEVBQUVhLEtBQUs7b0JBQ2pCTTtnQkFDSixPQUFPO29CQUNIUCxLQUFLQztnQkFDVDtnQkFDQSxPQUFPLE1BQU0sMERBQTBEO1lBQzNFO1lBRUEsU0FBU007Z0JBQ0xSLFFBQVE7b0JBQ0oyQixPQUFPekI7b0JBQ1BILE9BQU9BO29CQUNQNkIsVUFBVWxDLEtBQUtDLEdBQUcsS0FBS0Y7Z0JBQzNCO1lBQ0o7WUFFQSxTQUFTeUIsS0FBS08sTUFBTSxFQUFFSSxJQUFJLEVBQUVDLE1BQU07Z0JBQzlCTCxPQUFPTSxLQUFLLEdBQUc3QjtnQkFDZmhCLE9BQU8sSUFBSVYsVUFBVWlELFFBQVFJLE1BQU1DLFFBQVFwQyxLQUFLQyxHQUFHLEtBQUtGO1lBQzVEO1FBQ0o7UUFFQVEsS0FBSztJQUNUO0FBQ0o7QUFFQStCLE9BQU9DLE9BQU8sR0FBRyxTQUFVcEQsTUFBTTtJQUM3QixPQUFPLFNBQVVGLE1BQU0sRUFBRUMsT0FBTztRQUM1QixPQUFPRixLQUFLNEIsSUFBSSxDQUFDLElBQUksRUFBRTNCLFFBQVFDLFNBQVNDO0lBQzVDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi9leHQvcGFnZS5qcz85NTUxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtQYWdlRXJyb3J9ID0gcmVxdWlyZSgnLi4vZXJyb3JzL3BhZ2UnKTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHBhZ2VcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJlc29sdmVzIGEgZHluYW1pYyBzZXF1ZW5jZSBvZiBwYWdlcy9hcnJheXMgd2l0aCBbbWl4ZWQgdmFsdWVzXXtAdHV0b3JpYWwgbWl4ZWR9LlxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIGFjcXVpcmVzIHBhZ2VzIChhcnJheXMgb2YgW21peGVkIHZhbHVlc117QHR1dG9yaWFsIG1peGVkfSkgZnJvbSB0aGUgYHNvdXJjZWAgZnVuY3Rpb24sIG9uZSBieSBvbmUsXHJcbiAqIGFuZCByZXNvbHZlcyBlYWNoIHBhZ2UgYXMgYSB7QGxpbmsgYmF0Y2h9LCB0aWxsIG5vIG1vcmUgcGFnZXMgbGVmdCBvciBhbiBlcnJvci9yZWplY3Qgb2NjdXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGdlbmVyYXRvcn0gc291cmNlXHJcbiAqIEV4cGVjdGVkIHRvIHJldHVybiBhIFttaXhlZCB2YWx1ZV17QHR1dG9yaWFsIG1peGVkfSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5leHQgcGFnZSBvZiBkYXRhIChhcnJheSBvZiBbbWl4ZWQgdmFsdWVzXXtAdHV0b3JpYWwgbWl4ZWR9KS5cclxuICogUmV0dXJuaW5nIG9yIHJlc29sdmluZyB3aXRoIGB1bmRlZmluZWRgIGVuZHMgdGhlIHNlcXVlbmNlLCBhbmQgdGhlIG1ldGhvZCByZXNvbHZlcy5cclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGluaGVyaXRzIGB0aGlzYCBjb250ZXh0IGZyb20gdGhlIGNhbGxpbmcgbWV0aG9kLlxyXG4gKlxyXG4gKiBQYXJhbWV0ZXJzOlxyXG4gKiAgLSBgaW5kZXhgID0gaW5kZXggb2YgdGhlIHBhZ2UgYmVpbmcgcmVxdWVzdGVkXHJcbiAqICAtIGBkYXRhYCA9IHByZXZpb3VzbHkgcmV0dXJuZWQgcGFnZSwgcmVzb2x2ZWQgYXMgYSB7QGxpbmsgYmF0Y2h9IChgdW5kZWZpbmVkYCB3aGVuIGBpbmRleD0wYClcclxuICogIC0gYGRlbGF5YCA9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgY2FsbCAoYHVuZGVmaW5lZGAgd2hlbiBgaW5kZXg9MGApXHJcbiAqXHJcbiAqIElmIHRoZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3Igb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UsIHRoZSBtZXRob2QgcmVqZWN0cyB3aXRoXHJcbiAqIHtAbGluayBlcnJvcnMuUGFnZUVycm9yIFBhZ2VFcnJvcn0sIHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0eSBgc291cmNlYCBzZXQuXHJcbiAqXHJcbiAqIEFuZCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBvciByZXNvbHZlcyB3aXRoIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gYXJyYXkgb3IgYHVuZGVmaW5lZGAsXHJcbiAqIHRoZSBtZXRob2QgcmVqZWN0cyB3aXRoIHRoZSBzYW1lIHtAbGluayBlcnJvcnMuUGFnZUVycm9yIFBhZ2VFcnJvcn0sIGJ1dCB3aXRoIGBlcnJvcmAgc2V0IHRvXHJcbiAqIGBVbmV4cGVjdGVkIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc291cmNlLmBcclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb24gd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgUGFyYW1ldGVyICdzb3VyY2UnIG11c3QgYmUgYSBmdW5jdGlvbi5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogT3B0aW9uYWwgUGFyYW1ldGVycy5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbnxnZW5lcmF0b3J9IFtvcHRpb25zLmRlc3RdXHJcbiAqIE9wdGlvbmFsIGRlc3RpbmF0aW9uIGZ1bmN0aW9uIChvciBnZW5lcmF0b3IpLCB0byByZWNlaXZlIGEgcmVzb2x2ZWQge0BsaW5rIGJhdGNofSBvZiBkYXRhXHJcbiAqIGZvciBlYWNoIHBhZ2UsIHByb2Nlc3MgaXQgYW5kIHJlc3BvbmQgYXMgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIFBhcmFtZXRlcnM6XHJcbiAqICAtIGBpbmRleGAgPSBwYWdlIGluZGV4IGluIHRoZSBzZXF1ZW5jZVxyXG4gKiAgLSBgZGF0YWAgPSBwYWdlIGRhdGEgcmVzb2x2ZWQgYXMgYSB7QGxpbmsgYmF0Y2h9XHJcbiAqICAtIGBkZWxheWAgPSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGNhbGwgKGB1bmRlZmluZWRgIHdoZW4gYGluZGV4PTBgKVxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gaW5oZXJpdHMgYHRoaXNgIGNvbnRleHQgZnJvbSB0aGUgY2FsbGluZyBtZXRob2QuXHJcbiAqXHJcbiAqIEl0IGNhbiBvcHRpb25hbGx5IHJldHVybiBhIHByb21pc2Ugb2JqZWN0LCBpZiBub3RpZmljYXRpb25zIGFyZSBoYW5kbGVkIGFzeW5jaHJvbm91c2x5LlxyXG4gKiBBbmQgaWYgYSBwcm9taXNlIGlzIHJldHVybmVkLCB0aGUgbWV0aG9kIHdpbGwgbm90IHJlcXVlc3QgYW5vdGhlciBwYWdlIGZyb20gdGhlIGBzb3VyY2VgXHJcbiAqIGZ1bmN0aW9uIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkLlxyXG4gKlxyXG4gKiBJZiB0aGUgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yIG9yIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLCB0aGUgc2VxdWVuY2UgdGVybWluYXRlcyxcclxuICogYW5kIHRoZSBtZXRob2QgcmVqZWN0cyB3aXRoIHtAbGluayBlcnJvcnMuUGFnZUVycm9yIFBhZ2VFcnJvcn0sIHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0eSBgZGVzdGAgc2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGltaXQ9MF1cclxuICogTGltaXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBwYWdlcyB0byBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgYHNvdXJjZWAuIElmIHRoZSB2YWx1ZSBpcyBncmVhdGVyXHJcbiAqIHRoYW4gMCwgdGhlIG1ldGhvZCB3aWxsIHN1Y2Nlc3NmdWxseSByZXNvbHZlIG9uY2UgdGhlIHNwZWNpZmllZCBsaW1pdCBoYXMgYmVlbiByZWFjaGVkLlxyXG4gKlxyXG4gKiBXaGVuIGBsaW1pdGAgaXNuJ3Qgc3BlY2lmaWVkIChkZWZhdWx0KSwgdGhlIHNlcXVlbmNlIGlzIHVubGltaXRlZCwgYW5kIGl0IHdpbGwgY29udGludWVcclxuICogdGlsbCBvbmUgb2YgdGhlIGZvbGxvd2luZyBvY2N1cnM6XHJcbiAqICAtIGBzb3VyY2VgIHJldHVybnMgb3IgcmVzb2x2ZXMgd2l0aCBgdW5kZWZpbmVkYCBvciBhbiBpbnZhbGlkIHZhbHVlIChub24tYXJyYXkpXHJcbiAqICAtIGVpdGhlciBgc291cmNlYCBvciBgZGVzdGAgZnVuY3Rpb25zIHRocm93IGFuIGVycm9yIG9yIHJldHVybiBhIHJlamVjdGVkIHByb21pc2VcclxuICpcclxuICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAqXHJcbiAqIFdoZW4gc3VjY2Vzc2Z1bCwgdGhlIG1ldGhvZCByZXNvbHZlcyB3aXRoIG9iamVjdCBge3BhZ2VzLCB0b3RhbCwgZHVyYXRpb259YDpcclxuICogIC0gYHBhZ2VzYCA9IG51bWJlciBvZiBwYWdlcyByZXNvbHZlZFxyXG4gKiAgLSBgdG90YWxgID0gdGhlIHN1bSBvZiBhbGwgcGFnZSBzaXplcyAodG90YWwgbnVtYmVyIG9mIHZhbHVlcyByZXNvbHZlZClcclxuICogIC0gYGR1cmF0aW9uYCA9IG51bWJlciBvZiBtaWxsaXNlY29uZHMgY29uc3VtZWQgYnkgdGhlIG1ldGhvZFxyXG4gKlxyXG4gKiBXaGVuIHRoZSBtZXRob2QgZmFpbHMsIGl0IHJlamVjdHMgd2l0aCB7QGxpbmsgZXJyb3JzLlBhZ2VFcnJvciBQYWdlRXJyb3J9LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcGFnZShzb3VyY2UsIG9wdGlvbnMsIGNvbmZpZykge1xyXG5cclxuICAgIGNvbnN0ICRwID0gY29uZmlnLnByb21pc2UsIHNwZXggPSBjb25maWcuc3BleCwgdXRpbHMgPSBjb25maWcudXRpbHM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gJHAucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdzb3VyY2VcXCcgbXVzdCBiZSBhIGZ1bmN0aW9uLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHNvdXJjZSA9IHV0aWxzLndyYXAoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBsaW1pdCA9IChvcHRpb25zLmxpbWl0ID4gMCkgPyBwYXJzZUludChvcHRpb25zLmxpbWl0KSA6IDAsXHJcbiAgICAgICAgZGVzdCA9IHV0aWxzLndyYXAob3B0aW9ucy5kZXN0KSwgc2VsZiA9IHRoaXMsIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCByZXF1ZXN0LCBzcmNUaW1lLCBkZXN0VGltZSwgdG90YWwgPSAwO1xyXG5cclxuICAgIHJldHVybiAkcCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvb3AoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNyY05vdyA9IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICBzcmNEZWxheSA9IGlkeCA/IChzcmNOb3cgLSBzcmNUaW1lKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgc3JjVGltZSA9IHNyY05vdztcclxuICAgICAgICAgICAgdXRpbHMucmVzb2x2ZS5jYWxsKHNlbGYsIHNvdXJjZSwgW2lkeCwgcmVxdWVzdCwgc3JjRGVsYXldLCB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BleC5iYXRjaCh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3ROb3cgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdERlbGF5ID0gaWR4ID8gKGRlc3ROb3cgLSBkZXN0VGltZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0VGltZSA9IGRlc3ROb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0UmVzdWx0ID0gZGVzdC5jYWxsKHNlbGYsIGlkeCwgZGF0YSwgZGVzdERlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Q6IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDQsIGRlc3QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzUHJvbWlzZShkZXN0UmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMsIGRlc3QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIGR1bW15IHJldHVybiBpcyBqdXN0IHRvIHByZXZlbnQgQmx1ZWJpcmQgd2FybmluZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzb3VyY2UuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNSwgc291cmNlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKHJlYXNvbiwgaXNSZWopID0+IHtcclxuICAgICAgICAgICAgICAgIGZhaWwoe1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiByZWFzb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB9LCBpc1JlaiA/IDEgOiAyLCBzb3VyY2UubmFtZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gKytpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AoaWR4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIGR1bW15IHJldHVybiBpcyBqdXN0IHRvIHByZXZlbnQgQmx1ZWJpcmQgd2FybmluZ3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlczogaWR4LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbChyZWFzb24sIGNvZGUsIGNiTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmVhc29uLmluZGV4ID0gaWR4O1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQYWdlRXJyb3IocmVhc29uLCBjb2RlLCBjYk5hbWUsIERhdGUubm93KCkgLSBzdGFydCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb29wKDApO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gcGFnZS5jYWxsKHRoaXMsIHNvdXJjZSwgb3B0aW9ucywgY29uZmlnKTtcclxuICAgIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJQYWdlRXJyb3IiLCJyZXF1aXJlIiwicGFnZSIsInNvdXJjZSIsIm9wdGlvbnMiLCJjb25maWciLCIkcCIsInByb21pc2UiLCJzcGV4IiwidXRpbHMiLCJyZWplY3QiLCJUeXBlRXJyb3IiLCJ3cmFwIiwibGltaXQiLCJwYXJzZUludCIsImRlc3QiLCJzZWxmIiwic3RhcnQiLCJEYXRlIiwibm93IiwicmVxdWVzdCIsInNyY1RpbWUiLCJkZXN0VGltZSIsInRvdGFsIiwicmVzb2x2ZSIsImxvb3AiLCJpZHgiLCJzcmNOb3ciLCJzcmNEZWxheSIsInVuZGVmaW5lZCIsImNhbGwiLCJ2YWx1ZSIsInN1Y2Nlc3MiLCJBcnJheSIsImJhdGNoIiwidGhlbiIsImRhdGEiLCJsZW5ndGgiLCJkZXN0Tm93IiwiZGVzdERlbGF5IiwiZGVzdFJlc3VsdCIsImVyciIsImZhaWwiLCJlcnJvciIsIm5hbWUiLCJpc1Byb21pc2UiLCJuZXh0IiwiY2F0Y2giLCJFcnJvciIsInJlYXNvbiIsImlzUmVqIiwicGFnZXMiLCJkdXJhdGlvbiIsImNvZGUiLCJjYk5hbWUiLCJpbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/ext/page.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/ext/sequence.js":
/*!***********************************************!*\
  !*** ./node_modules/spex/lib/ext/sequence.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { SequenceError } = __webpack_require__(/*! ../errors/sequence */ \"(rsc)/./node_modules/spex/lib/errors/sequence.js\");\n/**\r\n * @method sequence\r\n * @description\r\n * Resolves a dynamic sequence of [mixed values]{@tutorial mixed}.\r\n *\r\n * The method acquires [mixed values]{@tutorial mixed} from the `source` function, one at a time, and resolves them,\r\n * till either no more values left in the sequence or an error/reject occurs.\r\n *\r\n * It supports both [linked and detached sequencing]{@tutorial sequencing}.\r\n *\r\n * @param {Function|generator} source\r\n * Expected to return the next [mixed value]{@tutorial mixed} to be resolved. Returning or resolving\r\n * with `undefined` ends the sequence, and the method resolves.\r\n *\r\n * Parameters:\r\n *  - `index` = current request index in the sequence\r\n *  - `data` = resolved data from the previous call (`undefined` when `index=0`)\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `source` set.\r\n *\r\n * Passing in anything other than a function will reject with {@link external:TypeError TypeError} = `Parameter 'source' must be a function.`\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Function|generator} [options.dest=null]\r\n * Optional destination function (or generator), to receive resolved data for each index,\r\n * process it and respond as required.\r\n *\r\n * Parameters:\r\n *  - `index` = index of the resolved data in the sequence\r\n *  - `data` = the data resolved\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function inherits `this` context from the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is done asynchronously.\r\n * If a promise is returned, the method will not request another value from the `source` function,\r\n * until the promise has been resolved (the resolved value is ignored).\r\n *\r\n * If the function throws an error or returns a rejected promise, the sequence terminates,\r\n * and the method rejects with {@link errors.SequenceError SequenceError}, which will have property `dest` set.\r\n *\r\n * @param {Number} [options.limit=0]\r\n * Limits the maximum size of the sequence. If the value is greater than 0, the method will\r\n * successfully resolve once the specified limit has been reached.\r\n *\r\n * When `limit` isn't specified (default), the sequence is unlimited, and it will continue\r\n * till one of the following occurs:\r\n *  - `source` either returns or resolves with `undefined`\r\n *  - either `source` or `dest` functions throw an error or return a rejected promise\r\n *\r\n * @param {Boolean} [options.track=false]\r\n * Changes the type of data to be resolved by this method. By default, it is `false`\r\n * (see the return result). When set to be `true`, the method tracks/collects all resolved data\r\n * into an array internally, and resolves with that array once the method has finished successfully.\r\n *\r\n * It must be used with caution, as to the size of the sequence, because accumulating data for\r\n * a very large sequence can result in consuming too much memory.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When successful, the resolved data depends on parameter `track`. When `track` is `false`\r\n * (default), the method resolves with object `{total, duration}`:\r\n *  - `total` = number of values resolved by the sequence\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When `track` is `true`, the method resolves with an array of all the data that has been resolved,\r\n * the same way that the standard $[promise.all] resolves. In addition, the array comes extended with\r\n * a hidden read-only property `duration` - number of milliseconds consumed by the method.\r\n *\r\n * When the method fails, it rejects with {@link errors.SequenceError SequenceError}.\r\n */ function sequence(source, options, config) {\n    const $p = config.promise, utils = config.utils;\n    if (typeof source !== \"function\") {\n        return $p.reject(new TypeError(\"Parameter 'source' must be a function.\"));\n    }\n    source = utils.wrap(source);\n    options = options || {};\n    const limit = options.limit > 0 ? parseInt(options.limit) : 0, dest = utils.wrap(options.dest), self = this, start = Date.now();\n    let data, srcTime, destTime, result = [];\n    return $p((resolve, reject)=>{\n        function loop(idx) {\n            const srcNow = Date.now(), srcDelay = idx ? srcNow - srcTime : undefined;\n            srcTime = srcNow;\n            utils.resolve.call(self, source, [\n                idx,\n                data,\n                srcDelay\n            ], (value, delayed)=>{\n                data = value;\n                if (data === undefined) {\n                    success();\n                } else {\n                    if (options.track) {\n                        result.push(data);\n                    }\n                    if (dest) {\n                        const destNow = Date.now(), destDelay = idx ? destNow - destTime : undefined;\n                        let destResult;\n                        destTime = destNow;\n                        try {\n                            destResult = dest.call(self, idx, data, destDelay);\n                        } catch (e) {\n                            fail({\n                                error: e,\n                                dest: data\n                            }, 3, dest.name);\n                            return;\n                        }\n                        if (utils.isPromise(destResult)) {\n                            destResult.then(()=>{\n                                next(true);\n                                return null; // this dummy return is just to prevent Bluebird warnings;\n                            }).catch((error)=>{\n                                fail({\n                                    error: error,\n                                    dest: data\n                                }, 2, dest.name);\n                            });\n                        } else {\n                            next(delayed);\n                        }\n                    } else {\n                        next(delayed);\n                    }\n                }\n            }, (reason, isRej)=>{\n                fail({\n                    error: reason,\n                    source: data\n                }, isRej ? 0 : 1, source.name);\n            });\n            function next(delayed) {\n                if (limit === ++idx) {\n                    success();\n                } else {\n                    if (delayed) {\n                        loop(idx);\n                    } else {\n                        $p.resolve().then(()=>{\n                            loop(idx);\n                            return null; // this dummy return is just to prevent Bluebird warnings;\n                        });\n                    }\n                }\n            }\n            function success() {\n                const length = Date.now() - start;\n                if (options.track) {\n                    utils.extend(result, \"duration\", length);\n                } else {\n                    result = {\n                        total: idx,\n                        duration: length\n                    };\n                }\n                resolve(result);\n            }\n            function fail(reason, code, cbName) {\n                reason.index = idx;\n                reject(new SequenceError(reason, code, cbName, Date.now() - start));\n            }\n        }\n        loop(0);\n    });\n}\nmodule.exports = function(config) {\n    return function(source, options) {\n        return sequence.call(this, source, options, config);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXh0L3NlcXVlbmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUNBLGFBQWEsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRFQyxHQUNELFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNO0lBRXJDLE1BQU1DLEtBQUtELE9BQU9FLE9BQU8sRUFBRUMsUUFBUUgsT0FBT0csS0FBSztJQUUvQyxJQUFJLE9BQU9MLFdBQVcsWUFBWTtRQUM5QixPQUFPRyxHQUFHRyxNQUFNLENBQUMsSUFBSUMsVUFBVTtJQUNuQztJQUVBUCxTQUFTSyxNQUFNRyxJQUFJLENBQUNSO0lBRXBCQyxVQUFVQSxXQUFXLENBQUM7SUFFdEIsTUFBTVEsUUFBUSxRQUFTQSxLQUFLLEdBQUcsSUFBS0MsU0FBU1QsUUFBUVEsS0FBSyxJQUFJLEdBQzFERSxPQUFPTixNQUFNRyxJQUFJLENBQUNQLFFBQVFVLElBQUksR0FDOUJDLE9BQU8sSUFBSSxFQUFFQyxRQUFRQyxLQUFLQyxHQUFHO0lBQ2pDLElBQUlDLE1BQU1DLFNBQVNDLFVBQVVDLFNBQVMsRUFBRTtJQUV4QyxPQUFPaEIsR0FBRyxDQUFDaUIsU0FBU2Q7UUFFaEIsU0FBU2UsS0FBS0MsR0FBRztZQUNiLE1BQU1DLFNBQVNULEtBQUtDLEdBQUcsSUFDbkJTLFdBQVdGLE1BQU9DLFNBQVNOLFVBQVdRO1lBQzFDUixVQUFVTTtZQUNWbEIsTUFBTWUsT0FBTyxDQUFDTSxJQUFJLENBQUNkLE1BQU1aLFFBQVE7Z0JBQUNzQjtnQkFBS047Z0JBQU1RO2FBQVMsRUFBRSxDQUFDRyxPQUFPQztnQkFDNURaLE9BQU9XO2dCQUNQLElBQUlYLFNBQVNTLFdBQVc7b0JBQ3BCSTtnQkFDSixPQUFPO29CQUNILElBQUk1QixRQUFRNkIsS0FBSyxFQUFFO3dCQUNmWCxPQUFPWSxJQUFJLENBQUNmO29CQUNoQjtvQkFDQSxJQUFJTCxNQUFNO3dCQUNOLE1BQU1xQixVQUFVbEIsS0FBS0MsR0FBRyxJQUNwQmtCLFlBQVlYLE1BQU9VLFVBQVVkLFdBQVlPO3dCQUM3QyxJQUFJUzt3QkFDSmhCLFdBQVdjO3dCQUNYLElBQUk7NEJBQ0FFLGFBQWF2QixLQUFLZSxJQUFJLENBQUNkLE1BQU1VLEtBQUtOLE1BQU1pQjt3QkFDNUMsRUFBRSxPQUFPRSxHQUFHOzRCQUNSQyxLQUFLO2dDQUNEQyxPQUFPRjtnQ0FDUHhCLE1BQU1LOzRCQUNWLEdBQUcsR0FBR0wsS0FBSzJCLElBQUk7NEJBQ2Y7d0JBQ0o7d0JBQ0EsSUFBSWpDLE1BQU1rQyxTQUFTLENBQUNMLGFBQWE7NEJBQzdCQSxXQUNLTSxJQUFJLENBQUM7Z0NBQ0ZDLEtBQUs7Z0NBQ0wsT0FBTyxNQUFNLDBEQUEwRDs0QkFDM0UsR0FDQ0MsS0FBSyxDQUFDTCxDQUFBQTtnQ0FDSEQsS0FBSztvQ0FDREMsT0FBT0E7b0NBQ1AxQixNQUFNSztnQ0FDVixHQUFHLEdBQUdMLEtBQUsyQixJQUFJOzRCQUNuQjt3QkFDUixPQUFPOzRCQUNIRyxLQUFLYjt3QkFDVDtvQkFDSixPQUFPO3dCQUNIYSxLQUFLYjtvQkFDVDtnQkFDSjtZQUNKLEdBQUcsQ0FBQ2UsUUFBUUM7Z0JBQ1JSLEtBQUs7b0JBQ0RDLE9BQU9NO29CQUNQM0MsUUFBUWdCO2dCQUNaLEdBQUc0QixRQUFRLElBQUksR0FBRzVDLE9BQU9zQyxJQUFJO1lBQ2pDO1lBRUEsU0FBU0csS0FBS2IsT0FBTztnQkFDakIsSUFBSW5CLFVBQVUsRUFBRWEsS0FBSztvQkFDakJPO2dCQUNKLE9BQU87b0JBQ0gsSUFBSUQsU0FBUzt3QkFDVFAsS0FBS0M7b0JBQ1QsT0FBTzt3QkFDSG5CLEdBQUdpQixPQUFPLEdBQ0xvQixJQUFJLENBQUM7NEJBQ0ZuQixLQUFLQzs0QkFDTCxPQUFPLE1BQU0sMERBQTBEO3dCQUMzRTtvQkFDUjtnQkFDSjtZQUNKO1lBRUEsU0FBU087Z0JBQ0wsTUFBTWdCLFNBQVMvQixLQUFLQyxHQUFHLEtBQUtGO2dCQUM1QixJQUFJWixRQUFRNkIsS0FBSyxFQUFFO29CQUNmekIsTUFBTXlDLE1BQU0sQ0FBQzNCLFFBQVEsWUFBWTBCO2dCQUNyQyxPQUFPO29CQUNIMUIsU0FBUzt3QkFDTDRCLE9BQU96Qjt3QkFDUDBCLFVBQVVIO29CQUNkO2dCQUNKO2dCQUNBekIsUUFBUUQ7WUFDWjtZQUVBLFNBQVNpQixLQUFLTyxNQUFNLEVBQUVNLElBQUksRUFBRUMsTUFBTTtnQkFDOUJQLE9BQU9RLEtBQUssR0FBRzdCO2dCQUNmaEIsT0FBTyxJQUFJVCxjQUFjOEMsUUFBUU0sTUFBTUMsUUFBUXBDLEtBQUtDLEdBQUcsS0FBS0Y7WUFDaEU7UUFDSjtRQUVBUSxLQUFLO0lBQ1Q7QUFDSjtBQUVBK0IsT0FBT0MsT0FBTyxHQUFHLFNBQVVuRCxNQUFNO0lBQzdCLE9BQU8sU0FBVUYsTUFBTSxFQUFFQyxPQUFPO1FBQzVCLE9BQU9GLFNBQVMyQixJQUFJLENBQUMsSUFBSSxFQUFFMUIsUUFBUUMsU0FBU0M7SUFDaEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3NwZXgvbGliL2V4dC9zZXF1ZW5jZS5qcz81YzlmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtTZXF1ZW5jZUVycm9yfSA9IHJlcXVpcmUoJy4uL2Vycm9ycy9zZXF1ZW5jZScpO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2VxdWVuY2VcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJlc29sdmVzIGEgZHluYW1pYyBzZXF1ZW5jZSBvZiBbbWl4ZWQgdmFsdWVzXXtAdHV0b3JpYWwgbWl4ZWR9LlxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIGFjcXVpcmVzIFttaXhlZCB2YWx1ZXNde0B0dXRvcmlhbCBtaXhlZH0gZnJvbSB0aGUgYHNvdXJjZWAgZnVuY3Rpb24sIG9uZSBhdCBhIHRpbWUsIGFuZCByZXNvbHZlcyB0aGVtLFxyXG4gKiB0aWxsIGVpdGhlciBubyBtb3JlIHZhbHVlcyBsZWZ0IGluIHRoZSBzZXF1ZW5jZSBvciBhbiBlcnJvci9yZWplY3Qgb2NjdXJzLlxyXG4gKlxyXG4gKiBJdCBzdXBwb3J0cyBib3RoIFtsaW5rZWQgYW5kIGRldGFjaGVkIHNlcXVlbmNpbmdde0B0dXRvcmlhbCBzZXF1ZW5jaW5nfS5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbnxnZW5lcmF0b3J9IHNvdXJjZVxyXG4gKiBFeHBlY3RlZCB0byByZXR1cm4gdGhlIG5leHQgW21peGVkIHZhbHVlXXtAdHV0b3JpYWwgbWl4ZWR9IHRvIGJlIHJlc29sdmVkLiBSZXR1cm5pbmcgb3IgcmVzb2x2aW5nXHJcbiAqIHdpdGggYHVuZGVmaW5lZGAgZW5kcyB0aGUgc2VxdWVuY2UsIGFuZCB0aGUgbWV0aG9kIHJlc29sdmVzLlxyXG4gKlxyXG4gKiBQYXJhbWV0ZXJzOlxyXG4gKiAgLSBgaW5kZXhgID0gY3VycmVudCByZXF1ZXN0IGluZGV4IGluIHRoZSBzZXF1ZW5jZVxyXG4gKiAgLSBgZGF0YWAgPSByZXNvbHZlZCBkYXRhIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgKGB1bmRlZmluZWRgIHdoZW4gYGluZGV4PTBgKVxyXG4gKiAgLSBgZGVsYXlgID0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBjYWxsIChgdW5kZWZpbmVkYCB3aGVuIGBpbmRleD0wYClcclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGluaGVyaXRzIGB0aGlzYCBjb250ZXh0IGZyb20gdGhlIGNhbGxpbmcgbWV0aG9kLlxyXG4gKlxyXG4gKiBJZiB0aGUgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yIG9yIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLCB0aGUgc2VxdWVuY2UgdGVybWluYXRlcyxcclxuICogYW5kIHRoZSBtZXRob2QgcmVqZWN0cyB3aXRoIHtAbGluayBlcnJvcnMuU2VxdWVuY2VFcnJvciBTZXF1ZW5jZUVycm9yfSwgd2hpY2ggd2lsbCBoYXZlIHByb3BlcnR5IGBzb3VyY2VgIHNldC5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb24gd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgUGFyYW1ldGVyICdzb3VyY2UnIG11c3QgYmUgYSBmdW5jdGlvbi5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogT3B0aW9uYWwgUGFyYW1ldGVycy5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbnxnZW5lcmF0b3J9IFtvcHRpb25zLmRlc3Q9bnVsbF1cclxuICogT3B0aW9uYWwgZGVzdGluYXRpb24gZnVuY3Rpb24gKG9yIGdlbmVyYXRvciksIHRvIHJlY2VpdmUgcmVzb2x2ZWQgZGF0YSBmb3IgZWFjaCBpbmRleCxcclxuICogcHJvY2VzcyBpdCBhbmQgcmVzcG9uZCBhcyByZXF1aXJlZC5cclxuICpcclxuICogUGFyYW1ldGVyczpcclxuICogIC0gYGluZGV4YCA9IGluZGV4IG9mIHRoZSByZXNvbHZlZCBkYXRhIGluIHRoZSBzZXF1ZW5jZVxyXG4gKiAgLSBgZGF0YWAgPSB0aGUgZGF0YSByZXNvbHZlZFxyXG4gKiAgLSBgZGVsYXlgID0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBjYWxsIChgdW5kZWZpbmVkYCB3aGVuIGBpbmRleD0wYClcclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGluaGVyaXRzIGB0aGlzYCBjb250ZXh0IGZyb20gdGhlIGNhbGxpbmcgbWV0aG9kLlxyXG4gKlxyXG4gKiBJdCBjYW4gb3B0aW9uYWxseSByZXR1cm4gYSBwcm9taXNlIG9iamVjdCwgaWYgZGF0YSBwcm9jZXNzaW5nIGlzIGRvbmUgYXN5bmNocm9ub3VzbHkuXHJcbiAqIElmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCwgdGhlIG1ldGhvZCB3aWxsIG5vdCByZXF1ZXN0IGFub3RoZXIgdmFsdWUgZnJvbSB0aGUgYHNvdXJjZWAgZnVuY3Rpb24sXHJcbiAqIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkICh0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgaWdub3JlZCkuXHJcbiAqXHJcbiAqIElmIHRoZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3Igb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UsIHRoZSBzZXF1ZW5jZSB0ZXJtaW5hdGVzLFxyXG4gKiBhbmQgdGhlIG1ldGhvZCByZWplY3RzIHdpdGgge0BsaW5rIGVycm9ycy5TZXF1ZW5jZUVycm9yIFNlcXVlbmNlRXJyb3J9LCB3aGljaCB3aWxsIGhhdmUgcHJvcGVydHkgYGRlc3RgIHNldC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0PTBdXHJcbiAqIExpbWl0cyB0aGUgbWF4aW11bSBzaXplIG9mIHRoZSBzZXF1ZW5jZS4gSWYgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAwLCB0aGUgbWV0aG9kIHdpbGxcclxuICogc3VjY2Vzc2Z1bGx5IHJlc29sdmUgb25jZSB0aGUgc3BlY2lmaWVkIGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAqXHJcbiAqIFdoZW4gYGxpbWl0YCBpc24ndCBzcGVjaWZpZWQgKGRlZmF1bHQpLCB0aGUgc2VxdWVuY2UgaXMgdW5saW1pdGVkLCBhbmQgaXQgd2lsbCBjb250aW51ZVxyXG4gKiB0aWxsIG9uZSBvZiB0aGUgZm9sbG93aW5nIG9jY3VyczpcclxuICogIC0gYHNvdXJjZWAgZWl0aGVyIHJldHVybnMgb3IgcmVzb2x2ZXMgd2l0aCBgdW5kZWZpbmVkYFxyXG4gKiAgLSBlaXRoZXIgYHNvdXJjZWAgb3IgYGRlc3RgIGZ1bmN0aW9ucyB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhY2s9ZmFsc2VdXHJcbiAqIENoYW5nZXMgdGhlIHR5cGUgb2YgZGF0YSB0byBiZSByZXNvbHZlZCBieSB0aGlzIG1ldGhvZC4gQnkgZGVmYXVsdCwgaXQgaXMgYGZhbHNlYFxyXG4gKiAoc2VlIHRoZSByZXR1cm4gcmVzdWx0KS4gV2hlbiBzZXQgdG8gYmUgYHRydWVgLCB0aGUgbWV0aG9kIHRyYWNrcy9jb2xsZWN0cyBhbGwgcmVzb2x2ZWQgZGF0YVxyXG4gKiBpbnRvIGFuIGFycmF5IGludGVybmFsbHksIGFuZCByZXNvbHZlcyB3aXRoIHRoYXQgYXJyYXkgb25jZSB0aGUgbWV0aG9kIGhhcyBmaW5pc2hlZCBzdWNjZXNzZnVsbHkuXHJcbiAqXHJcbiAqIEl0IG11c3QgYmUgdXNlZCB3aXRoIGNhdXRpb24sIGFzIHRvIHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSwgYmVjYXVzZSBhY2N1bXVsYXRpbmcgZGF0YSBmb3JcclxuICogYSB2ZXJ5IGxhcmdlIHNlcXVlbmNlIGNhbiByZXN1bHQgaW4gY29uc3VtaW5nIHRvbyBtdWNoIG1lbW9yeS5cclxuICpcclxuICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAqXHJcbiAqIFdoZW4gc3VjY2Vzc2Z1bCwgdGhlIHJlc29sdmVkIGRhdGEgZGVwZW5kcyBvbiBwYXJhbWV0ZXIgYHRyYWNrYC4gV2hlbiBgdHJhY2tgIGlzIGBmYWxzZWBcclxuICogKGRlZmF1bHQpLCB0aGUgbWV0aG9kIHJlc29sdmVzIHdpdGggb2JqZWN0IGB7dG90YWwsIGR1cmF0aW9ufWA6XHJcbiAqICAtIGB0b3RhbGAgPSBudW1iZXIgb2YgdmFsdWVzIHJlc29sdmVkIGJ5IHRoZSBzZXF1ZW5jZVxyXG4gKiAgLSBgZHVyYXRpb25gID0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBjb25zdW1lZCBieSB0aGUgbWV0aG9kXHJcbiAqXHJcbiAqIFdoZW4gYHRyYWNrYCBpcyBgdHJ1ZWAsIHRoZSBtZXRob2QgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBhbGwgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiByZXNvbHZlZCxcclxuICogdGhlIHNhbWUgd2F5IHRoYXQgdGhlIHN0YW5kYXJkICRbcHJvbWlzZS5hbGxdIHJlc29sdmVzLiBJbiBhZGRpdGlvbiwgdGhlIGFycmF5IGNvbWVzIGV4dGVuZGVkIHdpdGhcclxuICogYSBoaWRkZW4gcmVhZC1vbmx5IHByb3BlcnR5IGBkdXJhdGlvbmAgLSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGNvbnN1bWVkIGJ5IHRoZSBtZXRob2QuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIG1ldGhvZCBmYWlscywgaXQgcmVqZWN0cyB3aXRoIHtAbGluayBlcnJvcnMuU2VxdWVuY2VFcnJvciBTZXF1ZW5jZUVycm9yfS5cclxuICovXHJcbmZ1bmN0aW9uIHNlcXVlbmNlKHNvdXJjZSwgb3B0aW9ucywgY29uZmlnKSB7XHJcblxyXG4gICAgY29uc3QgJHAgPSBjb25maWcucHJvbWlzZSwgdXRpbHMgPSBjb25maWcudXRpbHM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gJHAucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdzb3VyY2VcXCcgbXVzdCBiZSBhIGZ1bmN0aW9uLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBzb3VyY2UgPSB1dGlscy53cmFwKHNvdXJjZSk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgY29uc3QgbGltaXQgPSAob3B0aW9ucy5saW1pdCA+IDApID8gcGFyc2VJbnQob3B0aW9ucy5saW1pdCkgOiAwLFxyXG4gICAgICAgIGRlc3QgPSB1dGlscy53cmFwKG9wdGlvbnMuZGVzdCksXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBkYXRhLCBzcmNUaW1lLCBkZXN0VGltZSwgcmVzdWx0ID0gW107XHJcblxyXG4gICAgcmV0dXJuICRwKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9vcChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3JjTm93ID0gRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgIHNyY0RlbGF5ID0gaWR4ID8gKHNyY05vdyAtIHNyY1RpbWUpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBzcmNUaW1lID0gc3JjTm93O1xyXG4gICAgICAgICAgICB1dGlscy5yZXNvbHZlLmNhbGwoc2VsZiwgc291cmNlLCBbaWR4LCBkYXRhLCBzcmNEZWxheV0sICh2YWx1ZSwgZGVsYXllZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3ROb3cgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdERlbGF5ID0gaWR4ID8gKGRlc3ROb3cgLSBkZXN0VGltZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0VGltZSA9IGRlc3ROb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0UmVzdWx0ID0gZGVzdC5jYWxsKHNlbGYsIGlkeCwgZGF0YSwgZGVzdERlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMywgZGVzdC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNQcm9taXNlKGRlc3RSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0UmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBkdW1teSByZXR1cm4gaXMganVzdCB0byBwcmV2ZW50IEJsdWViaXJkIHdhcm5pbmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIsIGRlc3QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KGRlbGF5ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChkZWxheWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIChyZWFzb24sIGlzUmVqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmYWlsKHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVhc29uLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZGF0YVxyXG4gICAgICAgICAgICAgICAgfSwgaXNSZWogPyAwIDogMSwgc291cmNlLm5hbWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZGVsYXllZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID09PSArK2lkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGF5ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcChpZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRwLnJlc29sdmUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoaWR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBkdW1teSByZXR1cm4gaXMganVzdCB0byBwcmV2ZW50IEJsdWViaXJkIHdhcm5pbmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWNjZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB1dGlscy5leHRlbmQocmVzdWx0LCAnZHVyYXRpb24nLCBsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiBpZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHJlYXNvbiwgY29kZSwgY2JOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZWFzb24uaW5kZXggPSBpZHg7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFNlcXVlbmNlRXJyb3IocmVhc29uLCBjb2RlLCBjYk5hbWUsIERhdGUubm93KCkgLSBzdGFydCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb29wKDApO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gc2VxdWVuY2UuY2FsbCh0aGlzLCBzb3VyY2UsIG9wdGlvbnMsIGNvbmZpZyk7XHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiU2VxdWVuY2VFcnJvciIsInJlcXVpcmUiLCJzZXF1ZW5jZSIsInNvdXJjZSIsIm9wdGlvbnMiLCJjb25maWciLCIkcCIsInByb21pc2UiLCJ1dGlscyIsInJlamVjdCIsIlR5cGVFcnJvciIsIndyYXAiLCJsaW1pdCIsInBhcnNlSW50IiwiZGVzdCIsInNlbGYiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJkYXRhIiwic3JjVGltZSIsImRlc3RUaW1lIiwicmVzdWx0IiwicmVzb2x2ZSIsImxvb3AiLCJpZHgiLCJzcmNOb3ciLCJzcmNEZWxheSIsInVuZGVmaW5lZCIsImNhbGwiLCJ2YWx1ZSIsImRlbGF5ZWQiLCJzdWNjZXNzIiwidHJhY2siLCJwdXNoIiwiZGVzdE5vdyIsImRlc3REZWxheSIsImRlc3RSZXN1bHQiLCJlIiwiZmFpbCIsImVycm9yIiwibmFtZSIsImlzUHJvbWlzZSIsInRoZW4iLCJuZXh0IiwiY2F0Y2giLCJyZWFzb24iLCJpc1JlaiIsImxlbmd0aCIsImV4dGVuZCIsInRvdGFsIiwiZHVyYXRpb24iLCJjb2RlIiwiY2JOYW1lIiwiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/ext/sequence.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/ext/stream/index.js":
/*!***************************************************!*\
  !*** ./node_modules/spex/lib/ext/stream/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    read: __webpack_require__(/*! ./read */ \"(rsc)/./node_modules/spex/lib/ext/stream/read.js\")\n};\n/**\r\n * @namespace stream\r\n * @description\r\n * Namespace with methods that implement stream operations, and {@link stream.read read} is the only method currently supported.\r\n *\r\n * **Synchronous Stream Processing**\r\n *\r\n * ```js\r\n * const stream = require('spex')(Promise).stream;\r\n * const fs = require('fs');\r\n *\r\n * const rs = fs.createReadStream('values.txt');\r\n *\r\n * function receiver(index, data, delay) {\r\n *    console.log('RECEIVED:', index, data, delay);\r\n * }\r\n *\r\n * stream.read(rs, receiver)\r\n *     .then(data => {\r\n *         console.log('DATA:', data);\r\n *     })\r\n *     .catch(error => {\r\n *         console.log('ERROR:', error);\r\n *     });\r\n * ```\r\n *\r\n * **Asynchronous Stream Processing**\r\n *\r\n * ```js\r\n * const stream = require('spex')(Promise).stream;\r\n * const fs = require('fs');\r\n *\r\n * const rs = fs.createReadStream('values.txt');\r\n *\r\n * function receiver(index, data, delay) {\r\n *    return new Promise(resolve => {\r\n *        console.log('RECEIVED:', index, data, delay);\r\n *        resolve();\r\n *    });\r\n * }\r\n *\r\n * stream.read(rs, receiver)\r\n *     .then(data => {\r\n *         console.log('DATA:', data);\r\n *     })\r\n *     .catch(error => {\r\n *         console.log('ERROR:', error);\r\n *    });\r\n * ```\r\n *\r\n * @property {function} stream.read\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n */ module.exports = function(config) {\n    const res = {\n        read: npm.read(config)\n    };\n    Object.freeze(res);\n    return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXh0L3N0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsTUFBTTtJQUNSQyxNQUFNQyxtQkFBT0EsQ0FBQztBQUNsQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFEQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsU0FBVUMsTUFBTTtJQUM3QixNQUFNQyxNQUFNO1FBQ1JMLE1BQU1ELElBQUlDLElBQUksQ0FBQ0k7SUFDbkI7SUFDQUUsT0FBT0MsTUFBTSxDQUFDRjtJQUNkLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi9leHQvc3RyZWFtL2luZGV4LmpzP2M5MGIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbnBtID0ge1xyXG4gICAgcmVhZDogcmVxdWlyZSgnLi9yZWFkJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIHN0cmVhbVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogTmFtZXNwYWNlIHdpdGggbWV0aG9kcyB0aGF0IGltcGxlbWVudCBzdHJlYW0gb3BlcmF0aW9ucywgYW5kIHtAbGluayBzdHJlYW0ucmVhZCByZWFkfSBpcyB0aGUgb25seSBtZXRob2QgY3VycmVudGx5IHN1cHBvcnRlZC5cclxuICpcclxuICogKipTeW5jaHJvbm91cyBTdHJlYW0gUHJvY2Vzc2luZyoqXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3NwZXgnKShQcm9taXNlKS5zdHJlYW07XHJcbiAqIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuICpcclxuICogY29uc3QgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKCd2YWx1ZXMudHh0Jyk7XHJcbiAqXHJcbiAqIGZ1bmN0aW9uIHJlY2VpdmVyKGluZGV4LCBkYXRhLCBkZWxheSkge1xyXG4gKiAgICBjb25zb2xlLmxvZygnUkVDRUlWRUQ6JywgaW5kZXgsIGRhdGEsIGRlbGF5KTtcclxuICogfVxyXG4gKlxyXG4gKiBzdHJlYW0ucmVhZChycywgcmVjZWl2ZXIpXHJcbiAqICAgICAudGhlbihkYXRhID0+IHtcclxuICogICAgICAgICBjb25zb2xlLmxvZygnREFUQTonLCBkYXRhKTtcclxuICogICAgIH0pXHJcbiAqICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUjonLCBlcnJvcik7XHJcbiAqICAgICB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqICoqQXN5bmNocm9ub3VzIFN0cmVhbSBQcm9jZXNzaW5nKipcclxuICpcclxuICogYGBganNcclxuICogY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3BleCcpKFByb21pc2UpLnN0cmVhbTtcclxuICogY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG4gKlxyXG4gKiBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ3ZhbHVlcy50eHQnKTtcclxuICpcclxuICogZnVuY3Rpb24gcmVjZWl2ZXIoaW5kZXgsIGRhdGEsIGRlbGF5KSB7XHJcbiAqICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICogICAgICAgIGNvbnNvbGUubG9nKCdSRUNFSVZFRDonLCBpbmRleCwgZGF0YSwgZGVsYXkpO1xyXG4gKiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gKiAgICB9KTtcclxuICogfVxyXG4gKlxyXG4gKiBzdHJlYW0ucmVhZChycywgcmVjZWl2ZXIpXHJcbiAqICAgICAudGhlbihkYXRhID0+IHtcclxuICogICAgICAgICBjb25zb2xlLmxvZygnREFUQTonLCBkYXRhKTtcclxuICogICAgIH0pXHJcbiAqICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUjonLCBlcnJvcik7XHJcbiAqICAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc3RyZWFtLnJlYWRcclxuICogQ29uc3VtZXMgYW5kIHByb2Nlc3NlcyBkYXRhIGZyb20gYSAkW1JlYWRhYmxlXSBzdHJlYW0uXHJcbiAqXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICByZWFkOiBucG0ucmVhZChjb25maWcpXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmZyZWV6ZShyZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuIl0sIm5hbWVzIjpbIm5wbSIsInJlYWQiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbmZpZyIsInJlcyIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/ext/stream/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/ext/stream/read.js":
/*!**************************************************!*\
  !*** ./node_modules/spex/lib/ext/stream/read.js ***!
  \**************************************************/
/***/ ((module) => {

eval("/**\r\n * @method stream.read\r\n * @description\r\n * Consumes and processes data from a $[Readable] stream.\r\n *\r\n * It reads the entire stream, using either **paused mode** (default), or in chunks (see `options.readChunks`)\r\n * with support for both synchronous and asynchronous data processing.\r\n *\r\n * **NOTE:** Once the method has finished, the onus is on the caller to release the stream\r\n * according to its protocol.\r\n *\r\n * @param {Object} stream\r\n * $[Readable] stream object.\r\n *\r\n * Passing in anything else will throw `Readable stream is required.`\r\n *\r\n * @param {Function|generator} receiver\r\n * Data processing callback (or generator).\r\n *\r\n * Passing in anything else will throw `Invalid stream receiver.`\r\n *\r\n * Parameters:\r\n *  - `index` = index of the call made to the function\r\n *  - `data` = array of all data reads from the stream's buffer\r\n *  - `delay` = number of milliseconds since the last call (`undefined` when `index=0`)\r\n *\r\n * The function is called with the same `this` context as the calling method.\r\n *\r\n * It can optionally return a promise object, if data processing is asynchronous.\r\n * And if a promise is returned, the method will not read data from the stream again,\r\n * until the promise has been resolved.\r\n *\r\n * If the function throws an error or returns a rejected promise, the method rejects\r\n * with the same error / rejection reason.\r\n *\r\n * @param {Object} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {Boolean} [options.closable=false]\r\n * Instructs the method to resolve on event `close` supported by the stream, as opposed to event\r\n * `end` that's used by default.\r\n *\r\n * @param {Boolean} [options.readChunks=false]\r\n * By default, the method handles event `readable` of the stream to consume data in a simplified form,\r\n * item by item. If you enable this option, the method will instead handle event `data` of the stream,\r\n * to consume chunks of data.\r\n *\r\n * @param {Number} [options.readSize]\r\n * When the value is greater than 0, it sets the read size from the stream's buffer\r\n * when the next data is available. By default, the method uses as few reads as possible\r\n * to get all the data currently available in the buffer.\r\n *\r\n * NOTE: This option is ignored when option `readChunks` is enabled.\r\n *\r\n * @returns {external:Promise}\r\n *\r\n * When finished successfully, resolves with object `{calls, reads, length, duration}`:\r\n *  - `calls` = number of calls made into the `receiver`\r\n *  - `reads` = number of successful reads from the stream\r\n *  - `length` = total length for all the data reads from the stream\r\n *  - `duration` = number of milliseconds consumed by the method\r\n *\r\n * When it fails, the method rejects with the error/reject specified,\r\n * which can happen as a result of:\r\n *  - event `error` emitted by the stream\r\n *  - receiver throws an error or returns a rejected promise\r\n */ \nfunction read(stream, receiver, options, config) {\n    const $p = config.promise, utils = config.utils;\n    if (!utils.isReadableStream(stream)) {\n        return $p.reject(new TypeError(\"Readable stream is required.\"));\n    }\n    if (typeof receiver !== \"function\") {\n        return $p.reject(new TypeError(\"Invalid stream receiver.\"));\n    }\n    receiver = utils.wrap(receiver);\n    options = options || {};\n    const readSize = options.readSize > 0 ? parseInt(options.readSize) : null, self = this, start = Date.now(), receiveEvent = options.readChunks ? \"data\" : \"readable\";\n    let cbTime, ready, waiting, stop, reads = 0, length = 0, index = 0;\n    return $p((resolve, reject)=>{\n        function onReceive(data) {\n            ready = true;\n            process(data);\n        }\n        function onEnd() {\n            if (!options.closable) {\n                success();\n            }\n        }\n        function onClose() {\n            success();\n        }\n        function onError(error) {\n            fail(error);\n        }\n        stream.on(receiveEvent, onReceive);\n        stream.on(\"end\", onEnd);\n        stream.on(\"close\", onClose);\n        stream.on(\"error\", onError);\n        function process(data) {\n            if (!ready || stop || waiting) {\n                return;\n            }\n            ready = false;\n            let cache;\n            if (options.readChunks) {\n                cache = data;\n                // istanbul ignore else;\n                // we cannot test the else condition, as it requires a special broken stream interface.\n                if (!Array.isArray(cache)) {\n                    cache = [\n                        cache\n                    ];\n                }\n                length += cache.length;\n                reads++;\n            } else {\n                cache = [];\n                waiting = true;\n                let page;\n                do {\n                    page = stream.read(readSize);\n                    if (page) {\n                        cache.push(page);\n                        // istanbul ignore next: requires a unique stream that\n                        // creates objects without property `length` defined.\n                        length += page.length || 0;\n                        reads++;\n                    }\n                }while (page);\n                if (!cache.length) {\n                    waiting = false;\n                    return;\n                }\n            }\n            const cbNow = Date.now(), cbDelay = index ? cbNow - cbTime : undefined;\n            let result;\n            cbTime = cbNow;\n            try {\n                result = receiver.call(self, index++, cache, cbDelay);\n            } catch (e) {\n                fail(e);\n                return;\n            }\n            if (utils.isPromise(result)) {\n                result.then(()=>{\n                    waiting = false;\n                    process();\n                    return null; // this dummy return is just to prevent Bluebird warnings;\n                }).catch((error)=>{\n                    fail(error);\n                });\n            } else {\n                waiting = false;\n                process();\n            }\n        }\n        function success() {\n            cleanup();\n            resolve({\n                calls: index,\n                reads: reads,\n                length: length,\n                duration: Date.now() - start\n            });\n        }\n        function fail(error) {\n            stop = true;\n            cleanup();\n            reject(error);\n        }\n        function cleanup() {\n            stream.removeListener(receiveEvent, onReceive);\n            stream.removeListener(\"close\", onClose);\n            stream.removeListener(\"error\", onError);\n            stream.removeListener(\"end\", onEnd);\n        }\n    });\n}\nmodule.exports = function(config) {\n    return function(stream, receiver, options) {\n        return read.call(this, stream, receiver, options, config);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvZXh0L3N0cmVhbS9yZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUM7QUFDRCxTQUFTQSxLQUFLQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxNQUFNO0lBRTNDLE1BQU1DLEtBQUtELE9BQU9FLE9BQU8sRUFBRUMsUUFBUUgsT0FBT0csS0FBSztJQUUvQyxJQUFJLENBQUNBLE1BQU1DLGdCQUFnQixDQUFDUCxTQUFTO1FBQ2pDLE9BQU9JLEdBQUdJLE1BQU0sQ0FBQyxJQUFJQyxVQUFVO0lBQ25DO0lBRUEsSUFBSSxPQUFPUixhQUFhLFlBQVk7UUFDaEMsT0FBT0csR0FBR0ksTUFBTSxDQUFDLElBQUlDLFVBQVU7SUFDbkM7SUFFQVIsV0FBV0ssTUFBTUksSUFBSSxDQUFDVDtJQUV0QkMsVUFBVUEsV0FBVyxDQUFDO0lBRXRCLE1BQU1TLFdBQVcsUUFBU0EsUUFBUSxHQUFHLElBQUtDLFNBQVNWLFFBQVFTLFFBQVEsSUFBSSxNQUNuRUUsT0FBTyxJQUFJLEVBQUVDLFFBQVFDLEtBQUtDLEdBQUcsSUFBSUMsZUFBZWYsUUFBUWdCLFVBQVUsR0FBRyxTQUFTO0lBQ2xGLElBQUlDLFFBQVFDLE9BQU9DLFNBQVNDLE1BQU1DLFFBQVEsR0FBR0MsU0FBUyxHQUFHQyxRQUFRO0lBRWpFLE9BQU9yQixHQUFHLENBQUNzQixTQUFTbEI7UUFFaEIsU0FBU21CLFVBQVVDLElBQUk7WUFDbkJSLFFBQVE7WUFDUlMsUUFBUUQ7UUFDWjtRQUVBLFNBQVNFO1lBQ0wsSUFBSSxDQUFDNUIsUUFBUTZCLFFBQVEsRUFBRTtnQkFDbkJDO1lBQ0o7UUFDSjtRQUVBLFNBQVNDO1lBQ0xEO1FBQ0o7UUFFQSxTQUFTRSxRQUFRQyxLQUFLO1lBQ2xCQyxLQUFLRDtRQUNUO1FBRUFuQyxPQUFPcUMsRUFBRSxDQUFDcEIsY0FBY1U7UUFDeEIzQixPQUFPcUMsRUFBRSxDQUFDLE9BQU9QO1FBQ2pCOUIsT0FBT3FDLEVBQUUsQ0FBQyxTQUFTSjtRQUNuQmpDLE9BQU9xQyxFQUFFLENBQUMsU0FBU0g7UUFFbkIsU0FBU0wsUUFBUUQsSUFBSTtZQUNqQixJQUFJLENBQUNSLFNBQVNFLFFBQVFELFNBQVM7Z0JBQzNCO1lBQ0o7WUFDQUQsUUFBUTtZQUNSLElBQUlrQjtZQUNKLElBQUlwQyxRQUFRZ0IsVUFBVSxFQUFFO2dCQUNwQm9CLFFBQVFWO2dCQUNSLHdCQUF3QjtnQkFDeEIsdUZBQXVGO2dCQUN2RixJQUFJLENBQUNXLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtvQkFDdkJBLFFBQVE7d0JBQUNBO3FCQUFNO2dCQUNuQjtnQkFDQWQsVUFBVWMsTUFBTWQsTUFBTTtnQkFDdEJEO1lBQ0osT0FBTztnQkFDSGUsUUFBUSxFQUFFO2dCQUNWakIsVUFBVTtnQkFDVixJQUFJb0I7Z0JBQ0osR0FBRztvQkFDQ0EsT0FBT3pDLE9BQU9ELElBQUksQ0FBQ1k7b0JBQ25CLElBQUk4QixNQUFNO3dCQUNOSCxNQUFNSSxJQUFJLENBQUNEO3dCQUNYLHNEQUFzRDt3QkFDdEQscURBQXFEO3dCQUNyRGpCLFVBQVVpQixLQUFLakIsTUFBTSxJQUFJO3dCQUN6QkQ7b0JBQ0o7Z0JBQ0osUUFBU2tCLE1BQU07Z0JBRWYsSUFBSSxDQUFDSCxNQUFNZCxNQUFNLEVBQUU7b0JBQ2ZILFVBQVU7b0JBQ1Y7Z0JBQ0o7WUFDSjtZQUVBLE1BQU1zQixRQUFRNUIsS0FBS0MsR0FBRyxJQUNsQjRCLFVBQVVuQixRQUFTa0IsUUFBUXhCLFNBQVUwQjtZQUN6QyxJQUFJQztZQUNKM0IsU0FBU3dCO1lBQ1QsSUFBSTtnQkFDQUcsU0FBUzdDLFNBQVM4QyxJQUFJLENBQUNsQyxNQUFNWSxTQUFTYSxPQUFPTTtZQUNqRCxFQUFFLE9BQU9JLEdBQUc7Z0JBQ1JaLEtBQUtZO2dCQUNMO1lBQ0o7WUFFQSxJQUFJMUMsTUFBTTJDLFNBQVMsQ0FBQ0gsU0FBUztnQkFDekJBLE9BQ0tJLElBQUksQ0FBQztvQkFDRjdCLFVBQVU7b0JBQ1ZRO29CQUNBLE9BQU8sTUFBTSwwREFBMEQ7Z0JBQzNFLEdBQ0NzQixLQUFLLENBQUNoQixDQUFBQTtvQkFDSEMsS0FBS0Q7Z0JBQ1Q7WUFDUixPQUFPO2dCQUNIZCxVQUFVO2dCQUNWUTtZQUNKO1FBQ0o7UUFFQSxTQUFTRztZQUNMb0I7WUFDQTFCLFFBQVE7Z0JBQ0oyQixPQUFPNUI7Z0JBQ1BGLE9BQU9BO2dCQUNQQyxRQUFRQTtnQkFDUjhCLFVBQVV2QyxLQUFLQyxHQUFHLEtBQUtGO1lBQzNCO1FBQ0o7UUFFQSxTQUFTc0IsS0FBS0QsS0FBSztZQUNmYixPQUFPO1lBQ1A4QjtZQUNBNUMsT0FBTzJCO1FBQ1g7UUFFQSxTQUFTaUI7WUFDTHBELE9BQU91RCxjQUFjLENBQUN0QyxjQUFjVTtZQUNwQzNCLE9BQU91RCxjQUFjLENBQUMsU0FBU3RCO1lBQy9CakMsT0FBT3VELGNBQWMsQ0FBQyxTQUFTckI7WUFDL0JsQyxPQUFPdUQsY0FBYyxDQUFDLE9BQU96QjtRQUNqQztJQUNKO0FBQ0o7QUFFQTBCLE9BQU9DLE9BQU8sR0FBRyxTQUFVdEQsTUFBTTtJQUM3QixPQUFPLFNBQVVILE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxPQUFPO1FBQ3RDLE9BQU9ILEtBQUtnRCxJQUFJLENBQUMsSUFBSSxFQUFFL0MsUUFBUUMsVUFBVUMsU0FBU0M7SUFDdEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3NwZXgvbGliL2V4dC9zdHJlYW0vcmVhZC5qcz8xMDE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbWV0aG9kIHN0cmVhbS5yZWFkXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb25zdW1lcyBhbmQgcHJvY2Vzc2VzIGRhdGEgZnJvbSBhICRbUmVhZGFibGVdIHN0cmVhbS5cclxuICpcclxuICogSXQgcmVhZHMgdGhlIGVudGlyZSBzdHJlYW0sIHVzaW5nIGVpdGhlciAqKnBhdXNlZCBtb2RlKiogKGRlZmF1bHQpLCBvciBpbiBjaHVua3MgKHNlZSBgb3B0aW9ucy5yZWFkQ2h1bmtzYClcclxuICogd2l0aCBzdXBwb3J0IGZvciBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgZGF0YSBwcm9jZXNzaW5nLlxyXG4gKlxyXG4gKiAqKk5PVEU6KiogT25jZSB0aGUgbWV0aG9kIGhhcyBmaW5pc2hlZCwgdGhlIG9udXMgaXMgb24gdGhlIGNhbGxlciB0byByZWxlYXNlIHRoZSBzdHJlYW1cclxuICogYWNjb3JkaW5nIHRvIGl0cyBwcm90b2NvbC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbVxyXG4gKiAkW1JlYWRhYmxlXSBzdHJlYW0gb2JqZWN0LlxyXG4gKlxyXG4gKiBQYXNzaW5nIGluIGFueXRoaW5nIGVsc2Ugd2lsbCB0aHJvdyBgUmVhZGFibGUgc3RyZWFtIGlzIHJlcXVpcmVkLmBcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbnxnZW5lcmF0b3J9IHJlY2VpdmVyXHJcbiAqIERhdGEgcHJvY2Vzc2luZyBjYWxsYmFjayAob3IgZ2VuZXJhdG9yKS5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBlbHNlIHdpbGwgdGhyb3cgYEludmFsaWQgc3RyZWFtIHJlY2VpdmVyLmBcclxuICpcclxuICogUGFyYW1ldGVyczpcclxuICogIC0gYGluZGV4YCA9IGluZGV4IG9mIHRoZSBjYWxsIG1hZGUgdG8gdGhlIGZ1bmN0aW9uXHJcbiAqICAtIGBkYXRhYCA9IGFycmF5IG9mIGFsbCBkYXRhIHJlYWRzIGZyb20gdGhlIHN0cmVhbSdzIGJ1ZmZlclxyXG4gKiAgLSBgZGVsYXlgID0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBjYWxsIChgdW5kZWZpbmVkYCB3aGVuIGBpbmRleD0wYClcclxuICpcclxuICogVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGB0aGlzYCBjb250ZXh0IGFzIHRoZSBjYWxsaW5nIG1ldGhvZC5cclxuICpcclxuICogSXQgY2FuIG9wdGlvbmFsbHkgcmV0dXJuIGEgcHJvbWlzZSBvYmplY3QsIGlmIGRhdGEgcHJvY2Vzc2luZyBpcyBhc3luY2hyb25vdXMuXHJcbiAqIEFuZCBpZiBhIHByb21pc2UgaXMgcmV0dXJuZWQsIHRoZSBtZXRob2Qgd2lsbCBub3QgcmVhZCBkYXRhIGZyb20gdGhlIHN0cmVhbSBhZ2FpbixcclxuICogdW50aWwgdGhlIHByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQuXHJcbiAqXHJcbiAqIElmIHRoZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3Igb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UsIHRoZSBtZXRob2QgcmVqZWN0c1xyXG4gKiB3aXRoIHRoZSBzYW1lIGVycm9yIC8gcmVqZWN0aW9uIHJlYXNvbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBPcHRpb25hbCBQYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb3NhYmxlPWZhbHNlXVxyXG4gKiBJbnN0cnVjdHMgdGhlIG1ldGhvZCB0byByZXNvbHZlIG9uIGV2ZW50IGBjbG9zZWAgc3VwcG9ydGVkIGJ5IHRoZSBzdHJlYW0sIGFzIG9wcG9zZWQgdG8gZXZlbnRcclxuICogYGVuZGAgdGhhdCdzIHVzZWQgYnkgZGVmYXVsdC5cclxuICpcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkQ2h1bmtzPWZhbHNlXVxyXG4gKiBCeSBkZWZhdWx0LCB0aGUgbWV0aG9kIGhhbmRsZXMgZXZlbnQgYHJlYWRhYmxlYCBvZiB0aGUgc3RyZWFtIHRvIGNvbnN1bWUgZGF0YSBpbiBhIHNpbXBsaWZpZWQgZm9ybSxcclxuICogaXRlbSBieSBpdGVtLiBJZiB5b3UgZW5hYmxlIHRoaXMgb3B0aW9uLCB0aGUgbWV0aG9kIHdpbGwgaW5zdGVhZCBoYW5kbGUgZXZlbnQgYGRhdGFgIG9mIHRoZSBzdHJlYW0sXHJcbiAqIHRvIGNvbnN1bWUgY2h1bmtzIG9mIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWFkU2l6ZV1cclxuICogV2hlbiB0aGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDAsIGl0IHNldHMgdGhlIHJlYWQgc2l6ZSBmcm9tIHRoZSBzdHJlYW0ncyBidWZmZXJcclxuICogd2hlbiB0aGUgbmV4dCBkYXRhIGlzIGF2YWlsYWJsZS4gQnkgZGVmYXVsdCwgdGhlIG1ldGhvZCB1c2VzIGFzIGZldyByZWFkcyBhcyBwb3NzaWJsZVxyXG4gKiB0byBnZXQgYWxsIHRoZSBkYXRhIGN1cnJlbnRseSBhdmFpbGFibGUgaW4gdGhlIGJ1ZmZlci5cclxuICpcclxuICogTk9URTogVGhpcyBvcHRpb24gaXMgaWdub3JlZCB3aGVuIG9wdGlvbiBgcmVhZENodW5rc2AgaXMgZW5hYmxlZC5cclxuICpcclxuICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAqXHJcbiAqIFdoZW4gZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LCByZXNvbHZlcyB3aXRoIG9iamVjdCBge2NhbGxzLCByZWFkcywgbGVuZ3RoLCBkdXJhdGlvbn1gOlxyXG4gKiAgLSBgY2FsbHNgID0gbnVtYmVyIG9mIGNhbGxzIG1hZGUgaW50byB0aGUgYHJlY2VpdmVyYFxyXG4gKiAgLSBgcmVhZHNgID0gbnVtYmVyIG9mIHN1Y2Nlc3NmdWwgcmVhZHMgZnJvbSB0aGUgc3RyZWFtXHJcbiAqICAtIGBsZW5ndGhgID0gdG90YWwgbGVuZ3RoIGZvciBhbGwgdGhlIGRhdGEgcmVhZHMgZnJvbSB0aGUgc3RyZWFtXHJcbiAqICAtIGBkdXJhdGlvbmAgPSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGNvbnN1bWVkIGJ5IHRoZSBtZXRob2RcclxuICpcclxuICogV2hlbiBpdCBmYWlscywgdGhlIG1ldGhvZCByZWplY3RzIHdpdGggdGhlIGVycm9yL3JlamVjdCBzcGVjaWZpZWQsXHJcbiAqIHdoaWNoIGNhbiBoYXBwZW4gYXMgYSByZXN1bHQgb2Y6XHJcbiAqICAtIGV2ZW50IGBlcnJvcmAgZW1pdHRlZCBieSB0aGUgc3RyZWFtXHJcbiAqICAtIHJlY2VpdmVyIHRocm93cyBhbiBlcnJvciBvciByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZChzdHJlYW0sIHJlY2VpdmVyLCBvcHRpb25zLCBjb25maWcpIHtcclxuXHJcbiAgICBjb25zdCAkcCA9IGNvbmZpZy5wcm9taXNlLCB1dGlscyA9IGNvbmZpZy51dGlscztcclxuXHJcbiAgICBpZiAoIXV0aWxzLmlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSkge1xyXG4gICAgICAgIHJldHVybiAkcC5yZWplY3QobmV3IFR5cGVFcnJvcignUmVhZGFibGUgc3RyZWFtIGlzIHJlcXVpcmVkLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHJlY2VpdmVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuICRwLnJlamVjdChuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmVhbSByZWNlaXZlci4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjZWl2ZXIgPSB1dGlscy53cmFwKHJlY2VpdmVyKTtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBjb25zdCByZWFkU2l6ZSA9IChvcHRpb25zLnJlYWRTaXplID4gMCkgPyBwYXJzZUludChvcHRpb25zLnJlYWRTaXplKSA6IG51bGwsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsIHN0YXJ0ID0gRGF0ZS5ub3coKSwgcmVjZWl2ZUV2ZW50ID0gb3B0aW9ucy5yZWFkQ2h1bmtzID8gJ2RhdGEnIDogJ3JlYWRhYmxlJztcclxuICAgIGxldCBjYlRpbWUsIHJlYWR5LCB3YWl0aW5nLCBzdG9wLCByZWFkcyA9IDAsIGxlbmd0aCA9IDAsIGluZGV4ID0gMDtcclxuXHJcbiAgICByZXR1cm4gJHAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBvblJlY2VpdmUoZGF0YSkge1xyXG4gICAgICAgICAgICByZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb2Nlc3MoZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkVuZCgpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNsb3NhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICAgICAgZmFpbChlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHJlYW0ub24ocmVjZWl2ZUV2ZW50LCBvblJlY2VpdmUpO1xyXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgb25FbmQpO1xyXG4gICAgICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbkNsb3NlKTtcclxuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXJlYWR5IHx8IHN0b3AgfHwgd2FpdGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjYWNoZTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVhZENodW5rcykge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgdGVzdCB0aGUgZWxzZSBjb25kaXRpb24sIGFzIGl0IHJlcXVpcmVzIGEgc3BlY2lhbCBicm9rZW4gc3RyZWFtIGludGVyZmFjZS5cclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IFtjYWNoZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gY2FjaGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVhZHMrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlID0gW107XHJcbiAgICAgICAgICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBwYWdlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBzdHJlYW0ucmVhZChyZWFkU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucHVzaChwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IHJlcXVpcmVzIGEgdW5pcXVlIHN0cmVhbSB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgb2JqZWN0cyB3aXRob3V0IHByb3BlcnR5IGBsZW5ndGhgIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBwYWdlLmxlbmd0aCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHBhZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgY2JOb3cgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgY2JEZWxheSA9IGluZGV4ID8gKGNiTm93IC0gY2JUaW1lKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgY2JUaW1lID0gY2JOb3c7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jYWxsKHNlbGYsIGluZGV4KyssIGNhY2hlLCBjYkRlbGF5KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgZmFpbChlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzUHJvbWlzZShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBkdW1teSByZXR1cm4gaXMganVzdCB0byBwcmV2ZW50IEJsdWViaXJkIHdhcm5pbmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICBjYWxsczogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICByZWFkczogcmVhZHMsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmYWlsKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xyXG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIocmVjZWl2ZUV2ZW50LCBvblJlY2VpdmUpO1xyXG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XHJcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHJlY2VpdmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWQuY2FsbCh0aGlzLCBzdHJlYW0sIHJlY2VpdmVyLCBvcHRpb25zLCBjb25maWcpO1xyXG4gICAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbInJlYWQiLCJzdHJlYW0iLCJyZWNlaXZlciIsIm9wdGlvbnMiLCJjb25maWciLCIkcCIsInByb21pc2UiLCJ1dGlscyIsImlzUmVhZGFibGVTdHJlYW0iLCJyZWplY3QiLCJUeXBlRXJyb3IiLCJ3cmFwIiwicmVhZFNpemUiLCJwYXJzZUludCIsInNlbGYiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJyZWNlaXZlRXZlbnQiLCJyZWFkQ2h1bmtzIiwiY2JUaW1lIiwicmVhZHkiLCJ3YWl0aW5nIiwic3RvcCIsInJlYWRzIiwibGVuZ3RoIiwiaW5kZXgiLCJyZXNvbHZlIiwib25SZWNlaXZlIiwiZGF0YSIsInByb2Nlc3MiLCJvbkVuZCIsImNsb3NhYmxlIiwic3VjY2VzcyIsIm9uQ2xvc2UiLCJvbkVycm9yIiwiZXJyb3IiLCJmYWlsIiwib24iLCJjYWNoZSIsIkFycmF5IiwiaXNBcnJheSIsInBhZ2UiLCJwdXNoIiwiY2JOb3ciLCJjYkRlbGF5IiwidW5kZWZpbmVkIiwicmVzdWx0IiwiY2FsbCIsImUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJjbGVhbnVwIiwiY2FsbHMiLCJkdXJhdGlvbiIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/ext/stream/read.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/spex/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/spex/lib/utils/index.js\"),\n    batch: __webpack_require__(/*! ./ext/batch */ \"(rsc)/./node_modules/spex/lib/ext/batch.js\"),\n    page: __webpack_require__(/*! ./ext/page */ \"(rsc)/./node_modules/spex/lib/ext/page.js\"),\n    sequence: __webpack_require__(/*! ./ext/sequence */ \"(rsc)/./node_modules/spex/lib/ext/sequence.js\"),\n    stream: __webpack_require__(/*! ./ext/stream */ \"(rsc)/./node_modules/spex/lib/ext/stream/index.js\"),\n    errors: __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/spex/lib/errors/index.js\")\n};\n/**\r\n * @module spex\r\n * @summary Specialized Promise Extensions\r\n * @author Vitaly Tomilov\r\n *\r\n * @description\r\n * Attaches to an external promise library and provides additional methods built solely\r\n * on the basic promise operations:\r\n *  - construct a new promise with a callback function\r\n *  - resolve a promise with some result data\r\n *  - reject a promise with a reason\r\n *\r\n * ### usage\r\n * For any third-party promise library:\r\n * ```js\r\n * const promise = require('bluebird');\r\n * const spex = require('spex')(promise);\r\n * ```\r\n * For ES6 promises:\r\n * ```js\r\n * const spex = require('spex')(Promise);\r\n * ```\r\n *\r\n * @param {Object|Function} promiseLib\r\n * Instance of a promise library to be used by this module.\r\n *\r\n * Some implementations use `Promise` constructor to create a new promise, while\r\n * others use the module's function for it. Both types are supported the same.\r\n *\r\n * Alternatively, an object of type {@link PromiseAdapter} can be passed in, which provides\r\n * compatibility with any promise library outside of the standard.\r\n *\r\n * Passing in a promise library that cannot be recognized will throw\r\n * `Invalid promise library specified.`\r\n *\r\n * @returns {Object}\r\n * Namespace with all supported methods.\r\n *\r\n * @see {@link PromiseAdapter}, {@link batch}, {@link page}, {@link sequence}, {@link stream}\r\n */ function main(promiseLib) {\n    const spex = {}, promise = parsePromiseLib(promiseLib); // promise library parsing;\n    const config = {\n        spex: spex,\n        promise: promise,\n        utils: npm.utils(promise)\n    };\n    spex.errors = npm.errors;\n    spex.batch = npm.batch(config);\n    spex.page = npm.page(config);\n    spex.sequence = npm.sequence(config);\n    spex.stream = npm.stream(config);\n    config.utils.extend(spex, \"$p\", promise);\n    Object.freeze(spex);\n    return spex;\n}\n//////////////////////////////////////////\n// Parses and validates a promise library;\nfunction parsePromiseLib(lib) {\n    if (lib) {\n        let promise;\n        if (lib instanceof main.PromiseAdapter) {\n            promise = function(func) {\n                return lib.create(func);\n            };\n            promise.resolve = lib.resolve;\n            promise.reject = lib.reject;\n            return promise;\n        }\n        const t = typeof lib;\n        if (t === \"function\" || t === \"object\") {\n            const Root = typeof lib.Promise === \"function\" ? lib.Promise : lib;\n            promise = function(func) {\n                return new Root(func);\n            };\n            promise.resolve = Root.resolve;\n            promise.reject = Root.reject;\n            if (typeof promise.resolve === \"function\" && typeof promise.reject === \"function\") {\n                return promise;\n            }\n        }\n    }\n    throw new TypeError(\"Invalid promise library specified.\");\n}\nmain.PromiseAdapter = __webpack_require__(/*! ./adapter */ \"(rsc)/./node_modules/spex/lib/adapter.js\");\nmain.errors = npm.errors;\nObject.freeze(main);\nmodule.exports = main; /**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */  /**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */  /**\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU07SUFDUkMsT0FBT0MsbUJBQU9BLENBQUM7SUFDZkMsT0FBT0QsbUJBQU9BLENBQUM7SUFDZkUsTUFBTUYsbUJBQU9BLENBQUM7SUFDZEcsVUFBVUgsbUJBQU9BLENBQUM7SUFDbEJJLFFBQVFKLG1CQUFPQSxDQUFDO0lBQ2hCSyxRQUFRTCxtQkFBT0EsQ0FBQztBQUNwQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1Q0MsR0FDRCxTQUFTTSxLQUFLQyxVQUFVO0lBRXBCLE1BQU1DLE9BQU8sQ0FBQyxHQUNWQyxVQUFVQyxnQkFBZ0JILGFBQWEsMkJBQTJCO0lBRXRFLE1BQU1JLFNBQVM7UUFDWEgsTUFBTUE7UUFDTkMsU0FBU0E7UUFDVFYsT0FBT0QsSUFBSUMsS0FBSyxDQUFDVTtJQUNyQjtJQUVBRCxLQUFLSCxNQUFNLEdBQUdQLElBQUlPLE1BQU07SUFDeEJHLEtBQUtQLEtBQUssR0FBR0gsSUFBSUcsS0FBSyxDQUFDVTtJQUN2QkgsS0FBS04sSUFBSSxHQUFHSixJQUFJSSxJQUFJLENBQUNTO0lBQ3JCSCxLQUFLTCxRQUFRLEdBQUdMLElBQUlLLFFBQVEsQ0FBQ1E7SUFDN0JILEtBQUtKLE1BQU0sR0FBR04sSUFBSU0sTUFBTSxDQUFDTztJQUV6QkEsT0FBT1osS0FBSyxDQUFDYSxNQUFNLENBQUNKLE1BQU0sTUFBTUM7SUFFaENJLE9BQU9DLE1BQU0sQ0FBQ047SUFFZCxPQUFPQTtBQUNYO0FBRUEsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyxTQUFTRSxnQkFBZ0JLLEdBQUc7SUFDeEIsSUFBSUEsS0FBSztRQUNMLElBQUlOO1FBQ0osSUFBSU0sZUFBZVQsS0FBS1UsY0FBYyxFQUFFO1lBQ3BDUCxVQUFVLFNBQVVRLElBQUk7Z0JBQ3BCLE9BQU9GLElBQUlHLE1BQU0sQ0FBQ0Q7WUFDdEI7WUFDQVIsUUFBUVUsT0FBTyxHQUFHSixJQUFJSSxPQUFPO1lBQzdCVixRQUFRVyxNQUFNLEdBQUdMLElBQUlLLE1BQU07WUFDM0IsT0FBT1g7UUFDWDtRQUNBLE1BQU1ZLElBQUksT0FBT047UUFDakIsSUFBSU0sTUFBTSxjQUFjQSxNQUFNLFVBQVU7WUFDcEMsTUFBTUMsT0FBTyxPQUFPUCxJQUFJUSxPQUFPLEtBQUssYUFBYVIsSUFBSVEsT0FBTyxHQUFHUjtZQUMvRE4sVUFBVSxTQUFVUSxJQUFJO2dCQUNwQixPQUFPLElBQUlLLEtBQUtMO1lBQ3BCO1lBQ0FSLFFBQVFVLE9BQU8sR0FBR0csS0FBS0gsT0FBTztZQUM5QlYsUUFBUVcsTUFBTSxHQUFHRSxLQUFLRixNQUFNO1lBQzVCLElBQUksT0FBT1gsUUFBUVUsT0FBTyxLQUFLLGNBQWMsT0FBT1YsUUFBUVcsTUFBTSxLQUFLLFlBQVk7Z0JBQy9FLE9BQU9YO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTSxJQUFJZSxVQUFVO0FBQ3hCO0FBRUFsQixLQUFLVSxjQUFjLEdBQUdoQixtQkFBT0EsQ0FBQztBQUM5Qk0sS0FBS0QsTUFBTSxHQUFHUCxJQUFJTyxNQUFNO0FBRXhCUSxPQUFPQyxNQUFNLENBQUNSO0FBRWRtQixPQUFPQyxPQUFPLEdBQUdwQixNQUVqQjs7O0NBR0MsSUFFRDs7O0NBR0MsSUFFRDs7O0NBR0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi9pbmRleC5qcz9iM2FhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG5wbSA9IHtcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJyksXHJcbiAgICBiYXRjaDogcmVxdWlyZSgnLi9leHQvYmF0Y2gnKSxcclxuICAgIHBhZ2U6IHJlcXVpcmUoJy4vZXh0L3BhZ2UnKSxcclxuICAgIHNlcXVlbmNlOiByZXF1aXJlKCcuL2V4dC9zZXF1ZW5jZScpLFxyXG4gICAgc3RyZWFtOiByZXF1aXJlKCcuL2V4dC9zdHJlYW0nKSxcclxuICAgIGVycm9yczogcmVxdWlyZSgnLi9lcnJvcnMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgc3BleFxyXG4gKiBAc3VtbWFyeSBTcGVjaWFsaXplZCBQcm9taXNlIEV4dGVuc2lvbnNcclxuICogQGF1dGhvciBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQXR0YWNoZXMgdG8gYW4gZXh0ZXJuYWwgcHJvbWlzZSBsaWJyYXJ5IGFuZCBwcm92aWRlcyBhZGRpdGlvbmFsIG1ldGhvZHMgYnVpbHQgc29sZWx5XHJcbiAqIG9uIHRoZSBiYXNpYyBwcm9taXNlIG9wZXJhdGlvbnM6XHJcbiAqICAtIGNvbnN0cnVjdCBhIG5ldyBwcm9taXNlIHdpdGggYSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiAgLSByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIHNvbWUgcmVzdWx0IGRhdGFcclxuICogIC0gcmVqZWN0IGEgcHJvbWlzZSB3aXRoIGEgcmVhc29uXHJcbiAqXHJcbiAqICMjIyB1c2FnZVxyXG4gKiBGb3IgYW55IHRoaXJkLXBhcnR5IHByb21pc2UgbGlicmFyeTpcclxuICogYGBganNcclxuICogY29uc3QgcHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XHJcbiAqIGNvbnN0IHNwZXggPSByZXF1aXJlKCdzcGV4JykocHJvbWlzZSk7XHJcbiAqIGBgYFxyXG4gKiBGb3IgRVM2IHByb21pc2VzOlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBzcGV4ID0gcmVxdWlyZSgnc3BleCcpKFByb21pc2UpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHByb21pc2VMaWJcclxuICogSW5zdGFuY2Ugb2YgYSBwcm9taXNlIGxpYnJhcnkgdG8gYmUgdXNlZCBieSB0aGlzIG1vZHVsZS5cclxuICpcclxuICogU29tZSBpbXBsZW1lbnRhdGlvbnMgdXNlIGBQcm9taXNlYCBjb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBuZXcgcHJvbWlzZSwgd2hpbGVcclxuICogb3RoZXJzIHVzZSB0aGUgbW9kdWxlJ3MgZnVuY3Rpb24gZm9yIGl0LiBCb3RoIHR5cGVzIGFyZSBzdXBwb3J0ZWQgdGhlIHNhbWUuXHJcbiAqXHJcbiAqIEFsdGVybmF0aXZlbHksIGFuIG9iamVjdCBvZiB0eXBlIHtAbGluayBQcm9taXNlQWRhcHRlcn0gY2FuIGJlIHBhc3NlZCBpbiwgd2hpY2ggcHJvdmlkZXNcclxuICogY29tcGF0aWJpbGl0eSB3aXRoIGFueSBwcm9taXNlIGxpYnJhcnkgb3V0c2lkZSBvZiB0aGUgc3RhbmRhcmQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYSBwcm9taXNlIGxpYnJhcnkgdGhhdCBjYW5ub3QgYmUgcmVjb2duaXplZCB3aWxsIHRocm93XHJcbiAqIGBJbnZhbGlkIHByb21pc2UgbGlicmFyeSBzcGVjaWZpZWQuYFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKiBOYW1lc3BhY2Ugd2l0aCBhbGwgc3VwcG9ydGVkIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIFByb21pc2VBZGFwdGVyfSwge0BsaW5rIGJhdGNofSwge0BsaW5rIHBhZ2V9LCB7QGxpbmsgc2VxdWVuY2V9LCB7QGxpbmsgc3RyZWFtfVxyXG4gKi9cclxuZnVuY3Rpb24gbWFpbihwcm9taXNlTGliKSB7XHJcblxyXG4gICAgY29uc3Qgc3BleCA9IHt9LCAvLyBsaWJyYXJ5IGluc3RhbmNlO1xyXG4gICAgICAgIHByb21pc2UgPSBwYXJzZVByb21pc2VMaWIocHJvbWlzZUxpYik7IC8vIHByb21pc2UgbGlicmFyeSBwYXJzaW5nO1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICBzcGV4OiBzcGV4LFxyXG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXHJcbiAgICAgICAgdXRpbHM6IG5wbS51dGlscyhwcm9taXNlKVxyXG4gICAgfTtcclxuXHJcbiAgICBzcGV4LmVycm9ycyA9IG5wbS5lcnJvcnM7XHJcbiAgICBzcGV4LmJhdGNoID0gbnBtLmJhdGNoKGNvbmZpZyk7XHJcbiAgICBzcGV4LnBhZ2UgPSBucG0ucGFnZShjb25maWcpO1xyXG4gICAgc3BleC5zZXF1ZW5jZSA9IG5wbS5zZXF1ZW5jZShjb25maWcpO1xyXG4gICAgc3BleC5zdHJlYW0gPSBucG0uc3RyZWFtKGNvbmZpZyk7XHJcblxyXG4gICAgY29uZmlnLnV0aWxzLmV4dGVuZChzcGV4LCAnJHAnLCBwcm9taXNlKTtcclxuXHJcbiAgICBPYmplY3QuZnJlZXplKHNwZXgpO1xyXG5cclxuICAgIHJldHVybiBzcGV4O1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUGFyc2VzIGFuZCB2YWxpZGF0ZXMgYSBwcm9taXNlIGxpYnJhcnk7XHJcbmZ1bmN0aW9uIHBhcnNlUHJvbWlzZUxpYihsaWIpIHtcclxuICAgIGlmIChsaWIpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZTtcclxuICAgICAgICBpZiAobGliIGluc3RhbmNlb2YgbWFpbi5Qcm9taXNlQWRhcHRlcikge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaWIuY3JlYXRlKGZ1bmMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUgPSBsaWIucmVzb2x2ZTtcclxuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QgPSBsaWIucmVqZWN0O1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiBsaWI7XHJcbiAgICAgICAgaWYgKHQgPT09ICdmdW5jdGlvbicgfHwgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgUm9vdCA9IHR5cGVvZiBsaWIuUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyA/IGxpYi5Qcm9taXNlIDogbGliO1xyXG4gICAgICAgICAgICBwcm9taXNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUm9vdChmdW5jKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlID0gUm9vdC5yZXNvbHZlO1xyXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdCA9IFJvb3QucmVqZWN0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb21pc2UucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcHJvbWlzZS5yZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcm9taXNlIGxpYnJhcnkgc3BlY2lmaWVkLicpO1xyXG59XHJcblxyXG5tYWluLlByb21pc2VBZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVyJyk7XHJcbm1haW4uZXJyb3JzID0gbnBtLmVycm9ycztcclxuXHJcbk9iamVjdC5mcmVlemUobWFpbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG1haW47XHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIEVycm9yXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3JcclxuICovXHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIFR5cGVFcnJvclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgUHJvbWlzZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2VcclxuICovXHJcbiJdLCJuYW1lcyI6WyJucG0iLCJ1dGlscyIsInJlcXVpcmUiLCJiYXRjaCIsInBhZ2UiLCJzZXF1ZW5jZSIsInN0cmVhbSIsImVycm9ycyIsIm1haW4iLCJwcm9taXNlTGliIiwic3BleCIsInByb21pc2UiLCJwYXJzZVByb21pc2VMaWIiLCJjb25maWciLCJleHRlbmQiLCJPYmplY3QiLCJmcmVlemUiLCJsaWIiLCJQcm9taXNlQWRhcHRlciIsImZ1bmMiLCJjcmVhdGUiLCJyZXNvbHZlIiwicmVqZWN0IiwidCIsIlJvb3QiLCJQcm9taXNlIiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/utils/index.js":
/*!**********************************************!*\
  !*** ./node_modules/spex/lib/utils/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    stat: __webpack_require__(/*! ./static */ \"(rsc)/./node_modules/spex/lib/utils/static.js\")\n};\nmodule.exports = function($p) {\n    const exp = {\n        formatError: npm.stat.formatError,\n        isPromise: npm.stat.isPromise,\n        isReadableStream: npm.stat.isReadableStream,\n        messageGap: npm.stat.messageGap,\n        extend: npm.stat.extend,\n        resolve: resolve,\n        wrap: wrap\n    };\n    return exp;\n    //////////////////////////////////////////\n    // Checks if the function is a generator,\n    // and if so - wraps it up into a promise;\n    function wrap(func) {\n        if (typeof func === \"function\") {\n            if (func.constructor.name === \"GeneratorFunction\") {\n                return asyncAdapter(func);\n            }\n            return func;\n        }\n        return null;\n    }\n    /////////////////////////////////////////////////////\n    // Resolves a mixed value into the actual value,\n    // consistent with the way mixed values are defined:\n    // https://github.com/vitaly-t/spex/wiki/Mixed-Values\n    function resolve(value, params, onSuccess, onError) {\n        const self = this;\n        let delayed = false;\n        function loop() {\n            while(typeof value === \"function\"){\n                if (value.constructor.name === \"GeneratorFunction\") {\n                    value = asyncAdapter(value);\n                }\n                try {\n                    value = params ? value.apply(self, params) : value.call(self);\n                } catch (e) {\n                    onError(e, false); // false means 'threw an error'\n                    return;\n                }\n            }\n            if (exp.isPromise(value)) {\n                value.then((data)=>{\n                    delayed = true;\n                    value = data;\n                    loop();\n                    return null; // this dummy return is just to prevent Bluebird warnings;\n                }).catch((error)=>{\n                    onError(error, true); // true means 'rejected'\n                });\n            } else {\n                onSuccess(value, delayed);\n            }\n        }\n        loop();\n    }\n    // Generator-to-Promise adapter;\n    // Based on: https://www.promisejs.org/generators/#both\n    function asyncAdapter(generator) {\n        return function() {\n            const g = generator.apply(this, arguments);\n            function handle(result) {\n                if (result.done) {\n                    return $p.resolve(result.value);\n                }\n                return $p.resolve(result.value).then((res)=>handle(g.next(res)), (err)=>handle(g.throw(err)));\n            }\n            return handle(g.next());\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU07SUFDUkMsTUFBTUMsbUJBQU9BLENBQUM7QUFDbEI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHLFNBQVVDLEVBQUU7SUFFekIsTUFBTUMsTUFBTTtRQUNSQyxhQUFhUCxJQUFJQyxJQUFJLENBQUNNLFdBQVc7UUFDakNDLFdBQVdSLElBQUlDLElBQUksQ0FBQ08sU0FBUztRQUM3QkMsa0JBQWtCVCxJQUFJQyxJQUFJLENBQUNRLGdCQUFnQjtRQUMzQ0MsWUFBWVYsSUFBSUMsSUFBSSxDQUFDUyxVQUFVO1FBQy9CQyxRQUFRWCxJQUFJQyxJQUFJLENBQUNVLE1BQU07UUFDdkJDLFNBQVNBO1FBQ1RDLE1BQU1BO0lBQ1Y7SUFFQSxPQUFPUDtJQUVQLDBDQUEwQztJQUMxQyx5Q0FBeUM7SUFDekMsMENBQTBDO0lBQzFDLFNBQVNPLEtBQUtDLElBQUk7UUFDZCxJQUFJLE9BQU9BLFNBQVMsWUFBWTtZQUM1QixJQUFJQSxLQUFLQyxXQUFXLENBQUNDLElBQUksS0FBSyxxQkFBcUI7Z0JBQy9DLE9BQU9DLGFBQWFIO1lBQ3hCO1lBQ0EsT0FBT0E7UUFDWDtRQUNBLE9BQU87SUFDWDtJQUVBLHFEQUFxRDtJQUNyRCxnREFBZ0Q7SUFDaEQsb0RBQW9EO0lBQ3BELHFEQUFxRDtJQUNyRCxTQUFTRixRQUFRTSxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxPQUFPO1FBRTlDLE1BQU1DLE9BQU8sSUFBSTtRQUNqQixJQUFJQyxVQUFVO1FBRWQsU0FBU0M7WUFDTCxNQUFPLE9BQU9OLFVBQVUsV0FBWTtnQkFDaEMsSUFBSUEsTUFBTUgsV0FBVyxDQUFDQyxJQUFJLEtBQUsscUJBQXFCO29CQUNoREUsUUFBUUQsYUFBYUM7Z0JBQ3pCO2dCQUNBLElBQUk7b0JBQ0FBLFFBQVFDLFNBQVNELE1BQU1PLEtBQUssQ0FBQ0gsTUFBTUgsVUFBVUQsTUFBTVEsSUFBSSxDQUFDSjtnQkFDNUQsRUFBRSxPQUFPSyxHQUFHO29CQUNSTixRQUFRTSxHQUFHLFFBQVEsK0JBQStCO29CQUNsRDtnQkFDSjtZQUNKO1lBQ0EsSUFBSXJCLElBQUlFLFNBQVMsQ0FBQ1UsUUFBUTtnQkFDdEJBLE1BQ0tVLElBQUksQ0FBQ0MsQ0FBQUE7b0JBQ0ZOLFVBQVU7b0JBQ1ZMLFFBQVFXO29CQUNSTDtvQkFDQSxPQUFPLE1BQU0sMERBQTBEO2dCQUMzRSxHQUNDTSxLQUFLLENBQUNDLENBQUFBO29CQUNIVixRQUFRVSxPQUFPLE9BQU8sd0JBQXdCO2dCQUNsRDtZQUNSLE9BQU87Z0JBQ0hYLFVBQVVGLE9BQU9LO1lBQ3JCO1FBQ0o7UUFFQUM7SUFDSjtJQUVBLGdDQUFnQztJQUNoQyx1REFBdUQ7SUFDdkQsU0FBU1AsYUFBYWUsU0FBUztRQUMzQixPQUFPO1lBQ0gsTUFBTUMsSUFBSUQsVUFBVVAsS0FBSyxDQUFDLElBQUksRUFBRVM7WUFFaEMsU0FBU0MsT0FBT0MsTUFBTTtnQkFDbEIsSUFBSUEsT0FBT0MsSUFBSSxFQUFFO29CQUNiLE9BQU9oQyxHQUFHTyxPQUFPLENBQUN3QixPQUFPbEIsS0FBSztnQkFDbEM7Z0JBQ0EsT0FBT2IsR0FBR08sT0FBTyxDQUFDd0IsT0FBT2xCLEtBQUssRUFDekJVLElBQUksQ0FBQ1UsQ0FBQUEsTUFBT0gsT0FBT0YsRUFBRU0sSUFBSSxDQUFDRCxPQUFPRSxDQUFBQSxNQUFPTCxPQUFPRixFQUFFUSxLQUFLLENBQUNEO1lBQ2hFO1lBRUEsT0FBT0wsT0FBT0YsRUFBRU0sSUFBSTtRQUN4QjtJQUNKO0FBRUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi91dGlscy9pbmRleC5qcz8zMjFhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG5wbSA9IHtcclxuICAgIHN0YXQ6IHJlcXVpcmUoJy4vc3RhdGljJylcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCRwKSB7XHJcblxyXG4gICAgY29uc3QgZXhwID0ge1xyXG4gICAgICAgIGZvcm1hdEVycm9yOiBucG0uc3RhdC5mb3JtYXRFcnJvcixcclxuICAgICAgICBpc1Byb21pc2U6IG5wbS5zdGF0LmlzUHJvbWlzZSxcclxuICAgICAgICBpc1JlYWRhYmxlU3RyZWFtOiBucG0uc3RhdC5pc1JlYWRhYmxlU3RyZWFtLFxyXG4gICAgICAgIG1lc3NhZ2VHYXA6IG5wbS5zdGF0Lm1lc3NhZ2VHYXAsXHJcbiAgICAgICAgZXh0ZW5kOiBucG0uc3RhdC5leHRlbmQsXHJcbiAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgICAgICB3cmFwOiB3cmFwXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBleHA7XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBDaGVja3MgaWYgdGhlIGZ1bmN0aW9uIGlzIGEgZ2VuZXJhdG9yLFxyXG4gICAgLy8gYW5kIGlmIHNvIC0gd3JhcHMgaXQgdXAgaW50byBhIHByb21pc2U7XHJcbiAgICBmdW5jdGlvbiB3cmFwKGZ1bmMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKGZ1bmMuY29uc3RydWN0b3IubmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jQWRhcHRlcihmdW5jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZnVuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIFJlc29sdmVzIGEgbWl4ZWQgdmFsdWUgaW50byB0aGUgYWN0dWFsIHZhbHVlLFxyXG4gICAgLy8gY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgbWl4ZWQgdmFsdWVzIGFyZSBkZWZpbmVkOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFseS10L3NwZXgvd2lraS9NaXhlZC1WYWx1ZXNcclxuICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUsIHBhcmFtcywgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxldCBkZWxheWVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvb3AoKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhc3luY0FkYXB0ZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtcyA/IHZhbHVlLmFwcGx5KHNlbGYsIHBhcmFtcykgOiB2YWx1ZS5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZSwgZmFsc2UpOyAvLyBmYWxzZSBtZWFucyAndGhyZXcgYW4gZXJyb3InXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHAuaXNQcm9taXNlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBkdW1teSByZXR1cm4gaXMganVzdCB0byBwcmV2ZW50IEJsdWViaXJkIHdhcm5pbmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvciwgdHJ1ZSk7IC8vIHRydWUgbWVhbnMgJ3JlamVjdGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzKHZhbHVlLCBkZWxheWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9vcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRvci10by1Qcm9taXNlIGFkYXB0ZXI7XHJcbiAgICAvLyBCYXNlZCBvbjogaHR0cHM6Ly93d3cucHJvbWlzZWpzLm9yZy9nZW5lcmF0b3JzLyNib3RoXHJcbiAgICBmdW5jdGlvbiBhc3luY0FkYXB0ZXIoZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRwLnJlc29sdmUocmVzdWx0LnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZXNvbHZlKHJlc3VsdC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4gaGFuZGxlKGcubmV4dChyZXMpKSwgZXJyID0+IGhhbmRsZShnLnRocm93KGVycikpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShnLm5leHQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJucG0iLCJzdGF0IiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCIkcCIsImV4cCIsImZvcm1hdEVycm9yIiwiaXNQcm9taXNlIiwiaXNSZWFkYWJsZVN0cmVhbSIsIm1lc3NhZ2VHYXAiLCJleHRlbmQiLCJyZXNvbHZlIiwid3JhcCIsImZ1bmMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhc3luY0FkYXB0ZXIiLCJ2YWx1ZSIsInBhcmFtcyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJzZWxmIiwiZGVsYXllZCIsImxvb3AiLCJhcHBseSIsImNhbGwiLCJlIiwidGhlbiIsImRhdGEiLCJjYXRjaCIsImVycm9yIiwiZ2VuZXJhdG9yIiwiZyIsImFyZ3VtZW50cyIsImhhbmRsZSIsInJlc3VsdCIsImRvbmUiLCJyZXMiLCJuZXh0IiwiZXJyIiwidGhyb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/spex/lib/utils/static.js":
/*!***********************************************!*\
  !*** ./node_modules/spex/lib/utils/static.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst npm = {\n    stream: __webpack_require__(/*! stream */ \"stream\"),\n    util: __webpack_require__(/*! util */ \"util\")\n};\n/////////////////////////////////////\n// Checks if the value is a promise;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\n////////////////////////////////////////////\n// Checks object for being a readable stream;\nfunction isReadableStream(obj) {\n    return obj instanceof npm.stream.Stream && typeof obj._read === \"function\" && typeof obj._readableState === \"object\";\n}\n////////////////////////////////////////////////////////////\n// Sets an object property as read-only and non-enumerable.\nfunction extend(obj, name, value) {\n    Object.defineProperty(obj, name, {\n        value: value,\n        configurable: false,\n        enumerable: false,\n        writable: false\n    });\n}\n///////////////////////////////////////////\n// Returns a space gap for console output;\nfunction messageGap(level) {\n    return \" \".repeat(level * 4);\n}\nfunction formatError(error, level) {\n    const names = [\n        \"BatchError\",\n        \"PageError\",\n        \"SequenceError\"\n    ];\n    let msg = npm.util.inspect(error);\n    if (error instanceof Error) {\n        if (names.indexOf(error.name) === -1) {\n            const gap = messageGap(level);\n            msg = msg.split(\"\\n\").map((line, index)=>{\n                return (index ? gap : \"\") + line;\n            }).join(\"\\n\");\n        } else {\n            msg = error.toString(level);\n        }\n    }\n    return msg;\n}\n////////////////////////////////////////////////////////\n// Adds prototype inspection, with support of the newer\n// Custom Inspection, which was added in Node.js 6.x\nfunction addInspection(type, cb) {\n    // istanbul ignore next;\n    if (npm.util.inspect.custom) {\n        // Custom inspection is supported:\n        type.prototype[npm.util.inspect.custom] = cb;\n    } else {\n        // Use classic inspection:\n        type.prototype.inspect = cb;\n    }\n}\nmodule.exports = {\n    addInspection: addInspection,\n    formatError: formatError,\n    isPromise: isPromise,\n    isReadableStream: isReadableStream,\n    messageGap: messageGap,\n    extend: extend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3BleC9saWIvdXRpbHMvc3RhdGljLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxNQUFNO0lBQ1JDLFFBQVFDLG1CQUFPQSxDQUFDO0lBQ2hCQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNsQjtBQUVBLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEMsU0FBU0UsVUFBVUMsS0FBSztJQUNwQixPQUFPQSxTQUFTLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUMxQztBQUVBLDRDQUE0QztBQUM1Qyw2Q0FBNkM7QUFDN0MsU0FBU0MsaUJBQWlCQyxHQUFHO0lBQ3pCLE9BQU9BLGVBQWVSLElBQUlDLE1BQU0sQ0FBQ1EsTUFBTSxJQUNuQyxPQUFPRCxJQUFJRSxLQUFLLEtBQUssY0FDckIsT0FBT0YsSUFBSUcsY0FBYyxLQUFLO0FBQ3RDO0FBRUEsNERBQTREO0FBQzVELDJEQUEyRDtBQUMzRCxTQUFTQyxPQUFPSixHQUFHLEVBQUVLLElBQUksRUFBRVIsS0FBSztJQUM1QlMsT0FBT0MsY0FBYyxDQUFDUCxLQUFLSyxNQUFNO1FBQzdCUixPQUFPQTtRQUNQVyxjQUFjO1FBQ2RDLFlBQVk7UUFDWkMsVUFBVTtJQUNkO0FBQ0o7QUFFQSwyQ0FBMkM7QUFDM0MsMENBQTBDO0FBQzFDLFNBQVNDLFdBQVdDLEtBQUs7SUFDckIsT0FBTyxJQUFJQyxNQUFNLENBQUNELFFBQVE7QUFDOUI7QUFFQSxTQUFTRSxZQUFZQyxLQUFLLEVBQUVILEtBQUs7SUFDN0IsTUFBTUksUUFBUTtRQUFDO1FBQWM7UUFBYTtLQUFnQjtJQUMxRCxJQUFJQyxNQUFNekIsSUFBSUcsSUFBSSxDQUFDdUIsT0FBTyxDQUFDSDtJQUMzQixJQUFJQSxpQkFBaUJJLE9BQU87UUFDeEIsSUFBSUgsTUFBTUksT0FBTyxDQUFDTCxNQUFNVixJQUFJLE1BQU0sQ0FBQyxHQUFHO1lBQ2xDLE1BQU1nQixNQUFNVixXQUFXQztZQUN2QkssTUFBTUEsSUFBSUssS0FBSyxDQUFDLE1BQU1DLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztnQkFDN0IsT0FBTyxDQUFDQSxRQUFRSixNQUFNLEVBQUMsSUFBS0c7WUFDaEMsR0FBR0UsSUFBSSxDQUFDO1FBQ1osT0FBTztZQUNIVCxNQUFNRixNQUFNWSxRQUFRLENBQUNmO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPSztBQUNYO0FBRUEsd0RBQXdEO0FBQ3hELHVEQUF1RDtBQUN2RCxvREFBb0Q7QUFDcEQsU0FBU1csY0FBY0MsSUFBSSxFQUFFQyxFQUFFO0lBQzNCLHdCQUF3QjtJQUN4QixJQUFJdEMsSUFBSUcsSUFBSSxDQUFDdUIsT0FBTyxDQUFDYSxNQUFNLEVBQUU7UUFDekIsa0NBQWtDO1FBQ2xDRixLQUFLRyxTQUFTLENBQUN4QyxJQUFJRyxJQUFJLENBQUN1QixPQUFPLENBQUNhLE1BQU0sQ0FBQyxHQUFHRDtJQUM5QyxPQUFPO1FBQ0gsMEJBQTBCO1FBQzFCRCxLQUFLRyxTQUFTLENBQUNkLE9BQU8sR0FBR1k7SUFDN0I7QUFDSjtBQUVBRyxPQUFPQyxPQUFPLEdBQUc7SUFDYk4sZUFBZUE7SUFDZmQsYUFBYUE7SUFDYmxCLFdBQVdBO0lBQ1hHLGtCQUFrQkE7SUFDbEJZLFlBQVlBO0lBQ1pQLFFBQVFBO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9zcGV4L2xpYi91dGlscy9zdGF0aWMuanM/MmExNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBucG0gPSB7XHJcbiAgICBzdHJlYW06IHJlcXVpcmUoJ3N0cmVhbScpLFxyXG4gICAgdXRpbDogcmVxdWlyZSgndXRpbCcpXHJcbn07XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBwcm9taXNlO1xyXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQ2hlY2tzIG9iamVjdCBmb3IgYmVpbmcgYSByZWFkYWJsZSBzdHJlYW07XHJcbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgbnBtLnN0cmVhbS5TdHJlYW0gJiZcclxuICAgICAgICB0eXBlb2Ygb2JqLl9yZWFkID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgdHlwZW9mIG9iai5fcmVhZGFibGVTdGF0ZSA9PT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBTZXRzIGFuIG9iamVjdCBwcm9wZXJ0eSBhcyByZWFkLW9ubHkgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG5mdW5jdGlvbiBleHRlbmQob2JqLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUmV0dXJucyBhIHNwYWNlIGdhcCBmb3IgY29uc29sZSBvdXRwdXQ7XHJcbmZ1bmN0aW9uIG1lc3NhZ2VHYXAobGV2ZWwpIHtcclxuICAgIHJldHVybiAnICcucmVwZWF0KGxldmVsICogNCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yLCBsZXZlbCkge1xyXG4gICAgY29uc3QgbmFtZXMgPSBbJ0JhdGNoRXJyb3InLCAnUGFnZUVycm9yJywgJ1NlcXVlbmNlRXJyb3InXTtcclxuICAgIGxldCBtc2cgPSBucG0udXRpbC5pbnNwZWN0KGVycm9yKTtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YoZXJyb3IubmFtZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdhcCA9IG1lc3NhZ2VHYXAobGV2ZWwpO1xyXG4gICAgICAgICAgICBtc2cgPSBtc2cuc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPyBnYXAgOiAnJykgKyBsaW5lO1xyXG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtc2cgPSBlcnJvci50b1N0cmluZyhsZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1zZztcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQWRkcyBwcm90b3R5cGUgaW5zcGVjdGlvbiwgd2l0aCBzdXBwb3J0IG9mIHRoZSBuZXdlclxyXG4vLyBDdXN0b20gSW5zcGVjdGlvbiwgd2hpY2ggd2FzIGFkZGVkIGluIE5vZGUuanMgNi54XHJcbmZ1bmN0aW9uIGFkZEluc3BlY3Rpb24odHlwZSwgY2IpIHtcclxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0O1xyXG4gICAgaWYgKG5wbS51dGlsLmluc3BlY3QuY3VzdG9tKSB7XHJcbiAgICAgICAgLy8gQ3VzdG9tIGluc3BlY3Rpb24gaXMgc3VwcG9ydGVkOlxyXG4gICAgICAgIHR5cGUucHJvdG90eXBlW25wbS51dGlsLmluc3BlY3QuY3VzdG9tXSA9IGNiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBVc2UgY2xhc3NpYyBpbnNwZWN0aW9uOlxyXG4gICAgICAgIHR5cGUucHJvdG90eXBlLmluc3BlY3QgPSBjYjtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBhZGRJbnNwZWN0aW9uOiBhZGRJbnNwZWN0aW9uLFxyXG4gICAgZm9ybWF0RXJyb3I6IGZvcm1hdEVycm9yLFxyXG4gICAgaXNQcm9taXNlOiBpc1Byb21pc2UsXHJcbiAgICBpc1JlYWRhYmxlU3RyZWFtOiBpc1JlYWRhYmxlU3RyZWFtLFxyXG4gICAgbWVzc2FnZUdhcDogbWVzc2FnZUdhcCxcclxuICAgIGV4dGVuZDogZXh0ZW5kXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJucG0iLCJzdHJlYW0iLCJyZXF1aXJlIiwidXRpbCIsImlzUHJvbWlzZSIsInZhbHVlIiwidGhlbiIsImlzUmVhZGFibGVTdHJlYW0iLCJvYmoiLCJTdHJlYW0iLCJfcmVhZCIsIl9yZWFkYWJsZVN0YXRlIiwiZXh0ZW5kIiwibmFtZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwibWVzc2FnZUdhcCIsImxldmVsIiwicmVwZWF0IiwiZm9ybWF0RXJyb3IiLCJlcnJvciIsIm5hbWVzIiwibXNnIiwiaW5zcGVjdCIsIkVycm9yIiwiaW5kZXhPZiIsImdhcCIsInNwbGl0IiwibWFwIiwibGluZSIsImluZGV4Iiwiam9pbiIsInRvU3RyaW5nIiwiYWRkSW5zcGVjdGlvbiIsInR5cGUiLCJjYiIsImN1c3RvbSIsInByb3RvdHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/spex/lib/utils/static.js\n");

/***/ })

};
;