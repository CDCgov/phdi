"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-promise";
exports.ids = ["vendor-chunks/pg-promise"];
exports.modules = {

/***/ "(rsc)/./node_modules/pg-promise/lib/assert.js":
/*!***********************************************!*\
  !*** ./node_modules/pg-promise/lib/assert.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { assertOptions } = __webpack_require__(/*! assert-options */ \"(rsc)/./node_modules/assert-options/dist/src/index.js\");\n// this to allow override options-related errors globally (for pg-promise)\nglobal.pgPromiseAssert = assertOptions;\nmodule.exports = {\n    assert () {\n        return global.pgPromiseAssert.apply(null, [\n            ...arguments\n        ]);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUNBLGFBQWEsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUVoQywwRUFBMEU7QUFDMUVDLE9BQU9DLGVBQWUsR0FBR0g7QUFFekJJLE9BQU9DLE9BQU8sR0FBRztJQUNiQztRQUNJLE9BQU9KLE9BQU9DLGVBQWUsQ0FBQ0ksS0FBSyxDQUFDLE1BQU07ZUFBSUM7U0FBVTtJQUM1RDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvYXNzZXJ0LmpzP2EzZTQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2Fzc2VydE9wdGlvbnN9ID0gcmVxdWlyZSgnYXNzZXJ0LW9wdGlvbnMnKTtcclxuXHJcbi8vIHRoaXMgdG8gYWxsb3cgb3ZlcnJpZGUgb3B0aW9ucy1yZWxhdGVkIGVycm9ycyBnbG9iYWxseSAoZm9yIHBnLXByb21pc2UpXHJcbmdsb2JhbC5wZ1Byb21pc2VBc3NlcnQgPSBhc3NlcnRPcHRpb25zO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBhc3NlcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5wZ1Byb21pc2VBc3NlcnQuYXBwbHkobnVsbCwgWy4uLmFyZ3VtZW50c10pO1xyXG4gICAgfVxyXG59O1xyXG4iXSwibmFtZXMiOlsiYXNzZXJ0T3B0aW9ucyIsInJlcXVpcmUiLCJnbG9iYWwiLCJwZ1Byb21pc2VBc3NlcnQiLCJtb2R1bGUiLCJleHBvcnRzIiwiYXNzZXJ0IiwiYXBwbHkiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/assert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/connect.js":
/*!************************************************!*\
  !*** ./node_modules/pg-promise/lib/connect.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Events } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/pg-promise/lib/events.js\");\nconst { ColorConsole } = __webpack_require__(/*! ./utils/color */ \"(rsc)/./node_modules/pg-promise/lib/utils/color.js\");\nconst npm = {\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\"),\n    formatting: __webpack_require__(/*! ./formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\")\n};\nfunction poolConnect(ctx, db, config) {\n    return config.promise((resolve, reject)=>{\n        const p = db.$pool;\n        if (p.ending) {\n            db.$destroy();\n            const err = new Error(npm.text.poolDestroyed);\n            Events.error(ctx.options, err, {\n                dc: ctx.dc\n            });\n            reject(err);\n            return;\n        }\n        p.connect((err, client)=>{\n            if (err) {\n                Events.error(ctx.options, err, {\n                    cn: npm.utils.getSafeConnection(ctx.cn),\n                    dc: ctx.dc\n                });\n                reject(err);\n            } else {\n                if (\"$useCount\" in client) {\n                    // Make sure useCount drops to 1, if it ever reaches maximum integer number;\n                    // We do not drop it to zero, to avoid rerun of initialization queries that\n                    // usually check for useCount === 0;\n                    // istanbul ignore if\n                    if (client.$useCount >= Number.MAX_SAFE_INTEGER) {\n                        client.$useCount = 1; // resetting; cannot auto-test this\n                    } else {\n                        client.$useCount = ++client.$useCount;\n                    }\n                } else {\n                    Object.defineProperty(client, \"$useCount\", {\n                        value: 0,\n                        configurable: false,\n                        enumerable: false,\n                        writable: true\n                    });\n                    setSchema(client, ctx);\n                }\n                setCtx(client, ctx);\n                const end = lockClientEnd(client);\n                client.on(\"error\", onError);\n                resolve({\n                    client,\n                    useCount: client.$useCount,\n                    release (kill) {\n                        client.end = end;\n                        client.release(kill || client.$connectionError);\n                        Events.disconnect(ctx, client);\n                        client.removeListener(\"error\", onError);\n                    }\n                });\n                Events.connect(ctx, client, client.$useCount);\n            }\n        });\n    });\n}\nfunction directConnect(ctx, config) {\n    return config.promise((resolve, reject)=>{\n        const client = new config.pgp.pg.Client(ctx.cn);\n        client.connect((err)=>{\n            if (err) {\n                Events.error(ctx.options, err, {\n                    cn: npm.utils.getSafeConnection(ctx.cn),\n                    dc: ctx.dc\n                });\n                reject(err);\n            } else {\n                setSchema(client, ctx);\n                setCtx(client, ctx);\n                const end = lockClientEnd(client);\n                client.on(\"error\", onError);\n                resolve({\n                    client,\n                    useCount: 0,\n                    release () {\n                        client.end = end;\n                        const p = config.promise((res, rej)=>client.end().then(res).catch(rej));\n                        Events.disconnect(ctx, client);\n                        client.removeListener(\"error\", onError);\n                        return p;\n                    }\n                });\n                Events.connect(ctx, client, 0);\n            }\n        });\n    });\n}\n// this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\nfunction onError(err) {\n    const ctx = this.$ctx;\n    const cn = npm.utils.getSafeConnection(ctx.cn);\n    Events.error(ctx.options, err, {\n        cn,\n        dc: ctx.dc\n    });\n    if (ctx.cnOptions && typeof ctx.cnOptions.onLost === \"function\" && !ctx.notified) {\n        try {\n            ctx.cnOptions.onLost.call(this, err, {\n                cn,\n                dc: ctx.dc,\n                start: ctx.start,\n                client: this\n            });\n        } catch (e) {\n            ColorConsole.error(e && e.stack || e);\n        }\n        ctx.notified = true;\n    }\n}\nfunction lockClientEnd(client) {\n    const end = client.end;\n    client.end = (doNotCall)=>{\n        // This call can happen only in the following two cases:\n        // 1. the client made the call directly, against the library's documentation (invalid code)\n        // 2. connection with the server broke, and the pool is terminating all clients forcefully.\n        ColorConsole.error(`${npm.text.clientEnd}\\n${npm.utils.getLocalStack(1, 3)}\\n`);\n        if (!doNotCall) {\n            end.call(client);\n        }\n    };\n    return end;\n}\nfunction setCtx(client, ctx) {\n    Object.defineProperty(client, \"$ctx\", {\n        value: ctx,\n        writable: true\n    });\n}\nfunction setSchema(client, ctx) {\n    let s = ctx.options.schema;\n    if (!s) {\n        return;\n    }\n    if (typeof s === \"function\") {\n        s = s.call(ctx.dc, ctx.dc);\n    }\n    if (Array.isArray(s)) {\n        s = s.filter((a)=>a && typeof a === \"string\");\n    }\n    if (typeof s === \"string\" || Array.isArray(s) && s.length) {\n        client.query(npm.formatting.as.format(\"SET search_path TO $1:name\", [\n            s\n        ]), (err)=>{\n            // istanbul ignore if;\n            if (err) {\n                // This is unlikely to ever happen, unless the connection is created faulty,\n                // and fails on the very first query, which is impossible to test automatically.\n                throw err;\n            }\n        });\n    }\n}\nmodule.exports = (config)=>({\n        pool: (ctx, db)=>poolConnect(ctx, db, config),\n        direct: (ctx)=>directConnect(ctx, config)\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvY29ubmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxNQUFNLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFDQyxZQUFZLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFFL0IsTUFBTUUsTUFBTTtJQUNSQyxPQUFPSCxtQkFBT0EsQ0FBQztJQUNmSSxNQUFNSixtQkFBT0EsQ0FBQztJQUNkSyxZQUFZTCxtQkFBT0EsQ0FBQztBQUN4QjtBQUVBLFNBQVNNLFlBQVlDLEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxNQUFNO0lBQ2hDLE9BQU9BLE9BQU9DLE9BQU8sQ0FBQyxDQUFDQyxTQUFTQztRQUM1QixNQUFNQyxJQUFJTCxHQUFHTSxLQUFLO1FBQ2xCLElBQUlELEVBQUVFLE1BQU0sRUFBRTtZQUNWUCxHQUFHUSxRQUFRO1lBQ1gsTUFBTUMsTUFBTSxJQUFJQyxNQUFNaEIsSUFBSUUsSUFBSSxDQUFDZSxhQUFhO1lBQzVDcEIsT0FBT3FCLEtBQUssQ0FBQ2IsSUFBSWMsT0FBTyxFQUFFSixLQUFLO2dCQUMzQkssSUFBSWYsSUFBSWUsRUFBRTtZQUNkO1lBQ0FWLE9BQU9LO1lBQ1A7UUFDSjtRQUNBSixFQUFFVSxPQUFPLENBQUMsQ0FBQ04sS0FBS087WUFDWixJQUFJUCxLQUFLO2dCQUNMbEIsT0FBT3FCLEtBQUssQ0FBQ2IsSUFBSWMsT0FBTyxFQUFFSixLQUFLO29CQUMzQlEsSUFBSXZCLElBQUlDLEtBQUssQ0FBQ3VCLGlCQUFpQixDQUFDbkIsSUFBSWtCLEVBQUU7b0JBQ3RDSCxJQUFJZixJQUFJZSxFQUFFO2dCQUNkO2dCQUNBVixPQUFPSztZQUNYLE9BQU87Z0JBQ0gsSUFBSSxlQUFlTyxRQUFRO29CQUN2Qiw0RUFBNEU7b0JBQzVFLDJFQUEyRTtvQkFDM0Usb0NBQW9DO29CQUNwQyxxQkFBcUI7b0JBQ3JCLElBQUlBLE9BQU9HLFNB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SyxPQUFPQSxNQUFNO0lBQ3hDO0lBQ0EsSUFBSSxPQUFPTCxNQUFNLFlBQWFFLE1BQU1DLE9BQU8sQ0FBQ0gsTUFBTUEsRUFBRU0sTUFBTSxFQUFHO1FBQ3pEakQsT0FBT2tELEtBQUssQ0FBQ3hFLElBQUlHLFVBQVUsQ0FBQ3NFLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDLDhCQUE4QjtZQUFDVDtTQUFFLEdBQUdsRCxDQUFBQTtZQUN0RSxzQkFBc0I7WUFDdEIsSUFBSUEsS0FBSztnQkFDTCw0RUFBNEU7Z0JBQzVFLGdGQUFnRjtnQkFDaEYsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7QUFDSjtBQUVBNEQsT0FBT0MsT0FBTyxHQUFHckUsQ0FBQUEsU0FBVztRQUN4QnNFLE1BQU0sQ0FBQ3hFLEtBQUtDLEtBQU9GLFlBQVlDLEtBQUtDLElBQUlDO1FBQ3hDdUUsUUFBUXpFLENBQUFBLE1BQU95QyxjQUFjekMsS0FBS0U7SUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9jb25uZWN0LmpzP2RkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtFdmVudHN9ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuY29uc3Qge0NvbG9yQ29uc29sZX0gPSByZXF1aXJlKCcuL3V0aWxzL2NvbG9yJyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpLFxyXG4gICAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JyksXHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuL2Zvcm1hdHRpbmcnKVxyXG59O1xyXG5cclxuZnVuY3Rpb24gcG9vbENvbm5lY3QoY3R4LCBkYiwgY29uZmlnKSB7XHJcbiAgICByZXR1cm4gY29uZmlnLnByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHAgPSBkYi4kcG9vbDtcclxuICAgICAgICBpZiAocC5lbmRpbmcpIHtcclxuICAgICAgICAgICAgZGIuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG5wbS50ZXh0LnBvb2xEZXN0cm95ZWQpO1xyXG4gICAgICAgICAgICBFdmVudHMuZXJyb3IoY3R4Lm9wdGlvbnMsIGVyciwge1xyXG4gICAgICAgICAgICAgICAgZGM6IGN0eC5kY1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcC5jb25uZWN0KChlcnIsIGNsaWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBFdmVudHMuZXJyb3IoY3R4Lm9wdGlvbnMsIGVyciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNuOiBucG0udXRpbHMuZ2V0U2FmZUNvbm5lY3Rpb24oY3R4LmNuKSxcclxuICAgICAgICAgICAgICAgICAgICBkYzogY3R4LmRjXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCckdXNlQ291bnQnIGluIGNsaWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB1c2VDb3VudCBkcm9wcyB0byAxLCBpZiBpdCBldmVyIHJlYWNoZXMgbWF4aW11bSBpbnRlZ2VyIG51bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgZHJvcCBpdCB0byB6ZXJvLCB0byBhdm9pZCByZXJ1biBvZiBpbml0aWFsaXphdGlvbiBxdWVyaWVzIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c3VhbGx5IGNoZWNrIGZvciB1c2VDb3VudCA9PT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LiR1c2VDb3VudCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuJHVzZUNvdW50ID0gMTsgLy8gcmVzZXR0aW5nOyBjYW5ub3QgYXV0by10ZXN0IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuJHVzZUNvdW50ID0gKytjbGllbnQuJHVzZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsaWVudCwgJyR1c2VDb3VudCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFNjaGVtYShjbGllbnQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRDdHgoY2xpZW50LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gbG9ja0NsaWVudEVuZChjbGllbnQpO1xyXG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUNvdW50OiBjbGllbnQuJHVzZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2Uoa2lsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQucmVsZWFzZShraWxsIHx8IGNsaWVudC4kY29ubmVjdGlvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRzLmRpc2Nvbm5lY3QoY3R4LCBjbGllbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBFdmVudHMuY29ubmVjdChjdHgsIGNsaWVudCwgY2xpZW50LiR1c2VDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkaXJlY3RDb25uZWN0KGN0eCwgY29uZmlnKSB7XHJcbiAgICByZXR1cm4gY29uZmlnLnByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBjb25maWcucGdwLnBnLkNsaWVudChjdHguY24pO1xyXG4gICAgICAgIGNsaWVudC5jb25uZWN0KGVyciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIEV2ZW50cy5lcnJvcihjdHgub3B0aW9ucywgZXJyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY246IG5wbS51dGlscy5nZXRTYWZlQ29ubmVjdGlvbihjdHguY24pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRjOiBjdHguZGNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTY2hlbWEoY2xpZW50LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3R4KGNsaWVudCwgY3R4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2tDbGllbnRFbmQoY2xpZW50KTtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5vbignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VDb3VudDogMCxcclxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY29uZmlnLnByb21pc2UoKHJlcywgcmVqKSA9PiBjbGllbnQuZW5kKCkudGhlbihyZXMpLmNhdGNoKHJlaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBFdmVudHMuZGlzY29ubmVjdChjdHgsIGNsaWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBFdmVudHMuY29ubmVjdChjdHgsIGNsaWVudCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyB0aGlzIGV2ZW50IG9ubHkgaGFwcGVucyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGxvc3QgcGh5c2ljYWxseSxcclxuLy8gd2hpY2ggY2Fubm90IGJlIHRlc3RlZCBhdXRvbWF0aWNhbGx5OyByZW1vdmluZyBmcm9tIGNvdmVyYWdlOlxyXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG5mdW5jdGlvbiBvbkVycm9yKGVycikge1xyXG4gICAgY29uc3QgY3R4ID0gdGhpcy4kY3R4O1xyXG4gICAgY29uc3QgY24gPSBucG0udXRpbHMuZ2V0U2FmZUNvbm5lY3Rpb24oY3R4LmNuKTtcclxuICAgIEV2ZW50cy5lcnJvcihjdHgub3B0aW9ucywgZXJyLCB7Y24sIGRjOiBjdHguZGN9KTtcclxuICAgIGlmIChjdHguY25PcHRpb25zICYmIHR5cGVvZiBjdHguY25PcHRpb25zLm9uTG9zdCA9PT0gJ2Z1bmN0aW9uJyAmJiAhY3R4Lm5vdGlmaWVkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY3R4LmNuT3B0aW9ucy5vbkxvc3QuY2FsbCh0aGlzLCBlcnIsIHtcclxuICAgICAgICAgICAgICAgIGNuLFxyXG4gICAgICAgICAgICAgICAgZGM6IGN0eC5kYyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjdHguc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBDb2xvckNvbnNvbGUuZXJyb3IoZSAmJiBlLnN0YWNrIHx8IGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgubm90aWZpZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb2NrQ2xpZW50RW5kKGNsaWVudCkge1xyXG4gICAgY29uc3QgZW5kID0gY2xpZW50LmVuZDtcclxuICAgIGNsaWVudC5lbmQgPSBkb05vdENhbGwgPT4ge1xyXG4gICAgICAgIC8vIFRoaXMgY2FsbCBjYW4gaGFwcGVuIG9ubHkgaW4gdGhlIGZvbGxvd2luZyB0d28gY2FzZXM6XHJcbiAgICAgICAgLy8gMS4gdGhlIGNsaWVudCBtYWRlIHRoZSBjYWxsIGRpcmVjdGx5LCBhZ2FpbnN0IHRoZSBsaWJyYXJ5J3MgZG9jdW1lbnRhdGlvbiAoaW52YWxpZCBjb2RlKVxyXG4gICAgICAgIC8vIDIuIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyIGJyb2tlLCBhbmQgdGhlIHBvb2wgaXMgdGVybWluYXRpbmcgYWxsIGNsaWVudHMgZm9yY2VmdWxseS5cclxuICAgICAgICBDb2xvckNvbnNvbGUuZXJyb3IoYCR7bnBtLnRleHQuY2xpZW50RW5kfVxcbiR7bnBtLnV0aWxzLmdldExvY2FsU3RhY2soMSwgMyl9XFxuYCk7XHJcbiAgICAgICAgaWYgKCFkb05vdENhbGwpIHtcclxuICAgICAgICAgICAgZW5kLmNhbGwoY2xpZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVuZDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Q3R4KGNsaWVudCwgY3R4KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xpZW50LCAnJGN0eCcsIHtcclxuICAgICAgICB2YWx1ZTogY3R4LFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U2NoZW1hKGNsaWVudCwgY3R4KSB7XHJcbiAgICBsZXQgcyA9IGN0eC5vcHRpb25zLnNjaGVtYTtcclxuICAgIGlmICghcykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHMgPSBzLmNhbGwoY3R4LmRjLCBjdHguZGMpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocykpIHtcclxuICAgICAgICBzID0gcy5maWx0ZXIoYSA9PiBhICYmIHR5cGVvZiBhID09PSAnc3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IChBcnJheS5pc0FycmF5KHMpICYmIHMubGVuZ3RoKSkge1xyXG4gICAgICAgIGNsaWVudC5xdWVyeShucG0uZm9ybWF0dGluZy5hcy5mb3JtYXQoJ1NFVCBzZWFyY2hfcGF0aCBUTyAkMTpuYW1lJywgW3NdKSwgZXJyID0+IHtcclxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGlmO1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVubGlrZWx5IHRvIGV2ZXIgaGFwcGVuLCB1bmxlc3MgdGhlIGNvbm5lY3Rpb24gaXMgY3JlYXRlZCBmYXVsdHksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgZmFpbHMgb24gdGhlIHZlcnkgZmlyc3QgcXVlcnksIHdoaWNoIGlzIGltcG9zc2libGUgdG8gdGVzdCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29uZmlnID0+ICh7XHJcbiAgICBwb29sOiAoY3R4LCBkYikgPT4gcG9vbENvbm5lY3QoY3R4LCBkYiwgY29uZmlnKSxcclxuICAgIGRpcmVjdDogY3R4ID0+IGRpcmVjdENvbm5lY3QoY3R4LCBjb25maWcpXHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiRXZlbnRzIiwicmVxdWlyZSIsIkNvbG9yQ29uc29sZSIsIm5wbSIsInV0aWxzIiwidGV4dCIsImZvcm1hdHRpbmciLCJwb29sQ29ubmVjdCIsImN0eCIsImRiIiwiY29uZmlnIiwicHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwIiwiJHBvb2wiLCJlbmRpbmciLCIkZGVzdHJveSIsImVyciIsIkVycm9yIiwicG9vbERlc3Ryb3llZCIsImVycm9yIiwib3B0aW9ucyIsImRjIiwiY29ubmVjdCIsImNsaWVudCIsImNuIiwiZ2V0U2FmZUNvbm5lY3Rpb24iLCIkdXNlQ291bnQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInNldFNjaGVtYSIsInNldEN0eCIsImVuZCIsImxvY2tDbGllbnRFbmQiLCJvbiIsIm9uRXJyb3IiLCJ1c2VDb3VudCIsInJlbGVhc2UiLCJraWxsIiwiJGNvbm5lY3Rpb25FcnJvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVMaXN0ZW5lciIsImRpcmVjdENvbm5lY3QiLCJwZ3AiLCJwZyIsIkNsaWVudCIsInJlcyIsInJlaiIsInRoZW4iLCJjYXRjaCIsIiRjdHgiLCJjbk9wdGlvbnMiLCJvbkxvc3QiLCJub3RpZmllZCIsImNhbGwiLCJzdGFydCIsImUiLCJzdGFjayIsImRvTm90Q2FsbCIsImNsaWVudEVuZCIsImdldExvY2FsU3RhY2siLCJzIiwic2NoZW1hIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiYSIsImxlbmd0aCIsInF1ZXJ5IiwiYXMiLCJmb3JtYXQiLCJtb2R1bGUiLCJleHBvcnRzIiwicG9vbCIsImRpcmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/context.js":
/*!************************************************!*\
  !*** ./node_modules/pg-promise/lib/context.js ***!
  \************************************************/
/***/ ((module) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ /**\r\n * @class ConnectionContext\r\n * @private\r\n * @summary Internal connection context.\r\n *\r\n * @param {object} cc\r\n * Connection Context.\r\n *\r\n * @param {object} cc.cn\r\n * Connection details\r\n *\r\n * @param {*} cc.dc\r\n * Database Context\r\n *\r\n * @param {object} cc.options\r\n * Library's Initialization Options\r\n *\r\n * @param {object} cc.db\r\n * Database Session we're attached to, if any.\r\n *\r\n * @param {number} cc.level\r\n * Task Level\r\n *\r\n * @param {number} cc.txLevel\r\n * Transaction Level\r\n *\r\n * @param {object} cc.parentCtx\r\n * Connection Context of the parent operation, if any.\r\n *\r\n */ \nclass ConnectionContext {\n    constructor(cc){\n        this.cn = cc.cn; // connection details;\n        this.dc = cc.dc; // database context;\n        this.options = cc.options; // library options;\n        this.db = cc.db; // database session;\n        this.level = cc.level; // task level;\n        this.txLevel = cc.txLevel; // transaction level;\n        this.parentCtx = null; // parent context\n        this.taskCtx = null; // task context\n        this.start = null; // Date/Time when connected\n        this.txCount = 0;\n    }\n    connect(db) {\n        this.db = db;\n        this.start = new Date();\n    }\n    disconnect(kill) {\n        if (this.db) {\n            const p = this.db.release(kill);\n            this.db = null;\n            return p;\n        }\n    }\n    clone() {\n        const obj = new ConnectionContext(this);\n        obj.parent = this;\n        obj.parentCtx = this.taskCtx;\n        return obj;\n    }\n    get nextTxCount() {\n        let txCurrent = this, txTop = this;\n        while(txCurrent.parent){\n            txCurrent = txCurrent.parent;\n            if (txCurrent.taskCtx && txCurrent.taskCtx.isTX) {\n                txTop = txCurrent;\n            }\n        }\n        return txTop.txCount++;\n    }\n}\n/**\r\n * Connection Context\r\n * @module context\r\n * @author Vitaly Tomilov\r\n * @private\r\n */ module.exports = {\n    ConnectionContext\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDO0FBQ0QsTUFBTUE7SUFFRkMsWUFBWUMsRUFBRSxDQUFFO1FBQ1osSUFBSSxDQUFDQyxFQUFFLEdBQUdELEdBQUdDLEVBQUUsRUFBRSxzQkFBc0I7UUFDdkMsSUFBSSxDQUFDQyxFQUFFLEdBQUdGLEdBQUdFLEVBQUUsRUFBRSxvQkFBb0I7UUFDckMsSUFBSSxDQUFDQyxPQUFPLEdBQUdILEdBQUdHLE9BQU8sRUFBRSxtQkFBbUI7UUFDOUMsSUFBSSxDQUFDQyxFQUFFLEdBQUdKLEdBQUdJLEVBQUUsRUFBRSxvQkFBb0I7UUFDckMsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLEdBQUdLLEtBQUssRUFBRSxjQUFjO1FBQ3JDLElBQUksQ0FBQ0MsT0FBTyxHQUFHTixHQUFHTSxPQUFPLEVBQUUscUJBQXFCO1FBQ2hELElBQUksQ0FBQ0MsU0FBUyxHQUFHLE1BQU0saUJBQWlCO1FBQ3hDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLE1BQU0sZUFBZTtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxNQUFNLDJCQUEyQjtRQUM5QyxJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNuQjtJQUVBQyxRQUFRUCxFQUFFLEVBQUU7UUFDUixJQUFJLENBQUNBLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNLLEtBQUssR0FBRyxJQUFJRztJQUNyQjtJQUVBQyxXQUFXQyxJQUFJLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQ1YsRUFBRSxFQUFFO1lBQ1QsTUFBTVcsSUFBSSxJQUFJLENBQUNYLEVBQUUsQ0FBQ1ksT0FBTyxDQUFDRjtZQUMxQixJQUFJLENBQUNWLEVBQUUsR0FBRztZQUNWLE9BQU9XO1FBQ1g7SUFDSjtJQUVBRSxRQUFRO1FBQ0osTUFBTUMsTUFBTSxJQUFJcEIsa0JBQWtCLElBQUk7UUFDdENvQixJQUFJQyxNQUFNLEdBQUcsSUFBSTtRQUNqQkQsSUFBSVgsU0FBUyxHQUFHLElBQUksQ0FBQ0MsT0FBTztRQUM1QixPQUFPVTtJQUNYO0lBRUEsSUFBSUUsY0FBYztRQUNkLElBQUlDLFlBQVksSUFBSSxFQUFFQyxRQUFRLElBQUk7UUFDbEMsTUFBT0QsVUFBVUYsTUFBTSxDQUFFO1lBQ3JCRSxZQUFZQSxVQUFVRixNQUFNO1lBQzVCLElBQUlFLFVBQVViLE9BQU8sSUFBSWEsVUFBVWIsT0FBTyxDQUFDZSxJQUFJLEVBQUU7Z0JBQzdDRCxRQUFRRDtZQUNaO1FBQ0o7UUFDQSxPQUFPQyxNQUFNWixPQUFPO0lBQ3hCO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNEYyxPQUFPQyxPQUFPLEdBQUc7SUFBQzNCO0FBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvY29udGV4dC5qcz8xYzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIENvbm5lY3Rpb25Db250ZXh0XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdW1tYXJ5IEludGVybmFsIGNvbm5lY3Rpb24gY29udGV4dC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNjXHJcbiAqIENvbm5lY3Rpb24gQ29udGV4dC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNjLmNuXHJcbiAqIENvbm5lY3Rpb24gZGV0YWlsc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNjLmRjXHJcbiAqIERhdGFiYXNlIENvbnRleHRcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNjLm9wdGlvbnNcclxuICogTGlicmFyeSdzIEluaXRpYWxpemF0aW9uIE9wdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNjLmRiXHJcbiAqIERhdGFiYXNlIFNlc3Npb24gd2UncmUgYXR0YWNoZWQgdG8sIGlmIGFueS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNjLmxldmVsXHJcbiAqIFRhc2sgTGV2ZWxcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNjLnR4TGV2ZWxcclxuICogVHJhbnNhY3Rpb24gTGV2ZWxcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNjLnBhcmVudEN0eFxyXG4gKiBDb25uZWN0aW9uIENvbnRleHQgb2YgdGhlIHBhcmVudCBvcGVyYXRpb24sIGlmIGFueS5cclxuICpcclxuICovXHJcbmNsYXNzIENvbm5lY3Rpb25Db250ZXh0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYykge1xyXG4gICAgICAgIHRoaXMuY24gPSBjYy5jbjsgLy8gY29ubmVjdGlvbiBkZXRhaWxzO1xyXG4gICAgICAgIHRoaXMuZGMgPSBjYy5kYzsgLy8gZGF0YWJhc2UgY29udGV4dDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjYy5vcHRpb25zOyAvLyBsaWJyYXJ5IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5kYiA9IGNjLmRiOyAvLyBkYXRhYmFzZSBzZXNzaW9uO1xyXG4gICAgICAgIHRoaXMubGV2ZWwgPSBjYy5sZXZlbDsgLy8gdGFzayBsZXZlbDtcclxuICAgICAgICB0aGlzLnR4TGV2ZWwgPSBjYy50eExldmVsOyAvLyB0cmFuc2FjdGlvbiBsZXZlbDtcclxuICAgICAgICB0aGlzLnBhcmVudEN0eCA9IG51bGw7IC8vIHBhcmVudCBjb250ZXh0XHJcbiAgICAgICAgdGhpcy50YXNrQ3R4ID0gbnVsbDsgLy8gdGFzayBjb250ZXh0XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IG51bGw7IC8vIERhdGUvVGltZSB3aGVuIGNvbm5lY3RlZFxyXG4gICAgICAgIHRoaXMudHhDb3VudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdChkYikge1xyXG4gICAgICAgIHRoaXMuZGIgPSBkYjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IERhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNjb25uZWN0KGtpbGwpIHtcclxuICAgICAgICBpZiAodGhpcy5kYikge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5kYi5yZWxlYXNlKGtpbGwpO1xyXG4gICAgICAgICAgICB0aGlzLmRiID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyBDb25uZWN0aW9uQ29udGV4dCh0aGlzKTtcclxuICAgICAgICBvYmoucGFyZW50ID0gdGhpcztcclxuICAgICAgICBvYmoucGFyZW50Q3R4ID0gdGhpcy50YXNrQ3R4O1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG5leHRUeENvdW50KCkge1xyXG4gICAgICAgIGxldCB0eEN1cnJlbnQgPSB0aGlzLCB0eFRvcCA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHR4Q3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdHhDdXJyZW50ID0gdHhDdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKHR4Q3VycmVudC50YXNrQ3R4ICYmIHR4Q3VycmVudC50YXNrQ3R4LmlzVFgpIHtcclxuICAgICAgICAgICAgICAgIHR4VG9wID0gdHhDdXJyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eFRvcC50eENvdW50Kys7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25uZWN0aW9uIENvbnRleHRcclxuICogQG1vZHVsZSBjb250ZXh0XHJcbiAqIEBhdXRob3IgVml0YWx5IFRvbWlsb3ZcclxuICogQHByaXZhdGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge0Nvbm5lY3Rpb25Db250ZXh0fTtcclxuIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb25Db250ZXh0IiwiY29uc3RydWN0b3IiLCJjYyIsImNuIiwiZGMiLCJvcHRpb25zIiwiZGIiLCJsZXZlbCIsInR4TGV2ZWwiLCJwYXJlbnRDdHgiLCJ0YXNrQ3R4Iiwic3RhcnQiLCJ0eENvdW50IiwiY29ubmVjdCIsIkRhdGUiLCJkaXNjb25uZWN0Iiwia2lsbCIsInAiLCJyZWxlYXNlIiwiY2xvbmUiLCJvYmoiLCJwYXJlbnQiLCJuZXh0VHhDb3VudCIsInR4Q3VycmVudCIsInR4VG9wIiwiaXNUWCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/database-pool.js":
/*!******************************************************!*\
  !*** ./node_modules/pg-promise/lib/database-pool.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ColorConsole } = __webpack_require__(/*! ./utils/color */ \"(rsc)/./node_modules/pg-promise/lib/utils/color.js\");\nconst npm = {\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @class DatabasePool\r\n * @static\r\n * @private\r\n */ class DatabasePool {\n    /**\r\n     * Global instance of the database pool repository.\r\n     *\r\n     * @returns {{dbMap: {}, dbs: Array}}\r\n     */ static get instance() {\n        const s = Symbol.for(\"pgPromiseDatabasePool\");\n        let scope = global[s];\n        if (!scope) {\n            scope = {\n                dbMap: {},\n                dbs: [] // all database objects\n            };\n            global[s] = scope;\n        }\n        return scope;\n    }\n    /**\r\n     * @method DatabasePool.register\r\n     * @static\r\n     * @description\r\n     *  - Registers each database object, to make sure no duplicates connections are used,\r\n     *    and if they are, produce a warning;\r\n     *  - Registers each Pool object, to be able to release them all when requested.\r\n     *\r\n     * @param {Database} db - The new Database object being registered.\r\n     */ static register(db) {\n        const cnKey = DatabasePool.createContextKey(db);\n        npm.utils.addReadProp(db, \"$cnKey\", cnKey, true);\n        const { dbMap, dbs } = DatabasePool.instance;\n        if (cnKey in dbMap) {\n            dbMap[cnKey]++;\n            /* istanbul ignore if */ if (!db.$config.options.noWarnings) {\n                ColorConsole.warn(`WARNING: Creating a duplicate database object for the same connection.\\n${npm.utils.getLocalStack(4, 3)}\\n`);\n            }\n        } else {\n            dbMap[cnKey] = 1;\n        }\n        dbs.push(db);\n    }\n    /**\r\n     * @method DatabasePool.unregister\r\n     * @static\r\n     * @param db\r\n     */ static unregister(db) {\n        const cnKey = db.$cnKey;\n        const { dbMap } = DatabasePool.instance;\n        if (!--dbMap[cnKey]) {\n            delete dbMap[cnKey];\n        }\n    }\n    /**\r\n     * @method DatabasePool.shutDown\r\n     * @static\r\n     */ static shutDown() {\n        const { instance } = DatabasePool;\n        instance.dbs.forEach((db)=>{\n            db.$destroy();\n        });\n        instance.dbs.length = 0;\n        instance.dbMap = {};\n    }\n    /**\r\n     * @method DatabasePool.createContextKey\r\n     * @static\r\n     * @description\r\n     * For connections that are objects it reorders the keys alphabetically,\r\n     * and then serializes the result into a JSON string.\r\n     *\r\n     * @param {Database} db - Database instance.\r\n     */ static createContextKey(db) {\n        let cn = db.$cn;\n        if (typeof cn === \"object\") {\n            const obj = {}, keys = Object.keys(cn).sort();\n            keys.forEach((name)=>{\n                obj[name] = cn[name];\n            });\n            cn = obj;\n        }\n        return npm.utils.toJson(npm.utils.getSafeConnection(cn)) + npm.utils.toJson(db.$dc);\n    }\n}\nmodule.exports = {\n    DatabasePool\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZGF0YWJhc2UtcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxZQUFZLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFL0IsTUFBTUMsTUFBTTtJQUNSQyxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNRztJQUVGOzs7O0tBSUMsR0FDRCxXQUFXQyxXQUFXO1FBQ2xCLE1BQU1DLElBQUlDLE9BQU9DLEdBQUcsQ0FBQztRQUNyQixJQUFJQyxRQUFRQyxNQUFNLENBQUNKLEVBQUU7UUFDckIsSUFBSSxDQUFDRyxPQUFPO1lBQ1JBLFFBQVE7Z0JBQ0pFLE9BQU8sQ0FBQztnQkFDUkMsS0FBSyxFQUFFLENBQUMsdUJBQXVCO1lBQ25DO1lBQ0FGLE1BQU0sQ0FBQ0osRUFBRSxHQUFHRztRQUNoQjtRQUNBLE9BQU9BO0lBQ1g7SUFFQTs7Ozs7Ozs7O0tBU0MsR0FDRCxPQUFPSSxTQUFTQyxFQUFFLEVBQUU7UUFDaEIsTUFBTUMsUUFBUVgsYUFBYVksZ0JBQWdCLENBQUNGO1FBQzVDWixJQUFJQyxLQUFLLENBQUNjLFdBQVcsQ0FBQ0gsSUFBSSxVQUFVQyxPQUFPO1FBQzNDLE1BQU0sRUFBQ0osS0FBSyxFQUFFQyxHQUFHLEVBQUMsR0FBR1IsYUFBYUMsUUFBUTtRQUMxQyxJQUFJVSxTQUFTSixPQUFPO1lBQ2hCQSxLQUFLLENBQUNJLE1BQU07WUFDWixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDRCxHQUFHSSxPQUFPLENBQUNDLE9BQU8sQ0FBQ0MsVUFBVSxFQUFFO2dCQUNoQ3BCLGFBQWFxQixJQUFJLENBQUMsQ0FBQyx3RUFBd0UsRUFBRW5CLElBQUlDLEtBQUssQ0FBQ21CLGFBQWEsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1lBQ2xJO1FBQ0osT0FBTztZQUNIWCxLQUFLLENBQUNJLE1BQU0sR0FBRztRQUNuQjtRQUNBSCxJQUFJVyxJQUFJLENBQUNUO0lBQ2I7SUFFQTs7OztLQUlDLEdBQ0QsT0FBT1UsV0FBV1YsRUFBRSxFQUFFO1FBQ2xCLE1BQU1DLFFBQVFELEdBQUdXLE1BQU07UUFDdkIsTUFBTSxFQUFDZCxLQUFLLEVBQUMsR0FBR1AsYUFBYUMsUUFBUTtRQUNyQyxJQUFJLENBQUMsRUFBRU0sS0FBSyxDQUFDSSxNQUFNLEVBQUU7WUFDakIsT0FBT0osS0FBSyxDQUFDSSxNQUFNO1FBQ3ZCO0lBQ0o7SUFFQTs7O0tBR0MsR0FDRCxPQUFPVyxXQUFXO1FBQ2QsTUFBTSxFQUFDckIsUUFBUSxFQUFDLEdBQUdEO1FBQ25CQyxTQUFTTyxHQUFHLENBQUNlLE9BQU8sQ0FBQ2IsQ0FBQUE7WUFDakJBLEdBQUdjLFFBQVE7UUFDZjtRQUNBdkIsU0FBU08sR0FBRyxDQUFDaUIsTUFBTSxHQUFHO1FBQ3RCeEIsU0FBU00sS0FBSyxHQUFHLENBQUM7SUFDdEI7SUFFQTs7Ozs7Ozs7S0FRQyxHQUNELE9BQU9LLGlCQUFpQkYsRUFBRSxFQUFFO1FBQ3hCLElBQUlnQixLQUFLaEIsR0FBR2lCLEdBQUc7UUFDZixJQUFJLE9BQU9ELE9BQU8sVUFBVTtZQUN4QixNQUFNRSxNQUFNLENBQUMsR0FBR0MsT0FBT0MsT0FBT0QsSUFBSSxDQUFDSCxJQUFJSyxJQUFJO1lBQzNDRixLQUFLTixPQUFPLENBQUNTLENBQUFBO2dCQUNUSixHQUFHLENBQUNJLEtBQUssR0FBR04sRUFBRSxDQUFDTSxLQUFLO1lBQ3hCO1lBQ0FOLEtBQUtFO1FBQ1Q7UUFDQSxPQUFPOUIsSUFBSUMsS0FBSyxDQUFDa0MsTUFBTSxDQUFDbkMsSUFBSUMsS0FBSyxDQUFDbUMsaUJBQWlCLENBQUNSLE9BQU81QixJQUFJQyxLQUFLLENBQUNrQyxNQUFNLENBQUN2QixHQUFHeUIsR0FBRztJQUN0RjtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUFDckM7QUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2RhdGFiYXNlLXBvb2wuanM/ZjI5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge0NvbG9yQ29uc29sZX0gPSByZXF1aXJlKCcuL3V0aWxzL2NvbG9yJyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpXHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIERhdGFiYXNlUG9vbFxyXG4gKiBAc3RhdGljXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZVBvb2wge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsIGluc3RhbmNlIG9mIHRoZSBkYXRhYmFzZSBwb29sIHJlcG9zaXRvcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3tkYk1hcDoge30sIGRiczogQXJyYXl9fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBTeW1ib2wuZm9yKCdwZ1Byb21pc2VEYXRhYmFzZVBvb2wnKTtcclxuICAgICAgICBsZXQgc2NvcGUgPSBnbG9iYWxbc107XHJcbiAgICAgICAgaWYgKCFzY29wZSkge1xyXG4gICAgICAgICAgICBzY29wZSA9IHtcclxuICAgICAgICAgICAgICAgIGRiTWFwOiB7fSwgLy8gbWFwIG9mIHVzZWQgZGF0YWJhc2UgY29udGV4dCBrZXlzIChjb25uZWN0aW9uICsgZGMpXHJcbiAgICAgICAgICAgICAgICBkYnM6IFtdIC8vIGFsbCBkYXRhYmFzZSBvYmplY3RzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGdsb2JhbFtzXSA9IHNjb3BlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2NvcGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIERhdGFiYXNlUG9vbC5yZWdpc3RlclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiAgLSBSZWdpc3RlcnMgZWFjaCBkYXRhYmFzZSBvYmplY3QsIHRvIG1ha2Ugc3VyZSBubyBkdXBsaWNhdGVzIGNvbm5lY3Rpb25zIGFyZSB1c2VkLFxyXG4gICAgICogICAgYW5kIGlmIHRoZXkgYXJlLCBwcm9kdWNlIGEgd2FybmluZztcclxuICAgICAqICAtIFJlZ2lzdGVycyBlYWNoIFBvb2wgb2JqZWN0LCB0byBiZSBhYmxlIHRvIHJlbGVhc2UgdGhlbSBhbGwgd2hlbiByZXF1ZXN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtEYXRhYmFzZX0gZGIgLSBUaGUgbmV3IERhdGFiYXNlIG9iamVjdCBiZWluZyByZWdpc3RlcmVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVnaXN0ZXIoZGIpIHtcclxuICAgICAgICBjb25zdCBjbktleSA9IERhdGFiYXNlUG9vbC5jcmVhdGVDb250ZXh0S2V5KGRiKTtcclxuICAgICAgICBucG0udXRpbHMuYWRkUmVhZFByb3AoZGIsICckY25LZXknLCBjbktleSwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qge2RiTWFwLCBkYnN9ID0gRGF0YWJhc2VQb29sLmluc3RhbmNlO1xyXG4gICAgICAgIGlmIChjbktleSBpbiBkYk1hcCkge1xyXG4gICAgICAgICAgICBkYk1hcFtjbktleV0rKztcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICghZGIuJGNvbmZpZy5vcHRpb25zLm5vV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgICAgIENvbG9yQ29uc29sZS53YXJuKGBXQVJOSU5HOiBDcmVhdGluZyBhIGR1cGxpY2F0ZSBkYXRhYmFzZSBvYmplY3QgZm9yIHRoZSBzYW1lIGNvbm5lY3Rpb24uXFxuJHtucG0udXRpbHMuZ2V0TG9jYWxTdGFjayg0LCAzKX1cXG5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRiTWFwW2NuS2V5XSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRicy5wdXNoKGRiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgRGF0YWJhc2VQb29sLnVucmVnaXN0ZXJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSBkYlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdW5yZWdpc3RlcihkYikge1xyXG4gICAgICAgIGNvbnN0IGNuS2V5ID0gZGIuJGNuS2V5O1xyXG4gICAgICAgIGNvbnN0IHtkYk1hcH0gPSBEYXRhYmFzZVBvb2wuaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKCEtLWRiTWFwW2NuS2V5XSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGJNYXBbY25LZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgRGF0YWJhc2VQb29sLnNodXREb3duXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzaHV0RG93bigpIHtcclxuICAgICAgICBjb25zdCB7aW5zdGFuY2V9ID0gRGF0YWJhc2VQb29sO1xyXG4gICAgICAgIGluc3RhbmNlLmRicy5mb3JFYWNoKGRiID0+IHtcclxuICAgICAgICAgICAgZGIuJGRlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbnN0YW5jZS5kYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpbnN0YW5jZS5kYk1hcCA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBEYXRhYmFzZVBvb2wuY3JlYXRlQ29udGV4dEtleVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBGb3IgY29ubmVjdGlvbnMgdGhhdCBhcmUgb2JqZWN0cyBpdCByZW9yZGVycyB0aGUga2V5cyBhbHBoYWJldGljYWxseSxcclxuICAgICAqIGFuZCB0aGVuIHNlcmlhbGl6ZXMgdGhlIHJlc3VsdCBpbnRvIGEgSlNPTiBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtEYXRhYmFzZX0gZGIgLSBEYXRhYmFzZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUNvbnRleHRLZXkoZGIpIHtcclxuICAgICAgICBsZXQgY24gPSBkYi4kY247XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqID0ge30sIGtleXMgPSBPYmplY3Qua2V5cyhjbikuc29ydCgpO1xyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvYmpbbmFtZV0gPSBjbltuYW1lXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNuID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnBtLnV0aWxzLnRvSnNvbihucG0udXRpbHMuZ2V0U2FmZUNvbm5lY3Rpb24oY24pKSArIG5wbS51dGlscy50b0pzb24oZGIuJGRjKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7RGF0YWJhc2VQb29sfTtcclxuIl0sIm5hbWVzIjpbIkNvbG9yQ29uc29sZSIsInJlcXVpcmUiLCJucG0iLCJ1dGlscyIsIkRhdGFiYXNlUG9vbCIsImluc3RhbmNlIiwicyIsIlN5bWJvbCIsImZvciIsInNjb3BlIiwiZ2xvYmFsIiwiZGJNYXAiLCJkYnMiLCJyZWdpc3RlciIsImRiIiwiY25LZXkiLCJjcmVhdGVDb250ZXh0S2V5IiwiYWRkUmVhZFByb3AiLCIkY29uZmlnIiwib3B0aW9ucyIsIm5vV2FybmluZ3MiLCJ3YXJuIiwiZ2V0TG9jYWxTdGFjayIsInB1c2giLCJ1bnJlZ2lzdGVyIiwiJGNuS2V5Iiwic2h1dERvd24iLCJmb3JFYWNoIiwiJGRlc3Ryb3kiLCJsZW5ndGgiLCJjbiIsIiRjbiIsIm9iaiIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwibmFtZSIsInRvSnNvbiIsImdldFNhZmVDb25uZWN0aW9uIiwiJGRjIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/database-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/database.js":
/*!*************************************************!*\
  !*** ./node_modules/pg-promise/lib/database.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Events } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/pg-promise/lib/events.js\");\nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst { resultQuery, multiResultQuery, streamQuery } = __webpack_require__(/*! ./special-query */ \"(rsc)/./node_modules/pg-promise/lib/special-query.js\");\nconst { ConnectionContext } = __webpack_require__(/*! ./context */ \"(rsc)/./node_modules/pg-promise/lib/context.js\");\nconst { DatabasePool } = __webpack_require__(/*! ./database-pool */ \"(rsc)/./node_modules/pg-promise/lib/database-pool.js\");\nconst { queryResult } = __webpack_require__(/*! ./query-result */ \"(rsc)/./node_modules/pg-promise/lib/query-result.js\");\nconst npm = {\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    pubUtils: __webpack_require__(/*! ./utils/public */ \"(rsc)/./node_modules/pg-promise/lib/utils/public.js\"),\n    connect: __webpack_require__(/*! ./connect */ \"(rsc)/./node_modules/pg-promise/lib/connect.js\"),\n    query: __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/pg-promise/lib/query.js\"),\n    task: __webpack_require__(/*! ./task */ \"(rsc)/./node_modules/pg-promise/lib/task.js\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * Note however, that in special cases you may need to re-create the database object, if its connection pool has been\r\n * shut-down externally. And in this case the library won't be showing any warning.\r\n *\r\n * @param {string|object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * The value can be accessed from the database object via property {@link Database.$cn $cn}.\r\n *\r\n * @param {*} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations and event handling\r\n * that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol extensions,\r\n * or different implementations within a single task / transaction callback, depending on the database context.\r\n *\r\n * This parameter also adds uniqueness to the connection context that's used in combination with the connection\r\n * parameters, i.e. use of unique database context will prevent getting the warning about creating a duplicate\r\n * Database object.\r\n *\r\n * The value can be accessed from the database object via property {@link Database#$dc $dc}.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database#query query},\r\n * {@link Database#none none},\r\n * {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone},\r\n * {@link Database#many many},\r\n * {@link Database#manyOrNone manyOrNone},\r\n * {@link Database#any any},\r\n * {@link Database#func func},\r\n * {@link Database#proc proc},\r\n * {@link Database#result result},\r\n * {@link Database#multiResult multiResult},\r\n * {@link Database#multi multi},\r\n * {@link Database#map map},\r\n * {@link Database#each each},\r\n * {@link Database#stream stream},\r\n * {@link Database#task task},\r\n * {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx},\r\n * {@link Database#txIf txIf},\r\n * {@link Database#connect connect},\r\n * {@link Database#$config $config},\r\n * {@link Database#$cn $cn},\r\n * {@link Database#$dc $dc},\r\n * {@link Database#$pool $pool},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * const pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * const cn = 'postgres://username:password@host:port/database';\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * const db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */ function Database(cn, dc, config) {\n    const dbThis = this, $p = config.promise, poolConnection = typeof cn === \"string\" ? {\n        connectionString: cn\n    } : cn, pool = new config.pgp.pg.Pool(poolConnection), endMethod = pool.end;\n    let destroyed;\n    pool.end = (cb)=>{\n        const res = endMethod.call(pool, cb);\n        dbThis.$destroy();\n        return res;\n    };\n    pool.on(\"error\", onError);\n    /**\r\n     * @method Database#connect\r\n     *\r\n     * @description\r\n     * Acquires a new or existing connection, depending on the current state of the connection pool, and parameter `direct`.\r\n     *\r\n     * This method creates a shared connection for executing a chain of queries against it. The connection must be released\r\n     * in the end of the chain by calling `done()` on the connection object.\r\n     *\r\n     * Method `done` takes one optional parameter - boolean `kill` flag, to signal the connection pool that you want it to kill\r\n     * the physical connection. This flag is ignored for direct connections, as they always close when released.\r\n     *\r\n     * It should not be used just for chaining queries on the same connection, methods {@link Database#task task} and\r\n     * {@link Database#tx tx} (for transactions) are to be used for that. This method is primarily for special cases, like\r\n     * `LISTEN` notifications.\r\n     *\r\n     * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n     * you cannot call `client.end()` directly, or it will print an error into the console:\r\n     * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n     * You should only call method `done()` to release the connection.\r\n     *\r\n     * @param {object} [options]\r\n     * Connection Options.\r\n     *\r\n     * @param {boolean} [options.direct=false]\r\n     * Creates a new connection directly, as a stand-alone {@link external:Client Client} object, bypassing the connection pool.\r\n     *\r\n     * By default, all connections are acquired from the connection pool. But if you set this option, the library will instead\r\n     * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n     *\r\n     * Note that specifically for direct connections, method `done` returns a {@link external:Promise Promise}, because those connections\r\n     * are closed physically, which may take time.\r\n     *\r\n     * **WARNING:**\r\n     *\r\n     * Do not use this option for regular query execution, because it exclusively occupies one physical channel, and it cannot scale.\r\n     * This option is only suitable for global connection usage, such as event listeners.\r\n     *\r\n     * @param {function} [options.onLost]\r\n     * Notification callback of the lost/broken connection, called with the following parameters:\r\n     *  - `err` - the original connectivity error\r\n     *  - `e` - error context object, which contains:\r\n     *    - `cn` - safe connection string/config (with the password hashed);\r\n     *    - `dc` - Database Context, as was used during {@link Database} construction;\r\n     *    - `start` - Date/Time (`Date` type) when the connection was established;\r\n     *    - `client` - {@link external:Client Client} object that has lost the connection.\r\n     *\r\n     * The notification is mostly valuable with `direct: true`, to be able to re-connect direct/permanent connections by calling\r\n     * method {@link Database#connect connect} again.\r\n     *\r\n     * You do not need to call `done` on lost connections, as it happens automatically. However, if you had event listeners\r\n     * set up on the connection's `client` object, you should remove them to avoid leaks:\r\n     *\r\n     * ```js\r\n     * function onLostConnection(err, e) {\r\n     *     e.client.removeListener('my-event', myHandler);\r\n     * }\r\n     * ```\r\n     *\r\n     * For a complete example see $[Robust Listeners].\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the connection result:\r\n     *  - resolves with the complete {@link Database} protocol, extended with:\r\n     *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n     *    - method `done` that must be called in the end, in order to release the connection (returns a {@link external:Promise Promise}\r\n     *      in case of direct connections)\r\n     *    - methods `batch`, `page` and `sequence`, same as inside a {@link Task}\r\n     *  - rejects with a connection-related error when it fails to connect.\r\n     *\r\n     * @see\r\n     * {@link Database#task Database.task},\r\n     * {@link Database#taskIf Database.taskIf},\r\n     * {@link Database#tx Database.tx},\r\n     * {@link Database#txIf Database.txIf}\r\n     *\r\n     * @example\r\n     *\r\n     * let sco; // shared connection object;\r\n     *\r\n     * db.connect()\r\n     *     .then(obj => {\r\n     *         // obj.client = new connected Client object;\r\n     *\r\n     *         sco = obj; // save the connection object;\r\n     *\r\n     *         // execute all the queries you need:\r\n     *         return sco.any('SELECT * FROM Users');\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     })\r\n     *     .finally(() => {\r\n     *         // release the connection, if it was successful:\r\n     *         if (sco) {\r\n     *             // if you pass `true` into method done, i.e. done(true),\r\n     *             // it will make the pool kill the physical connection.\r\n     *             sco.done();\r\n     *         }\r\n     *     });\r\n     *\r\n     */ this.connect = function(options) {\n        options = options || {};\n        const ctx = createContext();\n        ctx.cnOptions = options;\n        const self = {\n            query (query, values, qrm) {\n                if (!ctx.db) {\n                    return $p.reject(new Error(npm.text.queryDisconnected));\n                }\n                return config.$npm.query.call(this, ctx, query, values, qrm);\n            },\n            done (kill) {\n                if (!ctx.db) {\n                    throw new Error(npm.text.looseQuery);\n                }\n                return ctx.disconnect(kill);\n            },\n            batch (values, opt) {\n                return config.$npm.spex.batch.call(this, values, opt);\n            },\n            page (source, opt) {\n                return config.$npm.spex.page.call(this, source, opt);\n            },\n            sequence (source, opt) {\n                return config.$npm.spex.sequence.call(this, source, opt);\n            }\n        };\n        const connection = options.direct ? config.$npm.connect.direct(ctx) : config.$npm.connect.pool(ctx, dbThis);\n        return connection.then((db)=>{\n            ctx.connect(db);\n            self.client = db.client;\n            extend(ctx, self);\n            return self;\n        });\n    };\n    /**\r\n     * @method Database#query\r\n     *\r\n     * @description\r\n     * Base query method that executes a generic query, expecting the return data according to parameter `qrm`.\r\n     *\r\n     * It performs the following steps:\r\n     *\r\n     *  1. Validates and formats the query via {@link formatting.format as.format}, according to the `query` and `values` passed in;\r\n     *  2. For a root-level query (against the {@link Database} object), it requests a new connection from the pool;\r\n     *  3. Executes the query;\r\n     *  4. For a root-level query (against the {@link Database} object), it releases the connection back to the pool;\r\n     *  5. Resolves/rejects, according to the data returned from the query and the value of `qrm`.\r\n     *\r\n     * Direct use of this method is not suitable for chaining queries, for performance reasons. It should be done\r\n     * through either task or transaction context, see $[Chaining Queries].\r\n     *\r\n     * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n     *\r\n     * @param {string|function|object} query\r\n     * Query to be executed, which can be any of the following types:\r\n     * - A non-empty query string\r\n     * - A function that returns a query string or another function, i.e. recursive resolution\r\n     *   is supported, passing in `values` as `this`, and as the first parameter.\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value|function} [values]\r\n     * Query formatting parameter(s), or a function that returns it.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any]\r\n     * {@link queryResult Query Result Mask}\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result according to `qrm`.\r\n     */ this.query = function(query, values, qrm) {\n        const self = this, ctx = createContext();\n        return config.$npm.connect.pool(ctx, dbThis).then((db)=>{\n            ctx.connect(db);\n            return config.$npm.query.call(self, ctx, query, values, qrm);\n        }).then((data)=>{\n            ctx.disconnect();\n            return data;\n        }).catch((error)=>{\n            ctx.disconnect();\n            return $p.reject(error);\n        });\n    };\n    /**\r\n     * @member {object} Database#$config\r\n     * @readonly\r\n     * @description\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * Properties available in the object:\r\n     * - `pgp` - instance of the entire library after initialization\r\n     * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n     * - `promiseLib` - instance of the promise library that's used\r\n     * - `promise` - generic promise interface that uses `promiseLib` via 4 basic methods:\r\n     *   - `promise((resolve, reject) => {})` - to create a new promise\r\n     *   - `promise.resolve(value)` - to resolve with a value\r\n     *   - `promise.reject(reason)` - to reject with a reason\r\n     *   - `promise.all(iterable)` - to resolve an iterable list of promises\r\n     * - `version` - this library's version\r\n     * - `$npm` _(hidden property)_ - internal module cache\r\n     *\r\n     * @example\r\n     *\r\n     * // Using the promise protocol as configured by pg-promise:\r\n     *\r\n     * const $p = db.$config.promise;\r\n     *\r\n     * const resolvedPromise = $p.resolve('some data');\r\n     * const rejectedPromise = $p.reject('some reason');\r\n     *\r\n     * const newPromise = $p((resolve, reject) => {\r\n     *     // call either resolve(data) or reject(reason) here\r\n     * });\r\n     */ npm.utils.addReadProp(this, \"$config\", config, true);\n    /**\r\n     * @member {string|object} Database#$cn\r\n     * @readonly\r\n     * @description\r\n     * Database connection, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */ npm.utils.addReadProp(this, \"$cn\", cn, true);\n    /**\r\n     * @member {*} Database#$dc\r\n     * @readonly\r\n     * @description\r\n     * Database Context, as was passed in during the object's construction.\r\n     *\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * @see Database\r\n     */ npm.utils.addReadProp(this, \"$dc\", dc, true);\n    /**\r\n     * @member {external:pg-pool} Database#$pool\r\n     * @readonly\r\n     * @description\r\n     * A $[pg-pool] object associated with the database object, as each {@link Database} creates its own $[pg-pool] instance.\r\n     *\r\n     * This is a hidden property, primarily for integrating type {@link Database} with third-party libraries that support\r\n     * $[pg-pool] directly. Note however, that if you pass the pool object into a library that calls `pool.end()`, you will no longer be able\r\n     * to use this {@link Database} object, and each query method will be rejecting with {@link external:Error Error} =\r\n     * `Connection pool of the database object has been destroyed.`\r\n     *\r\n     * You can also use this object to shut down the pool, by calling `$pool.end()`.\r\n     *\r\n     * For more details see $[Library de-initialization].\r\n     *\r\n     * @see\r\n     * {@link Database}\r\n     * {@link module:pg-promise~end pgp.end}\r\n     *\r\n     * @example\r\n     *\r\n     * // Shutting down the connection pool of this database object,\r\n     * // after all queries have finished in a run-though process:\r\n     *\r\n     * .then(() => {}) // processing the data\r\n     * .catch() => {}) // handling the error\r\n     * .finally(db.$pool.end); // shutting down the pool\r\n     *\r\n     */ npm.utils.addReadProp(this, \"$pool\", pool, true);\n    /**\r\n     * @member {function} Database.$destroy\r\n     * @readonly\r\n     * @private\r\n     * @description\r\n     * Permanently shuts down the database object.\r\n     */ npm.utils.addReadProp(this, \"$destroy\", ()=>{\n        if (!destroyed) {\n            if (!pool.ending) {\n                endMethod.call(pool);\n            }\n            DatabasePool.unregister(dbThis);\n            pool.removeListener(\"error\", onError);\n            destroyed = true;\n        }\n    }, true);\n    DatabasePool.register(this);\n    extend(createContext(), this); // extending root protocol;\n    function createContext() {\n        return new ConnectionContext({\n            cn,\n            dc,\n            options: config.options\n        });\n    }\n    // Optional value-transformation helper:\n    function transform(value, cb, thisArg) {\n        return typeof cb === \"function\" ? value.then((data)=>cb.call(thisArg, data)) : value;\n    }\n    ////////////////////////////////////////////////////\n    // Injects additional methods into an access object,\n    // extending the protocol's base method 'query'.\n    function extend(ctx, obj) {\n        /**\r\n         * @method Database#none\r\n         * @description\r\n         * Executes a query that expects no data to be returned. If the query returns any data,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<null>}\r\n         * A promise object that represents the query result:\r\n         * - When no records are returned, it resolves with `null`.\r\n         * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No return data was expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n         */ obj.none = function(query, values) {\n            return obj.query.call(this, query, values, queryResult.none);\n        };\n        /**\r\n         * @method Database#one\r\n         * @description\r\n         * Executes a query that expects exactly 1 row to be returned. When 0 or more than 1 rows are returned,\r\n         * the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#oneOrNone oneOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n         *     .then(data => {\r\n         *         // data = a new event id, rather than an object with it\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation + conversion:\r\n         * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n         *     .then(count => {\r\n         *         // count = a proper integer value, rather than an object with a string\r\n         *     });\r\n         *\r\n         */ obj.one = function(query, values, cb, thisArg) {\n            const v = obj.query.call(this, query, values, queryResult.one);\n            return transform(v, cb, thisArg);\n        };\n        /**\r\n         * @method Database#many\r\n         * @description\r\n         * Executes a query that expects one or more rows to be returned. When the query returns no rows, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         */ obj.many = function(query, values) {\n            return obj.query.call(this, query, values, queryResult.many);\n        };\n        /**\r\n         * @method Database#oneOrNone\r\n         * @description\r\n         * Executes a query that expects 0 or 1 rows to be returned. It resolves with the row-object when 1 row is returned,\r\n         * or with `null` when nothing is returned. When the query returns more than 1 row, the method rejects.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with `null`.\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         * - Resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @see\r\n         * {@link Database#one one},\r\n         * {@link Database#none none},\r\n         * {@link Database#manyOrNone manyOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n         *     .then(data => {\r\n         *         // data = the event id or null (rather than object or null)\r\n         *     });\r\n         *\r\n         */ obj.oneOrNone = function(query, values, cb, thisArg) {\n            const v = obj.query.call(this, query, values, queryResult.one | queryResult.none);\n            return transform(v, cb, thisArg);\n        };\n        /**\r\n         * @method Database#manyOrNone\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#many many},\r\n         * {@link Database#none none}\r\n         *\r\n         */ obj.manyOrNone = function(query, values) {\n            return obj.query.call(this, query, values, queryResult.many | queryResult.none);\n        };\n        /**\r\n         * @method Database#any\r\n         * @description\r\n         * Executes a query that can return any number of rows.\r\n         * This is simply a shorter alias for method {@link Database#manyOrNone manyOrNone}.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#manyOrNone manyOrNone},\r\n         * {@link Database#map map},\r\n         * {@link Database#each each}\r\n         *\r\n         */ obj.any = function(query, values) {\n            return obj.query.call(this, query, values, queryResult.any);\n        };\n        /**\r\n         * @method Database#result\r\n         * @description\r\n         * Executes a query without any expectation for the return data, and resolves with the\r\n         * original $[Result] object when successful.\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - resolves with the original $[Result] object (by default);\r\n         * - resolves with the new value, if transformation callback `cb` was specified.\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // deleting rows and returning the number of rows deleted\r\n         * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n         *     .then(data => {\r\n         *         // data = number of rows that were deleted\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // getting only column details from a table\r\n         * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n         *     .then(data => {\r\n         *         // data = array of column descriptors\r\n         *     });\r\n         *\r\n         */ obj.result = function(query, values, cb, thisArg) {\n            const v = obj.query.call(this, query, values, resultQuery);\n            return transform(v, cb, thisArg);\n        };\n        /**\r\n         * @method Database#multiResult\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of the original $[Result] objects when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<external:Result[]>}\r\n         *\r\n         * @see {@link Database#multi multi}\r\n         *\r\n         */ obj.multiResult = function(query, values) {\n            return obj.query.call(this, query, values, multiResultQuery);\n        };\n        /**\r\n         * @method Database#multi\r\n         * @description\r\n         * Executes a multi-query string, without any expectation for the return data, and resolves with an array\r\n         * of arrays of rows when successful.\r\n         *\r\n         * The operation is atomic, i.e. all queries are executed in a single transaction, unless there are explicit\r\n         * `BEGIN/COMMIT` commands included in the query string to divide it into multiple transactions.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Multi-query string to be executed, which can be any of the following types:\r\n         * - A non-empty string that can contain any number of queries\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise<Array<Array>>}\r\n         *\r\n         * @see {@link Database#multiResult multiResult}\r\n         *\r\n         * @example\r\n         *\r\n         * // Get data from 2 tables in a single request:\r\n         * const [users, products] = await db.multi('SELECT * FROM users;SELECT * FROM products');\r\n         *\r\n         */ obj.multi = function(query, values) {\n            return obj.query.call(this, query, values, multiResultQuery).then((data)=>data.map((a)=>a.rows));\n        };\n        /**\r\n         * @method Database#stream\r\n         * @description\r\n         * Custom data streaming, with the help of $[pg-query-stream].\r\n         *\r\n         * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n         * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n         *\r\n         * @param {QueryStream} qs\r\n         * Stream object of type $[QueryStream].\r\n         *\r\n         * @param {Database.streamInitCB} initCB\r\n         * Stream initialization callback.\r\n         *\r\n         * It is invoked with the same `this` context as the calling method.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Result of the streaming operation.\r\n         *\r\n         * Once the streaming has finished successfully, the method resolves with\r\n         * `{processed, duration}`:\r\n         * - `processed` - total number of rows processed;\r\n         * - `duration` - streaming duration, in milliseconds.\r\n         *\r\n         * Possible rejections messages:\r\n         * - `Invalid or missing stream object.`\r\n         * - `Invalid stream state.`\r\n         * - `Invalid or missing stream initialization callback.`\r\n         */ obj.stream = function(qs, init) {\n            return obj.query.call(this, qs, init, streamQuery);\n        };\n        /**\r\n         * @method Database#func\r\n         * @description\r\n         * Executes a database function that returns a table, abbreviating the full syntax\r\n         * of `query('SELECT * FROM $1:alias($2:csv)', [funcName, values], qrm)`.\r\n         *\r\n         * @param {string} funcName\r\n         * Name of the function to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n         * which also supports `.`, to auto-split into a composite name.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the function - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object as returned from method {@link Database#query query}, according to parameter `qrm`.\r\n         *\r\n         * @see\r\n         * {@link Database#query query},\r\n         * {@link Database#proc proc}\r\n         */ obj.func = function(funcName, values, qrm) {\n            return obj.query.call(this, {\n                entity: funcName,\n                type: \"func\"\n            }, values, qrm);\n        };\n        /**\r\n         * @method Database#proc\r\n         * @description\r\n         * Executes a stored procedure by name, abbreviating the full syntax of\r\n         * `oneOrNone('CALL $1:alias($2:csv)', [procName, values], cb, thisArg)`.\r\n         *\r\n         * **NOTE:** This method uses the new `CALL` syntax that requires PostgreSQL v11 or later.\r\n         *\r\n         * @param {string} procName\r\n         * Name of the stored procedure to be executed.\r\n         * When it is not same-case, or contains extended symbols, it is double-quoted, as per the `:alias` filter,\r\n         * which also supports `.`, to auto-split into a composite SQL name.\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Parameters for the procedure - one value | array of values | function returning value(s).\r\n         *\r\n         * @param {function} [cb]\r\n         * Value-transformation callback, to allow in-line value change.\r\n         * When specified, the returned value replaces the original one.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * When the procedure takes output parameters, a single object is returned, with\r\n         * properties for the output values. Otherwise, the method resolves with `null`.\r\n         * And if the value-transformation callback is provided, it overrides the result.\r\n         *\r\n         * @see\r\n         * {@link Database#func func}\r\n         */ obj.proc = function(procName, values, cb, thisArg) {\n            const v = obj.query.call(this, {\n                entity: procName,\n                type: \"proc\"\n            }, values, queryResult.one | queryResult.none);\n            return transform(v, cb, thisArg);\n        };\n        /**\r\n         * @method Database#map\r\n         * @description\r\n         * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n         * resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method, to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         return data.map((row, index, data) => {\r\n         *              // return a new element\r\n         *         });\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} values\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function that produces an element of the new array, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the original array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array>}\r\n         * Resolves with the new array of values returned from the callback.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#each each},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n         *\r\n         * @example\r\n         *\r\n         * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n         *     .then(data => {\r\n         *         // data = array of active user id-s\r\n         *     })\r\n         *     .catch(error => {\r\n         *        // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n         *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // Build a list of active users, each with the list of user events:\r\n         * db.task(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n         *             .then(events=> {\r\n         *                 user.events = events;\r\n         *                 return user;\r\n         *             });\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */ obj.map = function(query, values, cb, thisArg) {\n            return obj.any.call(this, query, values).then((data)=>data.map(cb, thisArg));\n        };\n        /**\r\n         * @method Database#each\r\n         * @description\r\n         * Executes a provided function once per array element, for an array of rows resolved by method {@link Database#any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         data.forEach((row, index, data) => {\r\n         *              // process the row\r\n         *         });\r\n         *         return data;\r\n         *     });\r\n         * ```\r\n         *\r\n         * When receiving a multi-query result, only the last result is processed, ignoring the rest.\r\n         *\r\n         * @param {string|function|object} query\r\n         * Query to be executed, which can be any of the following types:\r\n         * - A non-empty query string\r\n         * - A function that returns a query string or another function, i.e. recursive resolution\r\n         *   is supported, passing in `values` as `this`, and as the first parameter.\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value|function} [values]\r\n         * Query formatting parameter(s), or a function that returns it.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function to execute for each row, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the array of rows resolved by method {@link Database#any any}\r\n         *\r\n         * @param {*} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise<Array<Object>>}\r\n         * Resolves with the original array of rows.\r\n         *\r\n         * @see\r\n         * {@link Database#any any},\r\n         * {@link Database#map map},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n         *\r\n         * @example\r\n         *\r\n         * db.each('SELECT id, code, name FROM Events', [], row => {\r\n         *     row.code = parseInt(row.code);\r\n         * })\r\n         *     .then(data => {\r\n         *         // data = array of events, with 'code' converted into integer\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */ obj.each = function(query, values, cb, thisArg) {\n            return obj.any.call(this, query, values).then((data)=>{\n                data.forEach(cb, thisArg);\n                return data;\n            });\n        };\n        /**\r\n         * @method Database#task\r\n         * @description\r\n         * Executes a callback function with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * This method should be used whenever executing more than one query at once, so the allocated connection\r\n         * is reused between all queries, and released only after the task has finished (see $[Chaining Queries]).\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the task context object. See class {@link Task} for more details.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task (see $[tags]).\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#taskIf taskIf},\r\n         * {@link Database#tx tx},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.task('my-task', t => {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n         *             .then(user => {\r\n         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.task('my-task', async t {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         const user = await t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */ obj.task = function() {\n            const args = npm.pubUtils.taskArgs(arguments);\n            assert(args.options, [\n                \"tag\"\n            ]);\n            return taskProcessor.call(this, args, false);\n        };\n        /**\r\n         * @method Database#taskIf\r\n         * @description\r\n         * Executes a conditional task that results in an actual new {@link Database#task task}, if either condition is met or\r\n         * when it is necessary (on the top level), or else it reuses the current connection context.\r\n         *\r\n         * The default condition is `not in task or transaction`, to start a task only if currently not inside another task or transaction,\r\n         * which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.taskIf({cnd: t => !t.ctx}, cb => {})\r\n         * ```\r\n         *\r\n         * It can be useful, if you want to simplify/reduce the task + log events footprint, by creating new tasks only when necessary.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for creating a ({@link Database#task task}), if it is met.\r\n         * It can be either a simple boolean, or a callback function that takes the task context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx}\r\n         * ```\r\n         *\r\n         * @param {function} cb\r\n         * Task callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link Database#txIf Database.txIf},\r\n         * {@link TaskContext}\r\n         *\r\n         */ obj.taskIf = function() {\n            const args = npm.pubUtils.taskArgs(arguments);\n            assert(args.options, [\n                \"tag\",\n                \"cnd\"\n            ]);\n            try {\n                let cnd = args.options.cnd;\n                if (\"cnd\" in args.options) {\n                    cnd = typeof cnd === \"function\" ? cnd.call(obj, obj) : !!cnd;\n                } else {\n                    cnd = !obj.ctx; // create task, if it is the top level\n                }\n                // reusable only if condition fails, and not top-level:\n                args.options.reusable = !cnd && !!obj.ctx;\n            } catch (e) {\n                return $p.reject(e);\n            }\n            return taskProcessor.call(this, args, false);\n        };\n        /**\r\n         * @method Database#tx\r\n         * @description\r\n         * Executes a callback function as a transaction, with automatically managed connection.\r\n         *\r\n         * When invoked on the root {@link Database} object, the method allocates the connection from the pool,\r\n         * executes the callback, and once finished - releases the connection back to the pool.\r\n         * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n         *\r\n         * A transaction wraps a regular {@link Database#task task} into additional queries:\r\n         * - it executes `BEGIN` just before invoking the callback function\r\n         * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n         * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n         * - it executes corresponding `SAVEPOINT` commands when the method is called recursively.\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task#batch batch}, {@link Task#page page}, {@link Task#sequence sequence}, plus property {@link Task#ctx ctx} -\r\n         * the transaction context object. See class {@link Task} for more details.\r\n         *\r\n         * Note that transactions should be chosen over tasks only where necessary, because unlike regular tasks,\r\n         * transactions are blocking operations.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction callback function, to return the result that will determine either success or failure for the operation.\r\n         *\r\n         * The function can be either the first of the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link TaskContext},\r\n         * $[tags],\r\n         * $[Chaining Queries]\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx('my-transaction', t => {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n         *             .then(user => {\r\n         *                 return t.batch([\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n         *                 ]);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES7 syntax for the callback:\r\n         * db.tx('my-transaction', async t {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         const user = await t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n         *         return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */ obj.tx = function() {\n            const args = npm.pubUtils.taskArgs(arguments);\n            assert(args.options, [\n                \"tag\",\n                \"mode\"\n            ]);\n            return taskProcessor.call(this, args, true);\n        };\n        /**\r\n         * @method Database#txIf\r\n         * @description\r\n         * Executes a conditional transaction that results in an actual transaction ({@link Database#tx tx}), if the condition is met,\r\n         * or else it executes a regular {@link Database#task task}.\r\n         *\r\n         * The default condition is `not in transaction`, to start a transaction only if currently not in transaction,\r\n         * or else start a task, which is the same as calling the following:\r\n         *\r\n         * ```js\r\n         * db.txIf({cnd: t => !t.ctx || !t.ctx.inTransaction}, cb => {})\r\n         * ```\r\n         *\r\n         * It is useful when you want to avoid $[Nested Transactions] - savepoints.\r\n         *\r\n         * @param {string|number|Object} [options]\r\n         * This parameter is optional, and presumed skipped when the first parameter is a function (`cb` parameter).\r\n         *\r\n         * When it is of type `string` or `number`, it is assumed to be option `tag` passed in directly. Otherwise,\r\n         * it is expected to be an object with options as listed below.\r\n         *\r\n         * @param {} [options.tag]\r\n         * Traceable context for the task/transaction (see $[tags]).\r\n         *\r\n         * @param {txMode.TransactionMode} [options.mode]\r\n         * Transaction Configuration Mode - extends the transaction-opening command with additional configuration.\r\n         *\r\n         * @param {boolean|function} [options.cnd]\r\n         * Condition for opening a transaction ({@link Database#tx tx}), if it is met, or a {@link Database#task task} when the condition is not met.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this` and as the first parameter.\r\n         *\r\n         * Default condition (when it is not specified):\r\n         *\r\n         * ```js\r\n         * {cnd: t => !t.ctx || !t.ctx.inTransaction}\r\n         * ```\r\n         *\r\n         * @param {boolean|function} [options.reusable=false]\r\n         * When `cnd` is/returns false, reuse context of the current task/transaction, if one exists.\r\n         * It can be either a simple boolean, or a callback function that takes the task/tx context as `this`\r\n         * and as the first parameter.\r\n         *\r\n         * By default, when `cnd` is/returns false, the method creates a new task. This option tells\r\n         * the method to reuse the current task/transaction context, and not create a new task.\r\n         *\r\n         * This option is ignored when executing against the top level of the protocol, because on\r\n         * that level, if no transaction is suddenly needed, a new task becomes necessary.\r\n         *\r\n         * @param {function} cb\r\n         * Transaction/task callback function, to return the result that will determine either\r\n         * success or failure for the operation.\r\n         *\r\n         * The function can be either the first or the second parameter passed into the method.\r\n         *\r\n         * It also can be an ES7 `async` function.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object with the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database#task Database.task},\r\n         * {@link Database#taskIf Database.taskIf},\r\n         * {@link Database#tx Database.tx},\r\n         * {@link TaskContext}\r\n         */ obj.txIf = function() {\n            const args = npm.pubUtils.taskArgs(arguments);\n            assert(args.options, [\n                \"tag\",\n                \"mode\",\n                \"cnd\",\n                \"reusable\"\n            ]);\n            try {\n                let cnd;\n                if (\"cnd\" in args.options) {\n                    cnd = args.options.cnd;\n                    cnd = typeof cnd === \"function\" ? cnd.call(obj, obj) : !!cnd;\n                } else {\n                    cnd = !obj.ctx || !obj.ctx.inTransaction;\n                }\n                args.options.cnd = cnd;\n                const reusable = args.options.reusable;\n                args.options.reusable = !cnd && obj.ctx && typeof reusable === \"function\" ? reusable.call(obj, obj) : !!reusable;\n            } catch (e) {\n                return $p.reject(e);\n            }\n            return taskProcessor.call(this, args, args.options.cnd);\n        };\n        // Task method;\n        // Resolves with result from the callback function;\n        function taskProcessor(params, isTX) {\n            if (typeof params.cb !== \"function\") {\n                return $p.reject(new TypeError(\"Callback function is required.\"));\n            }\n            if (params.options.reusable) {\n                return config.$npm.task.callback(obj.ctx, obj, params.cb, config);\n            }\n            const taskCtx = ctx.clone(); // task context object;\n            if (isTX) {\n                taskCtx.txLevel = taskCtx.txLevel >= 0 ? taskCtx.txLevel + 1 : 0;\n            }\n            taskCtx.inTransaction = taskCtx.txLevel >= 0;\n            taskCtx.level = taskCtx.level >= 0 ? taskCtx.level + 1 : 0;\n            taskCtx.cb = params.cb; // callback function;\n            taskCtx.mode = params.options.mode; // transaction mode;\n            if (this !== obj) {\n                taskCtx.context = this; // calling context object;\n            }\n            const tsk = new config.$npm.task.Task(taskCtx, params.options.tag, isTX, config);\n            taskCtx.taskCtx = tsk.ctx;\n            extend(taskCtx, tsk);\n            if (taskCtx.db) {\n                // reuse existing connection;\n                npm.utils.addReadProp(tsk.ctx, \"useCount\", taskCtx.db.useCount);\n                addServerVersion(tsk.ctx, taskCtx.db.client);\n                return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n            }\n            // connection required;\n            return config.$npm.connect.pool(taskCtx, dbThis).then((db)=>{\n                taskCtx.connect(db);\n                npm.utils.addReadProp(tsk.ctx, \"useCount\", db.useCount);\n                addServerVersion(tsk.ctx, db.client);\n                return config.$npm.task.execute(taskCtx, tsk, isTX, config);\n            }).then((data)=>{\n                taskCtx.disconnect();\n                return data;\n            }).catch((error)=>{\n                taskCtx.disconnect();\n                return $p.reject(error);\n            });\n        }\n        function addServerVersion(target, client) {\n            // Exclude else-case from coverage, because it can only occur with Native Bindings.\n            // istanbul ignore else\n            if (client.serverVersion) {\n                npm.utils.addReadProp(target, \"serverVersion\", client.serverVersion);\n            }\n        }\n        // extending the protocol;\n        Events.extend(ctx.options, obj, ctx.dc);\n    }\n}\n// this event only happens when the connection is lost physically,\n// which cannot be tested automatically; removing from coverage:\n// istanbul ignore next\nfunction onError(err) {\n    // this client was never seen by pg-promise, which\n    // can happen if it failed to initialize\n    if (!err.client.$ctx) {\n        return;\n    }\n    const ctx = err.client.$ctx;\n    Events.error(ctx.options, err, {\n        cn: npm.utils.getSafeConnection(ctx.cn),\n        dc: ctx.dc\n    });\n}\nmodule.exports = (config)=>{\n    const npmLocal = config.$npm;\n    npmLocal.connect = npmLocal.connect || npm.connect(config);\n    npmLocal.query = npmLocal.query || npm.query(config);\n    npmLocal.task = npmLocal.task || npm.task(config);\n    return Database;\n}; /**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database#stream Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * const QueryStream = require('pg-query-stream');\r\n * const JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * const qs = new QueryStream('SELECT * FROM users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log('Total rows processed:', data.processed,\r\n *           'Duration in milliseconds:', data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */  /**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */  /**\r\n * @external pg-pool\r\n * @alias pg-pool\r\n * @see https://github.com/brianc/node-pg-pool\r\n */  /**\r\n * @external Result\r\n * @see https://node-postgres.com/api/result\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZGF0YWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsTUFBTSxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBQ0MsTUFBTSxFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBQ0UsV0FBVyxFQUFFQyxnQkFBZ0IsRUFBRUMsV0FBVyxFQUFDLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzdELE1BQU0sRUFBQ0ssaUJBQWlCLEVBQUMsR0FBR0wsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFDTSxZQUFZLEVBQUMsR0FBR04sbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFDTyxXQUFXLEVBQUMsR0FBR1AsbUJBQU9BLENBQUM7QUFFOUIsTUFBTVEsTUFBTTtJQUNSQyxPQUFPVCxtQkFBT0EsQ0FBQztJQUNmVSxVQUFVVixtQkFBT0EsQ0FBQztJQUNsQlcsU0FBU1gsbUJBQU9BLENBQUM7SUFDakJZLE9BQU9aLG1CQUFPQSxDQUFDO0lBQ2ZhLE1BQU1iLG1CQUFPQSxDQUFDO0lBQ2RjLE1BQU1kLG1CQUFPQSxDQUFDO0FBQ2xCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0ZDLEdBQ0QsU0FBU2UsU0FBU0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07SUFFNUIsTUFBTUMsU0FBUyxJQUFJLEVBQ2ZDLEtBQUtGLE9BQU9HLE9BQU8sRUFDbkJDLGlCQUFpQixPQUFPTixPQUFPLFdBQVc7UUFBQ08sa0JBQWtCUDtJQUFFLElBQUlBLElBQ25FUSxPQUFPLElBQUlOLE9BQU9PLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDQyxJQUFJLENBQUNMLGlCQUM5Qk0sWUFBWUosS0FBS0ssR0FBRztJQUV4QixJ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O0lBQ3hDLElBQUksQ0FBQ0EsSUFBSW5FLE1BQU0sQ0FBQ29FLElBQUksRUFBRTtRQUNsQjtJQUNKO0lBQ0EsTUFBTTVGLE1BQU0yRixJQUFJbkUsTUFBTSxDQUFDb0UsSUFBSTtJQUMzQm5JLE9BQU9tRSxLQUFLLENBQUM1QixJQUFJRCxPQUFPLEVBQUU0RixLQUFLO1FBQzNCakgsSUFBSVIsSUFBSUMsS0FBSyxDQUFDMEgsaUJBQWlCLENBQUM3RixJQUFJdEIsRUFBRTtRQUN0Q0MsSUFBSXFCLElBQUlyQixFQUFFO0lBQ2Q7QUFDSjtBQUVBbUgsT0FBT0MsT0FBTyxHQUFHbkgsQ0FBQUE7SUFDYixNQUFNb0gsV0FBV3BILE9BQU84QixJQUFJO0lBQzVCc0YsU0FBUzNILE9BQU8sR0FBRzJILFNBQVMzSCxPQUFPLElBQUlILElBQUlHLE9BQU8sQ0FBQ087SUFDbkRvSCxTQUFTMUgsS0FBSyxHQUFHMEgsU0FBUzFILEtBQUssSUFBSUosSUFBSUksS0FBSyxDQUFDTTtJQUM3Q29ILFNBQVN6SCxJQUFJLEdBQUd5SCxTQUFTekgsSUFBSSxJQUFJTCxJQUFJSyxJQUFJLENBQUNLO0lBQzFDLE9BQU9IO0FBQ1gsR0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLElBRUQ7OztDQUdDLElBRUQ7Ozs7Q0FJQyxJQUVEOzs7Q0FHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2RhdGFiYXNlLmpzP2E4NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtFdmVudHN9ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuY29uc3Qge2Fzc2VydH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xyXG5jb25zdCB7cmVzdWx0UXVlcnksIG11bHRpUmVzdWx0UXVlcnksIHN0cmVhbVF1ZXJ5fSA9IHJlcXVpcmUoJy4vc3BlY2lhbC1xdWVyeScpO1xyXG5jb25zdCB7Q29ubmVjdGlvbkNvbnRleHR9ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XHJcbmNvbnN0IHtEYXRhYmFzZVBvb2x9ID0gcmVxdWlyZSgnLi9kYXRhYmFzZS1wb29sJyk7XHJcbmNvbnN0IHtxdWVyeVJlc3VsdH0gPSByZXF1aXJlKCcuL3F1ZXJ5LXJlc3VsdCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMnKSxcclxuICAgIHB1YlV0aWxzOiByZXF1aXJlKCcuL3V0aWxzL3B1YmxpYycpLFxyXG4gICAgY29ubmVjdDogcmVxdWlyZSgnLi9jb25uZWN0JyksXHJcbiAgICBxdWVyeTogcmVxdWlyZSgnLi9xdWVyeScpLFxyXG4gICAgdGFzazogcmVxdWlyZSgnLi90YXNrJyksXHJcbiAgICB0ZXh0OiByZXF1aXJlKCcuL3RleHQnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBEYXRhYmFzZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgcHJvdG9jb2wsIGV4dGVuc2libGUgdmlhIGV2ZW50IHtAbGluayBldmVudDpleHRlbmQgZXh0ZW5kfS5cclxuICogVGhpcyB0eXBlIGlzIG5vdCBhdmFpbGFibGUgZGlyZWN0bHksIGl0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgdmlhIHRoZSBsaWJyYXJ5J3MgYmFzZSBjYWxsLlxyXG4gKlxyXG4gKiAqKklNUE9SVEFOVDoqKlxyXG4gKlxyXG4gKiBGb3IgYW55IGdpdmVuIGNvbm5lY3Rpb24sIHlvdSBzaG91bGQgb25seSBjcmVhdGUgYSBzaW5nbGUge0BsaW5rIERhdGFiYXNlfSBvYmplY3QgaW4gYSBzZXBhcmF0ZSBtb2R1bGUsXHJcbiAqIHRvIGJlIHNoYXJlZCBpbiB5b3VyIGFwcGxpY2F0aW9uIChzZWUgdGhlIGNvZGUgZXhhbXBsZSBiZWxvdykuIElmIGluc3RlYWQgeW91IGtlZXAgY3JlYXRpbmcgdGhlIHtAbGluayBEYXRhYmFzZX1cclxuICogb2JqZWN0IGR5bmFtaWNhbGx5LCB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgc3VmZmVyIGZyb20gbG9zcyBpbiBwZXJmb3JtYW5jZSwgYW5kIHdpbGwgYmUgZ2V0dGluZyBhIHdhcm5pbmcgaW4gYVxyXG4gKiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCAod2hlbiBgTk9ERV9FTlZgID0gYGRldmVsb3BtZW50YCk6XHJcbiAqXHJcbiAqIGBXQVJOSU5HOiBDcmVhdGluZyBhIGR1cGxpY2F0ZSBkYXRhYmFzZSBvYmplY3QgZm9yIHRoZSBzYW1lIGNvbm5lY3Rpb24uYFxyXG4gKlxyXG4gKiBJZiB5b3UgZXZlciBzZWUgdGhpcyB3YXJuaW5nLCByZWN0aWZ5IHlvdXIge0BsaW5rIERhdGFiYXNlfSBvYmplY3QgaW5pdGlhbGl6YXRpb24sIHNvIHRoZXJlIGlzIG9ubHkgb25lIG9iamVjdFxyXG4gKiBwZXIgY29ubmVjdGlvbiBkZXRhaWxzLiBTZWUgdGhlIGV4YW1wbGUgcHJvdmlkZWQgYmVsb3cuXHJcbiAqXHJcbiAqIFNlZSBhbHNvOiBwcm9wZXJ0eSBgbm9XYXJuaW5nc2AgaW4ge0BsaW5rIG1vZHVsZTpwZy1wcm9taXNlIEluaXRpYWxpemF0aW9uIE9wdGlvbnN9LlxyXG4gKlxyXG4gKiBOb3RlIGhvd2V2ZXIsIHRoYXQgaW4gc3BlY2lhbCBjYXNlcyB5b3UgbWF5IG5lZWQgdG8gcmUtY3JlYXRlIHRoZSBkYXRhYmFzZSBvYmplY3QsIGlmIGl0cyBjb25uZWN0aW9uIHBvb2wgaGFzIGJlZW5cclxuICogc2h1dC1kb3duIGV4dGVybmFsbHkuIEFuZCBpbiB0aGlzIGNhc2UgdGhlIGxpYnJhcnkgd29uJ3QgYmUgc2hvd2luZyBhbnkgd2FybmluZy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjblxyXG4gKiBEYXRhYmFzZSBjb25uZWN0aW9uIGRldGFpbHMsIHdoaWNoIGNhbiBiZTpcclxuICpcclxuICogLSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqIC0gYSBjb25uZWN0aW9uIHN0cmluZ1xyXG4gKlxyXG4gKiBGb3IgZGV0YWlscyBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbHktdC9wZy1wcm9taXNlL3dpa2kvQ29ubmVjdGlvbi1TeW50YXggQ29ubmVjdGlvbiBTeW50YXh9LlxyXG4gKlxyXG4gKiBUaGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIGRhdGFiYXNlIG9iamVjdCB2aWEgcHJvcGVydHkge0BsaW5rIERhdGFiYXNlLiRjbiAkY259LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IFtkY11cclxuICogRGF0YWJhc2UgQ29udGV4dC5cclxuICpcclxuICogQW55IG9iamVjdCBvciB2YWx1ZSB0byBiZSBwcm9wYWdhdGVkIHRocm91Z2ggdGhlIHByb3RvY29sLCB0byBhbGxvdyBpbXBsZW1lbnRhdGlvbnMgYW5kIGV2ZW50IGhhbmRsaW5nXHJcbiAqIHRoYXQgZGVwZW5kIG9uIHRoZSBkYXRhYmFzZSBjb250ZXh0LlxyXG4gKlxyXG4gKiBUaGlzIGlzIG1haW5seSB0byBmYWNpbGl0YXRlIHRoZSB1c2Ugb2YgbXVsdGlwbGUgZGF0YWJhc2VzIHdoaWNoIG1heSBuZWVkIHNlcGFyYXRlIHByb3RvY29sIGV4dGVuc2lvbnMsXHJcbiAqIG9yIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgd2l0aGluIGEgc2luZ2xlIHRhc2sgLyB0cmFuc2FjdGlvbiBjYWxsYmFjaywgZGVwZW5kaW5nIG9uIHRoZSBkYXRhYmFzZSBjb250ZXh0LlxyXG4gKlxyXG4gKiBUaGlzIHBhcmFtZXRlciBhbHNvIGFkZHMgdW5pcXVlbmVzcyB0byB0aGUgY29ubmVjdGlvbiBjb250ZXh0IHRoYXQncyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIGNvbm5lY3Rpb25cclxuICogcGFyYW1ldGVycywgaS5lLiB1c2Ugb2YgdW5pcXVlIGRhdGFiYXNlIGNvbnRleHQgd2lsbCBwcmV2ZW50IGdldHRpbmcgdGhlIHdhcm5pbmcgYWJvdXQgY3JlYXRpbmcgYSBkdXBsaWNhdGVcclxuICogRGF0YWJhc2Ugb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIGRhdGFiYXNlIG9iamVjdCB2aWEgcHJvcGVydHkge0BsaW5rIERhdGFiYXNlIyRkYyAkZGN9LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RGF0YWJhc2V9XHJcbiAqXHJcbiAqIEBzZWVcclxuICpcclxuICoge0BsaW5rIERhdGFiYXNlI3F1ZXJ5IHF1ZXJ5fSxcclxuICoge0BsaW5rIERhdGFiYXNlI25vbmUgbm9uZX0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNvbmUgb25lfSxcclxuICoge0BsaW5rIERhdGFiYXNlI29uZU9yTm9uZSBvbmVPck5vbmV9LFxyXG4gKiB7QGxpbmsgRGF0YWJhc2UjbWFueSBtYW55fSxcclxuICoge0BsaW5rIERhdGFiYXNlI21hbnlPck5vbmUgbWFueU9yTm9uZX0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNhbnkgYW55fSxcclxuICoge0BsaW5rIERhdGFiYXNlI2Z1bmMgZnVuY30sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNwcm9jIHByb2N9LFxyXG4gKiB7QGxpbmsgRGF0YWJhc2UjcmVzdWx0IHJlc3VsdH0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNtdWx0aVJlc3VsdCBtdWx0aVJlc3VsdH0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNtdWx0aSBtdWx0aX0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNtYXAgbWFwfSxcclxuICoge0BsaW5rIERhdGFiYXNlI2VhY2ggZWFjaH0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNzdHJlYW0gc3RyZWFtfSxcclxuICoge0BsaW5rIERhdGFiYXNlI3Rhc2sgdGFza30sXHJcbiAqIHtAbGluayBEYXRhYmFzZSN0YXNrSWYgdGFza0lmfSxcclxuICoge0BsaW5rIERhdGFiYXNlI3R4IHR4fSxcclxuICoge0BsaW5rIERhdGFiYXNlI3R4SWYgdHhJZn0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNjb25uZWN0IGNvbm5lY3R9LFxyXG4gKiB7QGxpbmsgRGF0YWJhc2UjJGNvbmZpZyAkY29uZmlnfSxcclxuICoge0BsaW5rIERhdGFiYXNlIyRjbiAkY259LFxyXG4gKiB7QGxpbmsgRGF0YWJhc2UjJGRjICRkY30sXHJcbiAqIHtAbGluayBEYXRhYmFzZSMkcG9vbCAkcG9vbH0sXHJcbiAqIHtAbGluayBldmVudDpleHRlbmQgZXh0ZW5kfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBQcm9wZXIgd2F5IHRvIGluaXRpYWxpemUgYW5kIHNoYXJlIHRoZSBEYXRhYmFzZSBvYmplY3RcclxuICpcclxuICogLy8gTG9hZGluZyBhbmQgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5OlxyXG4gKiBjb25zdCBwZ3AgPSByZXF1aXJlKCdwZy1wcm9taXNlJykoe1xyXG4gKiAgICAgLy8gSW5pdGlhbGl6YXRpb24gT3B0aW9uc1xyXG4gKiB9KTtcclxuICpcclxuICogLy8gUHJlcGFyaW5nIHRoZSBjb25uZWN0aW9uIGRldGFpbHM6XHJcbiAqIGNvbnN0IGNuID0gJ3Bvc3RncmVzOi8vdXNlcm5hbWU6cGFzc3dvcmRAaG9zdDpwb3J0L2RhdGFiYXNlJztcclxuICpcclxuICogLy8gQ3JlYXRpbmcgYSBuZXcgZGF0YWJhc2UgaW5zdGFuY2UgZnJvbSB0aGUgY29ubmVjdGlvbiBkZXRhaWxzOlxyXG4gKiBjb25zdCBkYiA9IHBncChjbik7XHJcbiAqXHJcbiAqIC8vIEV4cG9ydGluZyB0aGUgZGF0YWJhc2Ugb2JqZWN0IGZvciBzaGFyZWQgdXNlOlxyXG4gKiBtb2R1bGUuZXhwb3J0cyA9IGRiO1xyXG4gKi9cclxuZnVuY3Rpb24gRGF0YWJhc2UoY24sIGRjLCBjb25maWcpIHtcclxuXHJcbiAgICBjb25zdCBkYlRoaXMgPSB0aGlzLFxyXG4gICAgICAgICRwID0gY29uZmlnLnByb21pc2UsXHJcbiAgICAgICAgcG9vbENvbm5lY3Rpb24gPSB0eXBlb2YgY24gPT09ICdzdHJpbmcnID8ge2Nvbm5lY3Rpb25TdHJpbmc6IGNufSA6IGNuLFxyXG4gICAgICAgIHBvb2wgPSBuZXcgY29uZmlnLnBncC5wZy5Qb29sKHBvb2xDb25uZWN0aW9uKSxcclxuICAgICAgICBlbmRNZXRob2QgPSBwb29sLmVuZDtcclxuXHJcbiAgICBsZXQgZGVzdHJveWVkO1xyXG5cclxuICAgIHBvb2wuZW5kID0gY2IgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGVuZE1ldGhvZC5jYWxsKHBvb2wsIGNiKTtcclxuICAgICAgICBkYlRoaXMuJGRlc3Ryb3koKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwb29sLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBEYXRhYmFzZSNjb25uZWN0XHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBBY3F1aXJlcyBhIG5ldyBvciBleGlzdGluZyBjb25uZWN0aW9uLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24gcG9vbCwgYW5kIHBhcmFtZXRlciBgZGlyZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgc2hhcmVkIGNvbm5lY3Rpb24gZm9yIGV4ZWN1dGluZyBhIGNoYWluIG9mIHF1ZXJpZXMgYWdhaW5zdCBpdC4gVGhlIGNvbm5lY3Rpb24gbXVzdCBiZSByZWxlYXNlZFxyXG4gICAgICogaW4gdGhlIGVuZCBvZiB0aGUgY2hhaW4gYnkgY2FsbGluZyBgZG9uZSgpYCBvbiB0aGUgY29ubmVjdGlvbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogTWV0aG9kIGBkb25lYCB0YWtlcyBvbmUgb3B0aW9uYWwgcGFyYW1ldGVyIC0gYm9vbGVhbiBga2lsbGAgZmxhZywgdG8gc2lnbmFsIHRoZSBjb25uZWN0aW9uIHBvb2wgdGhhdCB5b3Ugd2FudCBpdCB0byBraWxsXHJcbiAgICAgKiB0aGUgcGh5c2ljYWwgY29ubmVjdGlvbi4gVGhpcyBmbGFnIGlzIGlnbm9yZWQgZm9yIGRpcmVjdCBjb25uZWN0aW9ucywgYXMgdGhleSBhbHdheXMgY2xvc2Ugd2hlbiByZWxlYXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBJdCBzaG91bGQgbm90IGJlIHVzZWQganVzdCBmb3IgY2hhaW5pbmcgcXVlcmllcyBvbiB0aGUgc2FtZSBjb25uZWN0aW9uLCBtZXRob2RzIHtAbGluayBEYXRhYmFzZSN0YXNrIHRhc2t9IGFuZFxyXG4gICAgICoge0BsaW5rIERhdGFiYXNlI3R4IHR4fSAoZm9yIHRyYW5zYWN0aW9ucykgYXJlIHRvIGJlIHVzZWQgZm9yIHRoYXQuIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBmb3Igc3BlY2lhbCBjYXNlcywgbGlrZVxyXG4gICAgICogYExJU1RFTmAgbm90aWZpY2F0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiAqKk5PVEU6KiogRXZlbiB0aG91Z2ggdGhpcyBtZXRob2QgZXhwb3NlcyBhIHtAbGluayBleHRlcm5hbDpDbGllbnQgQ2xpZW50fSBvYmplY3QgdmlhIHByb3BlcnR5IGBjbGllbnRgLFxyXG4gICAgICogeW91IGNhbm5vdCBjYWxsIGBjbGllbnQuZW5kKClgIGRpcmVjdGx5LCBvciBpdCB3aWxsIHByaW50IGFuIGVycm9yIGludG8gdGhlIGNvbnNvbGU6XHJcbiAgICAgKiBgQWJub3JtYWwgY2xpZW50LmVuZCgpIGNhbGwsIGR1ZSB0byBpbnZhbGlkIGNvZGUgb3IgZmFpbGVkIHNlcnZlciBjb25uZWN0aW9uLmBcclxuICAgICAqIFlvdSBzaG91bGQgb25seSBjYWxsIG1ldGhvZCBgZG9uZSgpYCB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIENvbm5lY3Rpb24gT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpcmVjdD1mYWxzZV1cclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29ubmVjdGlvbiBkaXJlY3RseSwgYXMgYSBzdGFuZC1hbG9uZSB7QGxpbmsgZXh0ZXJuYWw6Q2xpZW50IENsaWVudH0gb2JqZWN0LCBieXBhc3NpbmcgdGhlIGNvbm5lY3Rpb24gcG9vbC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBhbGwgY29ubmVjdGlvbnMgYXJlIGFjcXVpcmVkIGZyb20gdGhlIGNvbm5lY3Rpb24gcG9vbC4gQnV0IGlmIHlvdSBzZXQgdGhpcyBvcHRpb24sIHRoZSBsaWJyYXJ5IHdpbGwgaW5zdGVhZFxyXG4gICAgICogY3JlYXRlIGEgbmV3IHtAbGluayBleHRlcm5hbDpDbGllbnQgQ2xpZW50fSBvYmplY3QgZGlyZWN0bHkgKHNlcGFyYXRlbHkgZnJvbSB0aGUgcG9vbCksIGFuZCB0aGVuIGNhbGwgaXRzIGBjb25uZWN0YCBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHNwZWNpZmljYWxseSBmb3IgZGlyZWN0IGNvbm5lY3Rpb25zLCBtZXRob2QgYGRvbmVgIHJldHVybnMgYSB7QGxpbmsgZXh0ZXJuYWw6UHJvbWlzZSBQcm9taXNlfSwgYmVjYXVzZSB0aG9zZSBjb25uZWN0aW9uc1xyXG4gICAgICogYXJlIGNsb3NlZCBwaHlzaWNhbGx5LCB3aGljaCBtYXkgdGFrZSB0aW1lLlxyXG4gICAgICpcclxuICAgICAqICoqV0FSTklORzoqKlxyXG4gICAgICpcclxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBvcHRpb24gZm9yIHJlZ3VsYXIgcXVlcnkgZXhlY3V0aW9uLCBiZWNhdXNlIGl0IGV4Y2x1c2l2ZWx5IG9jY3VwaWVzIG9uZSBwaHlzaWNhbCBjaGFubmVsLCBhbmQgaXQgY2Fubm90IHNjYWxlLlxyXG4gICAgICogVGhpcyBvcHRpb24gaXMgb25seSBzdWl0YWJsZSBmb3IgZ2xvYmFsIGNvbm5lY3Rpb24gdXNhZ2UsIHN1Y2ggYXMgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLm9uTG9zdF1cclxuICAgICAqIE5vdGlmaWNhdGlvbiBjYWxsYmFjayBvZiB0aGUgbG9zdC9icm9rZW4gY29ubmVjdGlvbiwgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gICAgICogIC0gYGVycmAgLSB0aGUgb3JpZ2luYWwgY29ubmVjdGl2aXR5IGVycm9yXHJcbiAgICAgKiAgLSBgZWAgLSBlcnJvciBjb250ZXh0IG9iamVjdCwgd2hpY2ggY29udGFpbnM6XHJcbiAgICAgKiAgICAtIGBjbmAgLSBzYWZlIGNvbm5lY3Rpb24gc3RyaW5nL2NvbmZpZyAod2l0aCB0aGUgcGFzc3dvcmQgaGFzaGVkKTtcclxuICAgICAqICAgIC0gYGRjYCAtIERhdGFiYXNlIENvbnRleHQsIGFzIHdhcyB1c2VkIGR1cmluZyB7QGxpbmsgRGF0YWJhc2V9IGNvbnN0cnVjdGlvbjtcclxuICAgICAqICAgIC0gYHN0YXJ0YCAtIERhdGUvVGltZSAoYERhdGVgIHR5cGUpIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkO1xyXG4gICAgICogICAgLSBgY2xpZW50YCAtIHtAbGluayBleHRlcm5hbDpDbGllbnQgQ2xpZW50fSBvYmplY3QgdGhhdCBoYXMgbG9zdCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbm90aWZpY2F0aW9uIGlzIG1vc3RseSB2YWx1YWJsZSB3aXRoIGBkaXJlY3Q6IHRydWVgLCB0byBiZSBhYmxlIHRvIHJlLWNvbm5lY3QgZGlyZWN0L3Blcm1hbmVudCBjb25uZWN0aW9ucyBieSBjYWxsaW5nXHJcbiAgICAgKiBtZXRob2Qge0BsaW5rIERhdGFiYXNlI2Nvbm5lY3QgY29ubmVjdH0gYWdhaW4uXHJcbiAgICAgKlxyXG4gICAgICogWW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgYGRvbmVgIG9uIGxvc3QgY29ubmVjdGlvbnMsIGFzIGl0IGhhcHBlbnMgYXV0b21hdGljYWxseS4gSG93ZXZlciwgaWYgeW91IGhhZCBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqIHNldCB1cCBvbiB0aGUgY29ubmVjdGlvbidzIGBjbGllbnRgIG9iamVjdCwgeW91IHNob3VsZCByZW1vdmUgdGhlbSB0byBhdm9pZCBsZWFrczpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZnVuY3Rpb24gb25Mb3N0Q29ubmVjdGlvbihlcnIsIGUpIHtcclxuICAgICAqICAgICBlLmNsaWVudC5yZW1vdmVMaXN0ZW5lcignbXktZXZlbnQnLCBteUhhbmRsZXIpO1xyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGEgY29tcGxldGUgZXhhbXBsZSBzZWUgJFtSb2J1c3QgTGlzdGVuZXJzXS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAqIEEgcHJvbWlzZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb25uZWN0aW9uIHJlc3VsdDpcclxuICAgICAqICAtIHJlc29sdmVzIHdpdGggdGhlIGNvbXBsZXRlIHtAbGluayBEYXRhYmFzZX0gcHJvdG9jb2wsIGV4dGVuZGVkIHdpdGg6XHJcbiAgICAgKiAgICAtIHByb3BlcnR5IGBjbGllbnRgIG9mIHR5cGUge0BsaW5rIGV4dGVybmFsOkNsaWVudCBDbGllbnR9IHRoYXQgcmVwcmVzZW50cyB0aGUgb3BlbiBjb25uZWN0aW9uXHJcbiAgICAgKiAgICAtIG1ldGhvZCBgZG9uZWAgdGhhdCBtdXN0IGJlIGNhbGxlZCBpbiB0aGUgZW5kLCBpbiBvcmRlciB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uIChyZXR1cm5zIGEge0BsaW5rIGV4dGVybmFsOlByb21pc2UgUHJvbWlzZX1cclxuICAgICAqICAgICAgaW4gY2FzZSBvZiBkaXJlY3QgY29ubmVjdGlvbnMpXHJcbiAgICAgKiAgICAtIG1ldGhvZHMgYGJhdGNoYCwgYHBhZ2VgIGFuZCBgc2VxdWVuY2VgLCBzYW1lIGFzIGluc2lkZSBhIHtAbGluayBUYXNrfVxyXG4gICAgICogIC0gcmVqZWN0cyB3aXRoIGEgY29ubmVjdGlvbi1yZWxhdGVkIGVycm9yIHdoZW4gaXQgZmFpbHMgdG8gY29ubmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlXHJcbiAgICAgKiB7QGxpbmsgRGF0YWJhc2UjdGFzayBEYXRhYmFzZS50YXNrfSxcclxuICAgICAqIHtAbGluayBEYXRhYmFzZSN0YXNrSWYgRGF0YWJhc2UudGFza0lmfSxcclxuICAgICAqIHtAbGluayBEYXRhYmFzZSN0eCBEYXRhYmFzZS50eH0sXHJcbiAgICAgKiB7QGxpbmsgRGF0YWJhc2UjdHhJZiBEYXRhYmFzZS50eElmfVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogbGV0IHNjbzsgLy8gc2hhcmVkIGNvbm5lY3Rpb24gb2JqZWN0O1xyXG4gICAgICpcclxuICAgICAqIGRiLmNvbm5lY3QoKVxyXG4gICAgICogICAgIC50aGVuKG9iaiA9PiB7XHJcbiAgICAgKiAgICAgICAgIC8vIG9iai5jbGllbnQgPSBuZXcgY29ubmVjdGVkIENsaWVudCBvYmplY3Q7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBzY28gPSBvYmo7IC8vIHNhdmUgdGhlIGNvbm5lY3Rpb24gb2JqZWN0O1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgLy8gZXhlY3V0ZSBhbGwgdGhlIHF1ZXJpZXMgeW91IG5lZWQ6XHJcbiAgICAgKiAgICAgICAgIHJldHVybiBzY28uYW55KCdTRUxFQ1QgKiBGUk9NIFVzZXJzJyk7XHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAqICAgICAgICAgLy8gc3VjY2Vzc1xyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAqICAgICAgICAgLy8gZXJyb3JcclxuICAgICAqICAgICB9KVxyXG4gICAgICogICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAqICAgICAgICAgLy8gcmVsZWFzZSB0aGUgY29ubmVjdGlvbiwgaWYgaXQgd2FzIHN1Y2Nlc3NmdWw6XHJcbiAgICAgKiAgICAgICAgIGlmIChzY28pIHtcclxuICAgICAqICAgICAgICAgICAgIC8vIGlmIHlvdSBwYXNzIGB0cnVlYCBpbnRvIG1ldGhvZCBkb25lLCBpLmUuIGRvbmUodHJ1ZSksXHJcbiAgICAgKiAgICAgICAgICAgICAvLyBpdCB3aWxsIG1ha2UgdGhlIHBvb2wga2lsbCB0aGUgcGh5c2ljYWwgY29ubmVjdGlvbi5cclxuICAgICAqICAgICAgICAgICAgIHNjby5kb25lKCk7XHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dCgpO1xyXG4gICAgICAgIGN0eC5jbk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5KHF1ZXJ5LCB2YWx1ZXMsIHFybSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdHguZGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHAucmVqZWN0KG5ldyBFcnJvcihucG0udGV4dC5xdWVyeURpc2Nvbm5lY3RlZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy4kbnBtLnF1ZXJ5LmNhbGwodGhpcywgY3R4LCBxdWVyeSwgdmFsdWVzLCBxcm0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkb25lKGtpbGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3R4LmRiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5wbS50ZXh0Lmxvb3NlUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5kaXNjb25uZWN0KGtpbGwpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBiYXRjaCh2YWx1ZXMsIG9wdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy4kbnBtLnNwZXguYmF0Y2guY2FsbCh0aGlzLCB2YWx1ZXMsIG9wdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhZ2Uoc291cmNlLCBvcHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuJG5wbS5zcGV4LnBhZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIG9wdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcXVlbmNlKHNvdXJjZSwgb3B0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLiRucG0uc3BleC5zZXF1ZW5jZS5jYWxsKHRoaXMsIHNvdXJjZSwgb3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0ID8gY29uZmlnLiRucG0uY29ubmVjdC5kaXJlY3QoY3R4KSA6IGNvbmZpZy4kbnBtLmNvbm5lY3QucG9vbChjdHgsIGRiVGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgLnRoZW4oZGIgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LmNvbm5lY3QoZGIpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jbGllbnQgPSBkYi5jbGllbnQ7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQoY3R4LCBzZWxmKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIERhdGFiYXNlI3F1ZXJ5XHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBCYXNlIHF1ZXJ5IG1ldGhvZCB0aGF0IGV4ZWN1dGVzIGEgZ2VuZXJpYyBxdWVyeSwgZXhwZWN0aW5nIHRoZSByZXR1cm4gZGF0YSBhY2NvcmRpbmcgdG8gcGFyYW1ldGVyIGBxcm1gLlxyXG4gICAgICpcclxuICAgICAqIEl0IHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgc3RlcHM6XHJcbiAgICAgKlxyXG4gICAgICogIDEuIFZhbGlkYXRlcyBhbmQgZm9ybWF0cyB0aGUgcXVlcnkgdmlhIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBhcy5mb3JtYXR9LCBhY2NvcmRpbmcgdG8gdGhlIGBxdWVyeWAgYW5kIGB2YWx1ZXNgIHBhc3NlZCBpbjtcclxuICAgICAqICAyLiBGb3IgYSByb290LWxldmVsIHF1ZXJ5IChhZ2FpbnN0IHRoZSB7QGxpbmsgRGF0YWJhc2V9IG9iamVjdCksIGl0IHJlcXVlc3RzIGEgbmV3IGNvbm5lY3Rpb24gZnJvbSB0aGUgcG9vbDtcclxuICAgICAqICAzLiBFeGVjdXRlcyB0aGUgcXVlcnk7XHJcbiAgICAgKiAgNC4gRm9yIGEgcm9vdC1sZXZlbCBxdWVyeSAoYWdhaW5zdCB0aGUge0BsaW5rIERhdGFiYXNlfSBvYmplY3QpLCBpdCByZWxlYXNlcyB0aGUgY29ubmVjdGlvbiBiYWNrIHRvIHRoZSBwb29sO1xyXG4gICAgICogIDUuIFJlc29sdmVzL3JlamVjdHMsIGFjY29yZGluZyB0byB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeSBhbmQgdGhlIHZhbHVlIG9mIGBxcm1gLlxyXG4gICAgICpcclxuICAgICAqIERpcmVjdCB1c2Ugb2YgdGhpcyBtZXRob2QgaXMgbm90IHN1aXRhYmxlIGZvciBjaGFpbmluZyBxdWVyaWVzLCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSXQgc2hvdWxkIGJlIGRvbmVcclxuICAgICAqIHRocm91Z2ggZWl0aGVyIHRhc2sgb3IgdHJhbnNhY3Rpb24gY29udGV4dCwgc2VlICRbQ2hhaW5pbmcgUXVlcmllc10uXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiByZWNlaXZpbmcgYSBtdWx0aS1xdWVyeSByZXN1bHQsIG9ubHkgdGhlIGxhc3QgcmVzdWx0IGlzIHByb2Nlc3NlZCwgaWdub3JpbmcgdGhlIHJlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBxdWVyeVxyXG4gICAgICogUXVlcnkgdG8gYmUgZXhlY3V0ZWQsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcclxuICAgICAqIC0gQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nXHJcbiAgICAgKiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcXVlcnkgc3RyaW5nIG9yIGFub3RoZXIgZnVuY3Rpb24sIGkuZS4gcmVjdXJzaXZlIHJlc29sdXRpb25cclxuICAgICAqICAgaXMgc3VwcG9ydGVkLCBwYXNzaW5nIGluIGB2YWx1ZXNgIGFzIGB0aGlzYCwgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAqIC0gUGFyYW1ldGVyaXplZCBRdWVyeSBge3RleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gb2JqZWN0XHJcbiAgICAgKiAtIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YXJyYXl8dmFsdWV8ZnVuY3Rpb259IFt2YWx1ZXNdXHJcbiAgICAgKiBRdWVyeSBmb3JtYXR0aW5nIHBhcmFtZXRlcihzKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBgcXVlcnlgIGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QsIHRoZSBgdmFsdWVzYCBjYW4gYmU6XHJcbiAgICAgKiAtIGEgc2luZ2xlIHZhbHVlIC0gdG8gcmVwbGFjZSBhbGwgYCQxYCBvY2N1cnJlbmNlc1xyXG4gICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgKiAtIGFuIG9iamVjdCAtIHRvIGFwcGx5ICRbTmFtZWQgUGFyYW1ldGVyc10gZm9ybWF0dGluZ1xyXG4gICAgICpcclxuICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAqIGFuZCBgdmFsdWVzYCBpcyBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aXRoaW4gc3VjaCBvYmplY3QsXHJcbiAgICAgKiBhcyBhbiBvdmVycmlkZSBmb3IgaXRzIGludGVybmFsIGB2YWx1ZXNgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7cXVlcnlSZXN1bHR9IFtxcm09cXVlcnlSZXN1bHQuYW55XVxyXG4gICAgICoge0BsaW5rIHF1ZXJ5UmVzdWx0IFF1ZXJ5IFJlc3VsdCBNYXNrfVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlfVxyXG4gICAgICogQSBwcm9taXNlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHF1ZXJ5IHJlc3VsdCBhY2NvcmRpbmcgdG8gYHFybWAuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIHZhbHVlcywgcXJtKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIGN0eCA9IGNyZWF0ZUNvbnRleHQoKTtcclxuICAgICAgICByZXR1cm4gY29uZmlnLiRucG0uY29ubmVjdC5wb29sKGN0eCwgZGJUaGlzKVxyXG4gICAgICAgICAgICAudGhlbihkYiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjdHguY29ubmVjdChkYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLiRucG0ucXVlcnkuY2FsbChzZWxmLCBjdHgsIHF1ZXJ5LCB2YWx1ZXMsIHFybSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9IERhdGFiYXNlIyRjb25maWdcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBUaGlzIGlzIGEgaGlkZGVuIHByb3BlcnR5LCB0byBoZWxwIGludGVncmF0aW5nIHR5cGUge0BsaW5rIERhdGFiYXNlfSBkaXJlY3RseSB3aXRoIHRoaXJkLXBhcnR5IGxpYnJhcmllcy5cclxuICAgICAqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIGF2YWlsYWJsZSBpbiB0aGUgb2JqZWN0OlxyXG4gICAgICogLSBgcGdwYCAtIGluc3RhbmNlIG9mIHRoZSBlbnRpcmUgbGlicmFyeSBhZnRlciBpbml0aWFsaXphdGlvblxyXG4gICAgICogLSBgb3B0aW9uc2AgLSB0aGUgbGlicmFyeSdzIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZSBJbml0aWFsaXphdGlvbiBPcHRpb25zfSBvYmplY3RcclxuICAgICAqIC0gYHByb21pc2VMaWJgIC0gaW5zdGFuY2Ugb2YgdGhlIHByb21pc2UgbGlicmFyeSB0aGF0J3MgdXNlZFxyXG4gICAgICogLSBgcHJvbWlzZWAgLSBnZW5lcmljIHByb21pc2UgaW50ZXJmYWNlIHRoYXQgdXNlcyBgcHJvbWlzZUxpYmAgdmlhIDQgYmFzaWMgbWV0aG9kczpcclxuICAgICAqICAgLSBgcHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7fSlgIC0gdG8gY3JlYXRlIGEgbmV3IHByb21pc2VcclxuICAgICAqICAgLSBgcHJvbWlzZS5yZXNvbHZlKHZhbHVlKWAgLSB0byByZXNvbHZlIHdpdGggYSB2YWx1ZVxyXG4gICAgICogICAtIGBwcm9taXNlLnJlamVjdChyZWFzb24pYCAtIHRvIHJlamVjdCB3aXRoIGEgcmVhc29uXHJcbiAgICAgKiAgIC0gYHByb21pc2UuYWxsKGl0ZXJhYmxlKWAgLSB0byByZXNvbHZlIGFuIGl0ZXJhYmxlIGxpc3Qgb2YgcHJvbWlzZXNcclxuICAgICAqIC0gYHZlcnNpb25gIC0gdGhpcyBsaWJyYXJ5J3MgdmVyc2lvblxyXG4gICAgICogLSBgJG5wbWAgXyhoaWRkZW4gcHJvcGVydHkpXyAtIGludGVybmFsIG1vZHVsZSBjYWNoZVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogLy8gVXNpbmcgdGhlIHByb21pc2UgcHJvdG9jb2wgYXMgY29uZmlndXJlZCBieSBwZy1wcm9taXNlOlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0ICRwID0gZGIuJGNvbmZpZy5wcm9taXNlO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9ICRwLnJlc29sdmUoJ3NvbWUgZGF0YScpO1xyXG4gICAgICogY29uc3QgcmVqZWN0ZWRQcm9taXNlID0gJHAucmVqZWN0KCdzb21lIHJlYXNvbicpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG5ld1Byb21pc2UgPSAkcCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgKiAgICAgLy8gY2FsbCBlaXRoZXIgcmVzb2x2ZShkYXRhKSBvciByZWplY3QocmVhc29uKSBoZXJlXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKHRoaXMsICckY29uZmlnJywgY29uZmlnLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xvYmplY3R9IERhdGFiYXNlIyRjblxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIERhdGFiYXNlIGNvbm5lY3Rpb24sIGFzIHdhcyBwYXNzZWQgaW4gZHVyaW5nIHRoZSBvYmplY3QncyBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhIGhpZGRlbiBwcm9wZXJ0eSwgdG8gaGVscCBpbnRlZ3JhdGluZyB0eXBlIHtAbGluayBEYXRhYmFzZX0gZGlyZWN0bHkgd2l0aCB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSBEYXRhYmFzZVxyXG4gICAgICovXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcywgJyRjbicsIGNuLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIgeyp9IERhdGFiYXNlIyRkY1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIERhdGFiYXNlIENvbnRleHQsIGFzIHdhcyBwYXNzZWQgaW4gZHVyaW5nIHRoZSBvYmplY3QncyBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhIGhpZGRlbiBwcm9wZXJ0eSwgdG8gaGVscCBpbnRlZ3JhdGluZyB0eXBlIHtAbGluayBEYXRhYmFzZX0gZGlyZWN0bHkgd2l0aCB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSBEYXRhYmFzZVxyXG4gICAgICovXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcywgJyRkYycsIGRjLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2V4dGVybmFsOnBnLXBvb2x9IERhdGFiYXNlIyRwb29sXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQSAkW3BnLXBvb2xdIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGRhdGFiYXNlIG9iamVjdCwgYXMgZWFjaCB7QGxpbmsgRGF0YWJhc2V9IGNyZWF0ZXMgaXRzIG93biAkW3BnLXBvb2xdIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYSBoaWRkZW4gcHJvcGVydHksIHByaW1hcmlseSBmb3IgaW50ZWdyYXRpbmcgdHlwZSB7QGxpbmsgRGF0YWJhc2V9IHdpdGggdGhpcmQtcGFydHkgbGlicmFyaWVzIHRoYXQgc3VwcG9ydFxyXG4gICAgICogJFtwZy1wb29sXSBkaXJlY3RseS4gTm90ZSBob3dldmVyLCB0aGF0IGlmIHlvdSBwYXNzIHRoZSBwb29sIG9iamVjdCBpbnRvIGEgbGlicmFyeSB0aGF0IGNhbGxzIGBwb29sLmVuZCgpYCwgeW91IHdpbGwgbm8gbG9uZ2VyIGJlIGFibGVcclxuICAgICAqIHRvIHVzZSB0aGlzIHtAbGluayBEYXRhYmFzZX0gb2JqZWN0LCBhbmQgZWFjaCBxdWVyeSBtZXRob2Qgd2lsbCBiZSByZWplY3Rpbmcgd2l0aCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID1cclxuICAgICAqIGBDb25uZWN0aW9uIHBvb2wgb2YgdGhlIGRhdGFiYXNlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQuYFxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgdGhpcyBvYmplY3QgdG8gc2h1dCBkb3duIHRoZSBwb29sLCBieSBjYWxsaW5nIGAkcG9vbC5lbmQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIG1vcmUgZGV0YWlscyBzZWUgJFtMaWJyYXJ5IGRlLWluaXRpYWxpemF0aW9uXS5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlXHJcbiAgICAgKiB7QGxpbmsgRGF0YWJhc2V9XHJcbiAgICAgKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+ZW5kIHBncC5lbmR9XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAvLyBTaHV0dGluZyBkb3duIHRoZSBjb25uZWN0aW9uIHBvb2wgb2YgdGhpcyBkYXRhYmFzZSBvYmplY3QsXHJcbiAgICAgKiAvLyBhZnRlciBhbGwgcXVlcmllcyBoYXZlIGZpbmlzaGVkIGluIGEgcnVuLXRob3VnaCBwcm9jZXNzOlxyXG4gICAgICpcclxuICAgICAqIC50aGVuKCgpID0+IHt9KSAvLyBwcm9jZXNzaW5nIHRoZSBkYXRhXHJcbiAgICAgKiAuY2F0Y2goKSA9PiB7fSkgLy8gaGFuZGxpbmcgdGhlIGVycm9yXHJcbiAgICAgKiAuZmluYWxseShkYi4kcG9vbC5lbmQpOyAvLyBzaHV0dGluZyBkb3duIHRoZSBwb29sXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcywgJyRwb29sJywgcG9vbCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn0gRGF0YWJhc2UuJGRlc3Ryb3lcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogUGVybWFuZW50bHkgc2h1dHMgZG93biB0aGUgZGF0YWJhc2Ugb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcywgJyRkZXN0cm95JywgKCkgPT4ge1xyXG4gICAgICAgIGlmICghZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIGlmICghcG9vbC5lbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGVuZE1ldGhvZC5jYWxsKHBvb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERhdGFiYXNlUG9vbC51bnJlZ2lzdGVyKGRiVGhpcyk7XHJcbiAgICAgICAgICAgIHBvb2wucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIGRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgRGF0YWJhc2VQb29sLnJlZ2lzdGVyKHRoaXMpO1xyXG5cclxuICAgIGV4dGVuZChjcmVhdGVDb250ZXh0KCksIHRoaXMpOyAvLyBleHRlbmRpbmcgcm9vdCBwcm90b2NvbDtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbkNvbnRleHQoe2NuLCBkYywgb3B0aW9uczogY29uZmlnLm9wdGlvbnN9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPcHRpb25hbCB2YWx1ZS10cmFuc2Zvcm1hdGlvbiBoZWxwZXI6XHJcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0odmFsdWUsIGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRoZW4oZGF0YSA9PiBjYi5jYWxsKHRoaXNBcmcsIGRhdGEpKSA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIEluamVjdHMgYWRkaXRpb25hbCBtZXRob2RzIGludG8gYW4gYWNjZXNzIG9iamVjdCxcclxuICAgIC8vIGV4dGVuZGluZyB0aGUgcHJvdG9jb2wncyBiYXNlIG1ldGhvZCAncXVlcnknLlxyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGN0eCwgb2JqKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2Ujbm9uZVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgcXVlcnkgdGhhdCBleHBlY3RzIG5vIGRhdGEgdG8gYmUgcmV0dXJuZWQuIElmIHRoZSBxdWVyeSByZXR1cm5zIGFueSBkYXRhLFxyXG4gICAgICAgICAqIHRoZSBtZXRob2QgcmVqZWN0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gcmVjZWl2aW5nIGEgbXVsdGktcXVlcnkgcmVzdWx0LCBvbmx5IHRoZSBsYXN0IHJlc3VsdCBpcyBwcm9jZXNzZWQsIGlnbm9yaW5nIHRoZSByZXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBxdWVyeVxyXG4gICAgICAgICAqIFF1ZXJ5IHRvIGJlIGV4ZWN1dGVkLCB3aGljaCBjYW4gYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6XHJcbiAgICAgICAgICogLSBBIG5vbi1lbXB0eSBxdWVyeSBzdHJpbmdcclxuICAgICAgICAgKiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcXVlcnkgc3RyaW5nIG9yIGFub3RoZXIgZnVuY3Rpb24sIGkuZS4gcmVjdXJzaXZlIHJlc29sdXRpb25cclxuICAgICAgICAgKiAgIGlzIHN1cHBvcnRlZCwgcGFzc2luZyBpbiBgdmFsdWVzYCBhcyBgdGhpc2AsIGFuZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIC0gUHJlcGFyZWQgU3RhdGVtZW50IGB7bmFtZSwgdGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUHJlcGFyZWRTdGF0ZW1lbnR9IG9iamVjdFxyXG4gICAgICAgICAqIC0gUGFyYW1ldGVyaXplZCBRdWVyeSBge3RleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gb2JqZWN0XHJcbiAgICAgICAgICogLSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8dmFsdWV8ZnVuY3Rpb259IFt2YWx1ZXNdXHJcbiAgICAgICAgICogUXVlcnkgZm9ybWF0dGluZyBwYXJhbWV0ZXIocyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QsIHRoZSBgdmFsdWVzYCBjYW4gYmU6XHJcbiAgICAgICAgICogLSBhIHNpbmdsZSB2YWx1ZSAtIHRvIHJlcGxhY2UgYWxsIGAkMWAgb2NjdXJyZW5jZXNcclxuICAgICAgICAgKiAtIGFuIGFycmF5IG9mIHZhbHVlcyAtIHRvIHJlcGxhY2UgYWxsIGAkMWAsIGAkMmAsIC4uLiB2YXJpYWJsZXNcclxuICAgICAgICAgKiAtIGFuIG9iamVjdCAtIHRvIGFwcGx5ICRbTmFtZWQgUGFyYW1ldGVyc10gZm9ybWF0dGluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIGEgUHJlcGFyZWQgU3RhdGVtZW50IG9yIGEgUGFyYW1ldGVyaXplZCBRdWVyeSAob3IgdGhlaXIgY2xhc3MgdHlwZXMpLFxyXG4gICAgICAgICAqIGFuZCBgdmFsdWVzYCBpcyBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aXRoaW4gc3VjaCBvYmplY3QsXHJcbiAgICAgICAgICogYXMgYW4gb3ZlcnJpZGUgZm9yIGl0cyBpbnRlcm5hbCBgdmFsdWVzYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlPG51bGw+fVxyXG4gICAgICAgICAqIEEgcHJvbWlzZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBxdWVyeSByZXN1bHQ6XHJcbiAgICAgICAgICogLSBXaGVuIG5vIHJlY29yZHMgYXJlIHJldHVybmVkLCBpdCByZXNvbHZlcyB3aXRoIGBudWxsYC5cclxuICAgICAgICAgKiAtIFdoZW4gYW55IGRhdGEgaXMgcmV0dXJuZWQsIGl0IHJlamVjdHMgd2l0aCB7QGxpbmsgZXJyb3JzLlF1ZXJ5UmVzdWx0RXJyb3IgUXVlcnlSZXN1bHRFcnJvcn06XHJcbiAgICAgICAgICogICAtIGAubWVzc2FnZWAgPSBgTm8gcmV0dXJuIGRhdGEgd2FzIGV4cGVjdGVkLmBcclxuICAgICAgICAgKiAgIC0gYC5jb2RlYCA9IHtAbGluayBlcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGUubm90RW1wdHkgcXVlcnlSZXN1bHRFcnJvckNvZGUubm90RW1wdHl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLm5vbmUgPSBmdW5jdGlvbiAocXVlcnksIHZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnF1ZXJ5LmNhbGwodGhpcywgcXVlcnksIHZhbHVlcywgcXVlcnlSZXN1bHQubm9uZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNvbmVcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBFeGVjdXRlcyBhIHF1ZXJ5IHRoYXQgZXhwZWN0cyBleGFjdGx5IDEgcm93IHRvIGJlIHJldHVybmVkLiBXaGVuIDAgb3IgbW9yZSB0aGFuIDEgcm93cyBhcmUgcmV0dXJuZWQsXHJcbiAgICAgICAgICogdGhlIG1ldGhvZCByZWplY3RzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiByZWNlaXZpbmcgYSBtdWx0aS1xdWVyeSByZXN1bHQsIG9ubHkgdGhlIGxhc3QgcmVzdWx0IGlzIHByb2Nlc3NlZCwgaWdub3JpbmcgdGhlIHJlc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R9IHF1ZXJ5XHJcbiAgICAgICAgICogUXVlcnkgdG8gYmUgZXhlY3V0ZWQsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcclxuICAgICAgICAgKiAtIEEgbm9uLWVtcHR5IHF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgICAqIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBxdWVyeSBzdHJpbmcgb3IgYW5vdGhlciBmdW5jdGlvbiwgaS5lLiByZWN1cnNpdmUgcmVzb2x1dGlvblxyXG4gICAgICAgICAqICAgaXMgc3VwcG9ydGVkLCBwYXNzaW5nIGluIGB2YWx1ZXNgIGFzIGB0aGlzYCwgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogLSBQcmVwYXJlZCBTdGF0ZW1lbnQgYHtuYW1lLCB0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudH0gb2JqZWN0XHJcbiAgICAgICAgICogLSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IGB7dGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSBvYmplY3RcclxuICAgICAgICAgKiAtIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheXx2YWx1ZXxmdW5jdGlvbn0gW3ZhbHVlc11cclxuICAgICAgICAgKiBRdWVyeSBmb3JtYXR0aW5nIHBhcmFtZXRlcihzKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGBxdWVyeWAgaXMgb2YgdHlwZSBgc3RyaW5nYCBvciBhIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdCwgdGhlIGB2YWx1ZXNgIGNhbiBiZTpcclxuICAgICAgICAgKiAtIGEgc2luZ2xlIHZhbHVlIC0gdG8gcmVwbGFjZSBhbGwgYCQxYCBvY2N1cnJlbmNlc1xyXG4gICAgICAgICAqIC0gYW4gYXJyYXkgb2YgdmFsdWVzIC0gdG8gcmVwbGFjZSBhbGwgYCQxYCwgYCQyYCwgLi4uIHZhcmlhYmxlc1xyXG4gICAgICAgICAqIC0gYW4gb2JqZWN0IC0gdG8gYXBwbHkgJFtOYW1lZCBQYXJhbWV0ZXJzXSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGBxdWVyeWAgaXMgYSBQcmVwYXJlZCBTdGF0ZW1lbnQgb3IgYSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IChvciB0aGVpciBjbGFzcyB0eXBlcyksXHJcbiAgICAgICAgICogYW5kIGB2YWx1ZXNgIGlzIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGl0IGlzIGF1dG9tYXRpY2FsbHkgc2V0IHdpdGhpbiBzdWNoIG9iamVjdCxcclxuICAgICAgICAgKiBhcyBhbiBvdmVycmlkZSBmb3IgaXRzIGludGVybmFsIGB2YWx1ZXNgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NiXVxyXG4gICAgICAgICAqIFZhbHVlLXRyYW5zZm9ybWF0aW9uIGNhbGxiYWNrLCB0byBhbGxvdyBpbi1saW5lIHZhbHVlIGNoYW5nZS5cclxuICAgICAgICAgKiBXaGVuIHNwZWNpZmllZCwgdGhlIHJldHVybmVkIHZhbHVlIHJlcGxhY2VzIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdGFrZXMgb25seSBvbmUgcGFyYW1ldGVyIC0gdmFsdWUgcmVzb2x2ZWQgZnJvbSB0aGUgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXVxyXG4gICAgICAgICAqIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIGNhbGxiYWNrLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAgICAgICAgICogQSBwcm9taXNlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHF1ZXJ5IHJlc3VsdDpcclxuICAgICAgICAgKiAtIFdoZW4gMSByb3cgaXMgcmV0dXJuZWQsIGl0IHJlc29sdmVzIHdpdGggdGhhdCByb3cgYXMgYSBzaW5nbGUgb2JqZWN0LlxyXG4gICAgICAgICAqIC0gV2hlbiBubyByb3dzIGFyZSByZXR1cm5lZCwgaXQgcmVqZWN0cyB3aXRoIHtAbGluayBlcnJvcnMuUXVlcnlSZXN1bHRFcnJvciBRdWVyeVJlc3VsdEVycm9yfTpcclxuICAgICAgICAgKiAgIC0gYC5tZXNzYWdlYCA9IGBObyBkYXRhIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LmBcclxuICAgICAgICAgKiAgIC0gYC5jb2RlYCA9IHtAbGluayBlcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGUubm9EYXRhIHF1ZXJ5UmVzdWx0RXJyb3JDb2RlLm5vRGF0YX1cclxuICAgICAgICAgKiAtIFdoZW4gbXVsdGlwbGUgcm93cyBhcmUgcmV0dXJuZWQsIGl0IHJlamVjdHMgd2l0aCB7QGxpbmsgZXJyb3JzLlF1ZXJ5UmVzdWx0RXJyb3IgUXVlcnlSZXN1bHRFcnJvcn06XHJcbiAgICAgICAgICogICAtIGAubWVzc2FnZWAgPSBgTXVsdGlwbGUgcm93cyB3ZXJlIG5vdCBleHBlY3RlZC5gXHJcbiAgICAgICAgICogICAtIGAuY29kZWAgPSB7QGxpbmsgZXJyb3JzLnF1ZXJ5UmVzdWx0RXJyb3JDb2RlLm11bHRpcGxlIHF1ZXJ5UmVzdWx0RXJyb3JDb2RlLm11bHRpcGxlfVxyXG4gICAgICAgICAqIC0gUmVzb2x2ZXMgd2l0aCB0aGUgbmV3IHZhbHVlLCBpZiB0cmFuc2Zvcm1hdGlvbiBjYWxsYmFjayBgY2JgIHdhcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI29uZU9yTm9uZSBvbmVPck5vbmV9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gYSBxdWVyeSB3aXRoIGluLWxpbmUgdmFsdWUgdHJhbnNmb3JtYXRpb246XHJcbiAgICAgICAgICogZGIub25lKCdJTlNFUlQgSU5UTyBFdmVudHMgVkFMVUVTKCQxKSBSRVRVUk5JTkcgaWQnLCBbMTIzXSwgZXZlbnQgPT4gZXZlbnQuaWQpXHJcbiAgICAgICAgICogICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gZGF0YSA9IGEgbmV3IGV2ZW50IGlkLCByYXRoZXIgdGhhbiBhbiBvYmplY3Qgd2l0aCBpdFxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBhIHF1ZXJ5IHdpdGggaW4tbGluZSB2YWx1ZSB0cmFuc2Zvcm1hdGlvbiArIGNvbnZlcnNpb246XHJcbiAgICAgICAgICogZGIub25lKCdTRUxFQ1QgY291bnQoKikgRlJPTSBVc2VycycsIFtdLCBjID0+ICtjLmNvdW50KVxyXG4gICAgICAgICAqICAgICAudGhlbihjb3VudCA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBjb3VudCA9IGEgcHJvcGVyIGludGVnZXIgdmFsdWUsIHJhdGhlciB0aGFuIGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLm9uZSA9IGZ1bmN0aW9uIChxdWVyeSwgdmFsdWVzLCBjYiwgdGhpc0FyZykge1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gb2JqLnF1ZXJ5LmNhbGwodGhpcywgcXVlcnksIHZhbHVlcywgcXVlcnlSZXN1bHQub25lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybSh2LCBjYiwgdGhpc0FyZyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNtYW55XHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBxdWVyeSB0aGF0IGV4cGVjdHMgb25lIG9yIG1vcmUgcm93cyB0byBiZSByZXR1cm5lZC4gV2hlbiB0aGUgcXVlcnkgcmV0dXJucyBubyByb3dzLCB0aGUgbWV0aG9kIHJlamVjdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHJlY2VpdmluZyBhIG11bHRpLXF1ZXJ5IHJlc3VsdCwgb25seSB0aGUgbGFzdCByZXN1bHQgaXMgcHJvY2Vzc2VkLCBpZ25vcmluZyB0aGUgcmVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gcXVlcnlcclxuICAgICAgICAgKiBRdWVyeSB0byBiZSBleGVjdXRlZCwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gICAgICAgICAqIC0gQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nXHJcbiAgICAgICAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHF1ZXJ5IHN0cmluZyBvciBhbm90aGVyIGZ1bmN0aW9uLCBpLmUuIHJlY3Vyc2l2ZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICogICBpcyBzdXBwb3J0ZWQsIHBhc3NpbmcgaW4gYHZhbHVlc2AgYXMgYHRoaXNgLCBhbmQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAgICAgKiAtIFBhcmFtZXRlcml6ZWQgUXVlcnkgYHt0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnl9IG9iamVjdFxyXG4gICAgICAgICAqIC0ge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fHZhbHVlfGZ1bmN0aW9ufSBbdmFsdWVzXVxyXG4gICAgICAgICAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVyKHMpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LCB0aGUgYHZhbHVlc2AgY2FuIGJlOlxyXG4gICAgICAgICAqIC0gYSBzaW5nbGUgdmFsdWUgLSB0byByZXBsYWNlIGFsbCBgJDFgIG9jY3VycmVuY2VzXHJcbiAgICAgICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgICAgICogLSBhbiBvYmplY3QgLSB0byBhcHBseSAkW05hbWVkIFBhcmFtZXRlcnNdIGZvcm1hdHRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAgICAgKiBhbmQgYHZhbHVlc2AgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgd2l0aGluIHN1Y2ggb2JqZWN0LFxyXG4gICAgICAgICAqIGFzIGFuIG92ZXJyaWRlIGZvciBpdHMgaW50ZXJuYWwgYHZhbHVlc2AuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcXVlcnkgcmVzdWx0OlxyXG4gICAgICAgICAqIC0gV2hlbiAxIG9yIG1vcmUgcm93cyBhcmUgcmV0dXJuZWQsIGl0IHJlc29sdmVzIHdpdGggdGhlIGFycmF5IG9mIHJvd3MuXHJcbiAgICAgICAgICogLSBXaGVuIG5vIHJvd3MgYXJlIHJldHVybmVkLCBpdCByZWplY3RzIHdpdGgge0BsaW5rIGVycm9ycy5RdWVyeVJlc3VsdEVycm9yIFF1ZXJ5UmVzdWx0RXJyb3J9OlxyXG4gICAgICAgICAqICAgLSBgLm1lc3NhZ2VgID0gYE5vIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgcXVlcnkuYFxyXG4gICAgICAgICAqICAgLSBgLmNvZGVgID0ge0BsaW5rIGVycm9ycy5xdWVyeVJlc3VsdEVycm9yQ29kZS5ub0RhdGEgcXVlcnlSZXN1bHRFcnJvckNvZGUubm9EYXRhfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai5tYW55ID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5xdWVyeS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMsIHF1ZXJ5UmVzdWx0Lm1hbnkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2Ujb25lT3JOb25lXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBxdWVyeSB0aGF0IGV4cGVjdHMgMCBvciAxIHJvd3MgdG8gYmUgcmV0dXJuZWQuIEl0IHJlc29sdmVzIHdpdGggdGhlIHJvdy1vYmplY3Qgd2hlbiAxIHJvdyBpcyByZXR1cm5lZCxcclxuICAgICAgICAgKiBvciB3aXRoIGBudWxsYCB3aGVuIG5vdGhpbmcgaXMgcmV0dXJuZWQuIFdoZW4gdGhlIHF1ZXJ5IHJldHVybnMgbW9yZSB0aGFuIDEgcm93LCB0aGUgbWV0aG9kIHJlamVjdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHJlY2VpdmluZyBhIG11bHRpLXF1ZXJ5IHJlc3VsdCwgb25seSB0aGUgbGFzdCByZXN1bHQgaXMgcHJvY2Vzc2VkLCBpZ25vcmluZyB0aGUgcmVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gcXVlcnlcclxuICAgICAgICAgKiBRdWVyeSB0byBiZSBleGVjdXRlZCwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gICAgICAgICAqIC0gQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nXHJcbiAgICAgICAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHF1ZXJ5IHN0cmluZyBvciBhbm90aGVyIGZ1bmN0aW9uLCBpLmUuIHJlY3Vyc2l2ZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICogICBpcyBzdXBwb3J0ZWQsIHBhc3NpbmcgaW4gYHZhbHVlc2AgYXMgYHRoaXNgLCBhbmQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAgICAgKiAtIFBhcmFtZXRlcml6ZWQgUXVlcnkgYHt0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnl9IG9iamVjdFxyXG4gICAgICAgICAqIC0ge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fHZhbHVlfGZ1bmN0aW9ufSBbdmFsdWVzXVxyXG4gICAgICAgICAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVyKHMpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LCB0aGUgYHZhbHVlc2AgY2FuIGJlOlxyXG4gICAgICAgICAqIC0gYSBzaW5nbGUgdmFsdWUgLSB0byByZXBsYWNlIGFsbCBgJDFgIG9jY3VycmVuY2VzXHJcbiAgICAgICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgICAgICogLSBhbiBvYmplY3QgLSB0byBhcHBseSAkW05hbWVkIFBhcmFtZXRlcnNdIGZvcm1hdHRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAgICAgKiBhbmQgYHZhbHVlc2AgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgd2l0aGluIHN1Y2ggb2JqZWN0LFxyXG4gICAgICAgICAqIGFzIGFuIG92ZXJyaWRlIGZvciBpdHMgaW50ZXJuYWwgYHZhbHVlc2AuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2JdXHJcbiAgICAgICAgICogVmFsdWUtdHJhbnNmb3JtYXRpb24gY2FsbGJhY2ssIHRvIGFsbG93IGluLWxpbmUgdmFsdWUgY2hhbmdlLlxyXG4gICAgICAgICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgcmV0dXJuZWQgdmFsdWUgcmVwbGFjZXMgdGhlIG9yaWdpbmFsIG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmx5IG9uZSBwYXJhbWV0ZXIgLSB2YWx1ZSByZXNvbHZlZCBmcm9tIHRoZSBxdWVyeS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddXHJcbiAgICAgICAgICogVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgdHJhbnNmb3JtYXRpb24gY2FsbGJhY2suXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcXVlcnkgcmVzdWx0OlxyXG4gICAgICAgICAqIC0gV2hlbiBubyByb3dzIGFyZSByZXR1cm5lZCwgaXQgcmVzb2x2ZXMgd2l0aCBgbnVsbGAuXHJcbiAgICAgICAgICogLSBXaGVuIDEgcm93IGlzIHJldHVybmVkLCBpdCByZXNvbHZlcyB3aXRoIHRoYXQgcm93IGFzIGEgc2luZ2xlIG9iamVjdC5cclxuICAgICAgICAgKiAtIFdoZW4gbXVsdGlwbGUgcm93cyBhcmUgcmV0dXJuZWQsIGl0IHJlamVjdHMgd2l0aCB7QGxpbmsgZXJyb3JzLlF1ZXJ5UmVzdWx0RXJyb3IgUXVlcnlSZXN1bHRFcnJvcn06XHJcbiAgICAgICAgICogICAtIGAubWVzc2FnZWAgPSBgTXVsdGlwbGUgcm93cyB3ZXJlIG5vdCBleHBlY3RlZC5gXHJcbiAgICAgICAgICogICAtIGAuY29kZWAgPSB7QGxpbmsgZXJyb3JzLnF1ZXJ5UmVzdWx0RXJyb3JDb2RlLm11bHRpcGxlIHF1ZXJ5UmVzdWx0RXJyb3JDb2RlLm11bHRpcGxlfVxyXG4gICAgICAgICAqIC0gUmVzb2x2ZXMgd2l0aCB0aGUgbmV3IHZhbHVlLCBpZiB0cmFuc2Zvcm1hdGlvbiBjYWxsYmFjayBgY2JgIHdhcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI29uZSBvbmV9LFxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNub25lIG5vbmV9LFxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNtYW55T3JOb25lIG1hbnlPck5vbmV9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gYSBxdWVyeSB3aXRoIGluLWxpbmUgdmFsdWUgdHJhbnNmb3JtYXRpb246XHJcbiAgICAgICAgICogZGIub25lT3JOb25lKCdTRUxFQ1QgaWQgRlJPTSBFdmVudHMgV0hFUkUgdHlwZSA9ICQxJywgWydlbnRyeSddLCBlID0+IGUgJiYgZS5pZClcclxuICAgICAgICAgKiAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBkYXRhID0gdGhlIGV2ZW50IGlkIG9yIG51bGwgKHJhdGhlciB0aGFuIG9iamVjdCBvciBudWxsKVxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai5vbmVPck5vbmUgPSBmdW5jdGlvbiAocXVlcnksIHZhbHVlcywgY2IsIHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgY29uc3QgdiA9IG9iai5xdWVyeS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMsIHF1ZXJ5UmVzdWx0Lm9uZSB8IHF1ZXJ5UmVzdWx0Lm5vbmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtKHYsIGNiLCB0aGlzQXJnKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIERhdGFiYXNlI21hbnlPck5vbmVcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBFeGVjdXRlcyBhIHF1ZXJ5IHRoYXQgY2FuIHJldHVybiBhbnkgbnVtYmVyIG9mIHJvd3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHJlY2VpdmluZyBhIG11bHRpLXF1ZXJ5IHJlc3VsdCwgb25seSB0aGUgbGFzdCByZXN1bHQgaXMgcHJvY2Vzc2VkLCBpZ25vcmluZyB0aGUgcmVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gcXVlcnlcclxuICAgICAgICAgKiBRdWVyeSB0byBiZSBleGVjdXRlZCwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gICAgICAgICAqIC0gQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nXHJcbiAgICAgICAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHF1ZXJ5IHN0cmluZyBvciBhbm90aGVyIGZ1bmN0aW9uLCBpLmUuIHJlY3Vyc2l2ZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICogICBpcyBzdXBwb3J0ZWQsIHBhc3NpbmcgaW4gYHZhbHVlc2AgYXMgYHRoaXNgLCBhbmQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAgICAgKiAtIFBhcmFtZXRlcml6ZWQgUXVlcnkgYHt0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnl9IG9iamVjdFxyXG4gICAgICAgICAqIC0ge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fHZhbHVlfGZ1bmN0aW9ufSBbdmFsdWVzXVxyXG4gICAgICAgICAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVyKHMpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LCB0aGUgYHZhbHVlc2AgY2FuIGJlOlxyXG4gICAgICAgICAqIC0gYSBzaW5nbGUgdmFsdWUgLSB0byByZXBsYWNlIGFsbCBgJDFgIG9jY3VycmVuY2VzXHJcbiAgICAgICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgICAgICogLSBhbiBvYmplY3QgLSB0byBhcHBseSAkW05hbWVkIFBhcmFtZXRlcnNdIGZvcm1hdHRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAgICAgKiBhbmQgYHZhbHVlc2AgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgd2l0aGluIHN1Y2ggb2JqZWN0LFxyXG4gICAgICAgICAqIGFzIGFuIG92ZXJyaWRlIGZvciBpdHMgaW50ZXJuYWwgYHZhbHVlc2AuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZTxBcnJheT59XHJcbiAgICAgICAgICogQSBwcm9taXNlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHF1ZXJ5IHJlc3VsdDpcclxuICAgICAgICAgKiAtIFdoZW4gbm8gcm93cyBhcmUgcmV0dXJuZWQsIGl0IHJlc29sdmVzIHdpdGggYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgICAgICogLSBXaGVuIDEgb3IgbW9yZSByb3dzIGFyZSByZXR1cm5lZCwgaXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXJyYXkgb2Ygcm93cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWVcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjYW55IGFueX0sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI21hbnkgbWFueX0sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI25vbmUgbm9uZX1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai5tYW55T3JOb25lID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5xdWVyeS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMsIHF1ZXJ5UmVzdWx0Lm1hbnkgfCBxdWVyeVJlc3VsdC5ub25lKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIERhdGFiYXNlI2FueVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgcXVlcnkgdGhhdCBjYW4gcmV0dXJuIGFueSBudW1iZXIgb2Ygcm93cy5cclxuICAgICAgICAgKiBUaGlzIGlzIHNpbXBseSBhIHNob3J0ZXIgYWxpYXMgZm9yIG1ldGhvZCB7QGxpbmsgRGF0YWJhc2UjbWFueU9yTm9uZSBtYW55T3JOb25lfS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gcmVjZWl2aW5nIGEgbXVsdGktcXVlcnkgcmVzdWx0LCBvbmx5IHRoZSBsYXN0IHJlc3VsdCBpcyBwcm9jZXNzZWQsIGlnbm9yaW5nIHRoZSByZXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBxdWVyeVxyXG4gICAgICAgICAqIFF1ZXJ5IHRvIGJlIGV4ZWN1dGVkLCB3aGljaCBjYW4gYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6XHJcbiAgICAgICAgICogLSBBIG5vbi1lbXB0eSBxdWVyeSBzdHJpbmdcclxuICAgICAgICAgKiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcXVlcnkgc3RyaW5nIG9yIGFub3RoZXIgZnVuY3Rpb24sIGkuZS4gcmVjdXJzaXZlIHJlc29sdXRpb25cclxuICAgICAgICAgKiAgIGlzIHN1cHBvcnRlZCwgcGFzc2luZyBpbiBgdmFsdWVzYCBhcyBgdGhpc2AsIGFuZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIC0gUHJlcGFyZWQgU3RhdGVtZW50IGB7bmFtZSwgdGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUHJlcGFyZWRTdGF0ZW1lbnR9IG9iamVjdFxyXG4gICAgICAgICAqIC0gUGFyYW1ldGVyaXplZCBRdWVyeSBge3RleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gb2JqZWN0XHJcbiAgICAgICAgICogLSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8dmFsdWV8ZnVuY3Rpb259IFt2YWx1ZXNdXHJcbiAgICAgICAgICogUXVlcnkgZm9ybWF0dGluZyBwYXJhbWV0ZXIocyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QsIHRoZSBgdmFsdWVzYCBjYW4gYmU6XHJcbiAgICAgICAgICogLSBhIHNpbmdsZSB2YWx1ZSAtIHRvIHJlcGxhY2UgYWxsIGAkMWAgb2NjdXJyZW5jZXNcclxuICAgICAgICAgKiAtIGFuIGFycmF5IG9mIHZhbHVlcyAtIHRvIHJlcGxhY2UgYWxsIGAkMWAsIGAkMmAsIC4uLiB2YXJpYWJsZXNcclxuICAgICAgICAgKiAtIGFuIG9iamVjdCAtIHRvIGFwcGx5ICRbTmFtZWQgUGFyYW1ldGVyc10gZm9ybWF0dGluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIGEgUHJlcGFyZWQgU3RhdGVtZW50IG9yIGEgUGFyYW1ldGVyaXplZCBRdWVyeSAob3IgdGhlaXIgY2xhc3MgdHlwZXMpLFxyXG4gICAgICAgICAqIGFuZCBgdmFsdWVzYCBpcyBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aXRoaW4gc3VjaCBvYmplY3QsXHJcbiAgICAgICAgICogYXMgYW4gb3ZlcnJpZGUgZm9yIGl0cyBpbnRlcm5hbCBgdmFsdWVzYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlPEFycmF5Pn1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcXVlcnkgcmVzdWx0OlxyXG4gICAgICAgICAqIC0gV2hlbiBubyByb3dzIGFyZSByZXR1cm5lZCwgaXQgcmVzb2x2ZXMgd2l0aCBhbiBlbXB0eSBhcnJheS5cclxuICAgICAgICAgKiAtIFdoZW4gMSBvciBtb3JlIHJvd3MgYXJlIHJldHVybmVkLCBpdCByZXNvbHZlcyB3aXRoIHRoZSBhcnJheSBvZiByb3dzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZVxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNtYW55T3JOb25lIG1hbnlPck5vbmV9LFxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNtYXAgbWFwfSxcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjZWFjaCBlYWNofVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLmFueSA9IGZ1bmN0aW9uIChxdWVyeSwgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoucXVlcnkuY2FsbCh0aGlzLCBxdWVyeSwgdmFsdWVzLCBxdWVyeVJlc3VsdC5hbnkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2UjcmVzdWx0XHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBxdWVyeSB3aXRob3V0IGFueSBleHBlY3RhdGlvbiBmb3IgdGhlIHJldHVybiBkYXRhLCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcclxuICAgICAgICAgKiBvcmlnaW5hbCAkW1Jlc3VsdF0gb2JqZWN0IHdoZW4gc3VjY2Vzc2Z1bC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gcmVjZWl2aW5nIGEgbXVsdGktcXVlcnkgcmVzdWx0LCBvbmx5IHRoZSBsYXN0IHJlc3VsdCBpcyBwcm9jZXNzZWQsIGlnbm9yaW5nIHRoZSByZXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBxdWVyeVxyXG4gICAgICAgICAqIFF1ZXJ5IHRvIGJlIGV4ZWN1dGVkLCB3aGljaCBjYW4gYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6XHJcbiAgICAgICAgICogLSBBIG5vbi1lbXB0eSBxdWVyeSBzdHJpbmdcclxuICAgICAgICAgKiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcXVlcnkgc3RyaW5nIG9yIGFub3RoZXIgZnVuY3Rpb24sIGkuZS4gcmVjdXJzaXZlIHJlc29sdXRpb25cclxuICAgICAgICAgKiAgIGlzIHN1cHBvcnRlZCwgcGFzc2luZyBpbiBgdmFsdWVzYCBhcyBgdGhpc2AsIGFuZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIC0gUHJlcGFyZWQgU3RhdGVtZW50IGB7bmFtZSwgdGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUHJlcGFyZWRTdGF0ZW1lbnR9IG9iamVjdFxyXG4gICAgICAgICAqIC0gUGFyYW1ldGVyaXplZCBRdWVyeSBge3RleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gb2JqZWN0XHJcbiAgICAgICAgICogLSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8dmFsdWV8ZnVuY3Rpb259IFt2YWx1ZXNdXHJcbiAgICAgICAgICogUXVlcnkgZm9ybWF0dGluZyBwYXJhbWV0ZXIocyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QsIHRoZSBgdmFsdWVzYCBjYW4gYmU6XHJcbiAgICAgICAgICogLSBhIHNpbmdsZSB2YWx1ZSAtIHRvIHJlcGxhY2UgYWxsIGAkMWAgb2NjdXJyZW5jZXNcclxuICAgICAgICAgKiAtIGFuIGFycmF5IG9mIHZhbHVlcyAtIHRvIHJlcGxhY2UgYWxsIGAkMWAsIGAkMmAsIC4uLiB2YXJpYWJsZXNcclxuICAgICAgICAgKiAtIGFuIG9iamVjdCAtIHRvIGFwcGx5ICRbTmFtZWQgUGFyYW1ldGVyc10gZm9ybWF0dGluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIGEgUHJlcGFyZWQgU3RhdGVtZW50IG9yIGEgUGFyYW1ldGVyaXplZCBRdWVyeSAob3IgdGhlaXIgY2xhc3MgdHlwZXMpLFxyXG4gICAgICAgICAqIGFuZCBgdmFsdWVzYCBpcyBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aXRoaW4gc3VjaCBvYmplY3QsXHJcbiAgICAgICAgICogYXMgYW4gb3ZlcnJpZGUgZm9yIGl0cyBpbnRlcm5hbCBgdmFsdWVzYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl1cclxuICAgICAgICAgKiBWYWx1ZS10cmFuc2Zvcm1hdGlvbiBjYWxsYmFjaywgdG8gYWxsb3cgaW4tbGluZSB2YWx1ZSBjaGFuZ2UuXHJcbiAgICAgICAgICogV2hlbiBzcGVjaWZpZWQsIHRoZSByZXR1cm5lZCB2YWx1ZSByZXBsYWNlcyB0aGUgb3JpZ2luYWwgb25lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHRha2VzIG9ubHkgb25lIHBhcmFtZXRlciAtIHZhbHVlIHJlc29sdmVkIGZyb20gdGhlIHF1ZXJ5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ11cclxuICAgICAgICAgKiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBjYWxsYmFjay5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlfVxyXG4gICAgICAgICAqIEEgcHJvbWlzZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBxdWVyeSByZXN1bHQ6XHJcbiAgICAgICAgICogLSByZXNvbHZlcyB3aXRoIHRoZSBvcmlnaW5hbCAkW1Jlc3VsdF0gb2JqZWN0IChieSBkZWZhdWx0KTtcclxuICAgICAgICAgKiAtIHJlc29sdmVzIHdpdGggdGhlIG5ldyB2YWx1ZSwgaWYgdHJhbnNmb3JtYXRpb24gY2FsbGJhY2sgYGNiYCB3YXMgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHVzZSBvZiB2YWx1ZSB0cmFuc2Zvcm1hdGlvbjpcclxuICAgICAgICAgKiAvLyBkZWxldGluZyByb3dzIGFuZCByZXR1cm5pbmcgdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWRcclxuICAgICAgICAgKiBkYi5yZXN1bHQoJ0RFTEVURSBGUk9NIEV2ZW50cyBXSEVSRSBpZCA9ICQxJywgWzEyM10sIHIgPT4gci5yb3dDb3VudClcclxuICAgICAgICAgKiAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBkYXRhID0gbnVtYmVyIG9mIHJvd3MgdGhhdCB3ZXJlIGRlbGV0ZWRcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gdXNlIG9mIHZhbHVlIHRyYW5zZm9ybWF0aW9uOlxyXG4gICAgICAgICAqIC8vIGdldHRpbmcgb25seSBjb2x1bW4gZGV0YWlscyBmcm9tIGEgdGFibGVcclxuICAgICAgICAgKiBkYi5yZXN1bHQoJ1NFTEVDVCAqIEZST00gVXNlcnMgTElNSVQgMCcsIG51bGwsIHIgPT4gci5maWVsZHMpXHJcbiAgICAgICAgICogICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gZGF0YSA9IGFycmF5IG9mIGNvbHVtbiBkZXNjcmlwdG9yc1xyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai5yZXN1bHQgPSBmdW5jdGlvbiAocXVlcnksIHZhbHVlcywgY2IsIHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgY29uc3QgdiA9IG9iai5xdWVyeS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMsIHJlc3VsdFF1ZXJ5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybSh2LCBjYiwgdGhpc0FyZyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNtdWx0aVJlc3VsdFxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgbXVsdGktcXVlcnkgc3RyaW5nLCB3aXRob3V0IGFueSBleHBlY3RhdGlvbiBmb3IgdGhlIHJldHVybiBkYXRhLCBhbmQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheVxyXG4gICAgICAgICAqIG9mIHRoZSBvcmlnaW5hbCAkW1Jlc3VsdF0gb2JqZWN0cyB3aGVuIHN1Y2Nlc3NmdWwuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgb3BlcmF0aW9uIGlzIGF0b21pYywgaS5lLiBhbGwgcXVlcmllcyBhcmUgZXhlY3V0ZWQgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHVubGVzcyB0aGVyZSBhcmUgZXhwbGljaXRcclxuICAgICAgICAgKiBgQkVHSU4vQ09NTUlUYCBjb21tYW5kcyBpbmNsdWRlZCBpbiB0aGUgcXVlcnkgc3RyaW5nIHRvIGRpdmlkZSBpdCBpbnRvIG11bHRpcGxlIHRyYW5zYWN0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gcXVlcnlcclxuICAgICAgICAgKiBNdWx0aS1xdWVyeSBzdHJpbmcgdG8gYmUgZXhlY3V0ZWQsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcclxuICAgICAgICAgKiAtIEEgbm9uLWVtcHR5IHN0cmluZyB0aGF0IGNhbiBjb250YWluIGFueSBudW1iZXIgb2YgcXVlcmllc1xyXG4gICAgICAgICAqIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBxdWVyeSBzdHJpbmcgb3IgYW5vdGhlciBmdW5jdGlvbiwgaS5lLiByZWN1cnNpdmUgcmVzb2x1dGlvblxyXG4gICAgICAgICAqICAgaXMgc3VwcG9ydGVkLCBwYXNzaW5nIGluIGB2YWx1ZXNgIGFzIGB0aGlzYCwgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogLSBQcmVwYXJlZCBTdGF0ZW1lbnQgYHtuYW1lLCB0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudH0gb2JqZWN0XHJcbiAgICAgICAgICogLSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IGB7dGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSBvYmplY3RcclxuICAgICAgICAgKiAtIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheXx2YWx1ZXxmdW5jdGlvbn0gW3ZhbHVlc11cclxuICAgICAgICAgKiBRdWVyeSBmb3JtYXR0aW5nIHBhcmFtZXRlcihzKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGBxdWVyeWAgaXMgb2YgdHlwZSBgc3RyaW5nYCBvciBhIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdCwgdGhlIGB2YWx1ZXNgIGNhbiBiZTpcclxuICAgICAgICAgKiAtIGEgc2luZ2xlIHZhbHVlIC0gdG8gcmVwbGFjZSBhbGwgYCQxYCBvY2N1cnJlbmNlc1xyXG4gICAgICAgICAqIC0gYW4gYXJyYXkgb2YgdmFsdWVzIC0gdG8gcmVwbGFjZSBhbGwgYCQxYCwgYCQyYCwgLi4uIHZhcmlhYmxlc1xyXG4gICAgICAgICAqIC0gYW4gb2JqZWN0IC0gdG8gYXBwbHkgJFtOYW1lZCBQYXJhbWV0ZXJzXSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGBxdWVyeWAgaXMgYSBQcmVwYXJlZCBTdGF0ZW1lbnQgb3IgYSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IChvciB0aGVpciBjbGFzcyB0eXBlcyksXHJcbiAgICAgICAgICogYW5kIGB2YWx1ZXNgIGlzIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGl0IGlzIGF1dG9tYXRpY2FsbHkgc2V0IHdpdGhpbiBzdWNoIG9iamVjdCxcclxuICAgICAgICAgKiBhcyBhbiBvdmVycmlkZSBmb3IgaXRzIGludGVybmFsIGB2YWx1ZXNgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2U8ZXh0ZXJuYWw6UmVzdWx0W10+fVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgRGF0YWJhc2UjbXVsdGkgbXVsdGl9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBvYmoubXVsdGlSZXN1bHQgPSBmdW5jdGlvbiAocXVlcnksIHZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnF1ZXJ5LmNhbGwodGhpcywgcXVlcnksIHZhbHVlcywgbXVsdGlSZXN1bHRRdWVyeSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNtdWx0aVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgbXVsdGktcXVlcnkgc3RyaW5nLCB3aXRob3V0IGFueSBleHBlY3RhdGlvbiBmb3IgdGhlIHJldHVybiBkYXRhLCBhbmQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheVxyXG4gICAgICAgICAqIG9mIGFycmF5cyBvZiByb3dzIHdoZW4gc3VjY2Vzc2Z1bC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBvcGVyYXRpb24gaXMgYXRvbWljLCBpLmUuIGFsbCBxdWVyaWVzIGFyZSBleGVjdXRlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgdW5sZXNzIHRoZXJlIGFyZSBleHBsaWNpdFxyXG4gICAgICAgICAqIGBCRUdJTi9DT01NSVRgIGNvbW1hbmRzIGluY2x1ZGVkIGluIHRoZSBxdWVyeSBzdHJpbmcgdG8gZGl2aWRlIGl0IGludG8gbXVsdGlwbGUgdHJhbnNhY3Rpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBxdWVyeVxyXG4gICAgICAgICAqIE11bHRpLXF1ZXJ5IHN0cmluZyB0byBiZSBleGVjdXRlZCwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gICAgICAgICAqIC0gQSBub24tZW1wdHkgc3RyaW5nIHRoYXQgY2FuIGNvbnRhaW4gYW55IG51bWJlciBvZiBxdWVyaWVzXHJcbiAgICAgICAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHF1ZXJ5IHN0cmluZyBvciBhbm90aGVyIGZ1bmN0aW9uLCBpLmUuIHJlY3Vyc2l2ZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICogICBpcyBzdXBwb3J0ZWQsIHBhc3NpbmcgaW4gYHZhbHVlc2AgYXMgYHRoaXNgLCBhbmQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAgICAgKiAtIFBhcmFtZXRlcml6ZWQgUXVlcnkgYHt0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnl9IG9iamVjdFxyXG4gICAgICAgICAqIC0ge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fHZhbHVlfGZ1bmN0aW9ufSBbdmFsdWVzXVxyXG4gICAgICAgICAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVyKHMpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LCB0aGUgYHZhbHVlc2AgY2FuIGJlOlxyXG4gICAgICAgICAqIC0gYSBzaW5nbGUgdmFsdWUgLSB0byByZXBsYWNlIGFsbCBgJDFgIG9jY3VycmVuY2VzXHJcbiAgICAgICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgICAgICogLSBhbiBvYmplY3QgLSB0byBhcHBseSAkW05hbWVkIFBhcmFtZXRlcnNdIGZvcm1hdHRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAgICAgKiBhbmQgYHZhbHVlc2AgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgd2l0aGluIHN1Y2ggb2JqZWN0LFxyXG4gICAgICAgICAqIGFzIGFuIG92ZXJyaWRlIGZvciBpdHMgaW50ZXJuYWwgYHZhbHVlc2AuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZTxBcnJheTxBcnJheT4+fVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgRGF0YWJhc2UjbXVsdGlSZXN1bHQgbXVsdGlSZXN1bHR9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gR2V0IGRhdGEgZnJvbSAyIHRhYmxlcyBpbiBhIHNpbmdsZSByZXF1ZXN0OlxyXG4gICAgICAgICAqIGNvbnN0IFt1c2VycywgcHJvZHVjdHNdID0gYXdhaXQgZGIubXVsdGkoJ1NFTEVDVCAqIEZST00gdXNlcnM7U0VMRUNUICogRlJPTSBwcm9kdWN0cycpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLm11bHRpID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5xdWVyeS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMsIG11bHRpUmVzdWx0UXVlcnkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IGRhdGEubWFwKGEgPT4gYS5yb3dzKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNzdHJlYW1cclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBDdXN0b20gZGF0YSBzdHJlYW1pbmcsIHdpdGggdGhlIGhlbHAgb2YgJFtwZy1xdWVyeS1zdHJlYW1dLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgZG9lc24ndCB3b3JrIHdpdGggdGhlICRbTmF0aXZlIEJpbmRpbmdzXSwgYW5kIGlmIG9wdGlvbiBgcGdOYXRpdmVgXHJcbiAgICAgICAgICogaXMgc2V0LCBpdCB3aWxsIHJlamVjdCB3aXRoIGBTdHJlYW1pbmcgZG9lc24ndCB3b3JrIHdpdGggTmF0aXZlIEJpbmRpbmdzLmBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UXVlcnlTdHJlYW19IHFzXHJcbiAgICAgICAgICogU3RyZWFtIG9iamVjdCBvZiB0eXBlICRbUXVlcnlTdHJlYW1dLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtEYXRhYmFzZS5zdHJlYW1Jbml0Q0J9IGluaXRDQlxyXG4gICAgICAgICAqIFN0cmVhbSBpbml0aWFsaXphdGlvbiBjYWxsYmFjay5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IGlzIGludm9rZWQgd2l0aCB0aGUgc2FtZSBgdGhpc2AgY29udGV4dCBhcyB0aGUgY2FsbGluZyBtZXRob2QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBSZXN1bHQgb2YgdGhlIHN0cmVhbWluZyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBPbmNlIHRoZSBzdHJlYW1pbmcgaGFzIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSwgdGhlIG1ldGhvZCByZXNvbHZlcyB3aXRoXHJcbiAgICAgICAgICogYHtwcm9jZXNzZWQsIGR1cmF0aW9ufWA6XHJcbiAgICAgICAgICogLSBgcHJvY2Vzc2VkYCAtIHRvdGFsIG51bWJlciBvZiByb3dzIHByb2Nlc3NlZDtcclxuICAgICAgICAgKiAtIGBkdXJhdGlvbmAgLSBzdHJlYW1pbmcgZHVyYXRpb24sIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBvc3NpYmxlIHJlamVjdGlvbnMgbWVzc2FnZXM6XHJcbiAgICAgICAgICogLSBgSW52YWxpZCBvciBtaXNzaW5nIHN0cmVhbSBvYmplY3QuYFxyXG4gICAgICAgICAqIC0gYEludmFsaWQgc3RyZWFtIHN0YXRlLmBcclxuICAgICAgICAgKiAtIGBJbnZhbGlkIG9yIG1pc3Npbmcgc3RyZWFtIGluaXRpYWxpemF0aW9uIGNhbGxiYWNrLmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBvYmouc3RyZWFtID0gZnVuY3Rpb24gKHFzLCBpbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoucXVlcnkuY2FsbCh0aGlzLCBxcywgaW5pdCwgc3RyZWFtUXVlcnkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2UjZnVuY1xyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgZGF0YWJhc2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGFibGUsIGFiYnJldmlhdGluZyB0aGUgZnVsbCBzeW50YXhcclxuICAgICAgICAgKiBvZiBgcXVlcnkoJ1NFTEVDVCAqIEZST00gJDE6YWxpYXMoJDI6Y3N2KScsIFtmdW5jTmFtZSwgdmFsdWVzXSwgcXJtKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWVcclxuICAgICAgICAgKiBOYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAgICAgKiBXaGVuIGl0IGlzIG5vdCBzYW1lLWNhc2UsIG9yIGNvbnRhaW5zIGV4dGVuZGVkIHN5bWJvbHMsIGl0IGlzIGRvdWJsZS1xdW90ZWQsIGFzIHBlciB0aGUgYDphbGlhc2AgZmlsdGVyLFxyXG4gICAgICAgICAqIHdoaWNoIGFsc28gc3VwcG9ydHMgYC5gLCB0byBhdXRvLXNwbGl0IGludG8gYSBjb21wb3NpdGUgbmFtZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8dmFsdWV8ZnVuY3Rpb259IFt2YWx1ZXNdXHJcbiAgICAgICAgICogUGFyYW1ldGVycyBmb3IgdGhlIGZ1bmN0aW9uIC0gb25lIHZhbHVlIHwgYXJyYXkgb2YgdmFsdWVzIHwgZnVuY3Rpb24gcmV0dXJuaW5nIHZhbHVlKHMpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtxdWVyeVJlc3VsdH0gW3FybT1xdWVyeVJlc3VsdC5hbnldIC0ge0BsaW5rIHF1ZXJ5UmVzdWx0IFF1ZXJ5IFJlc3VsdCBNYXNrfS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQSBwcm9taXNlIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIG1ldGhvZCB7QGxpbmsgRGF0YWJhc2UjcXVlcnkgcXVlcnl9LCBhY2NvcmRpbmcgdG8gcGFyYW1ldGVyIGBxcm1gLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZVxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNxdWVyeSBxdWVyeX0sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Byb2MgcHJvY31cclxuICAgICAgICAgKi9cclxuICAgICAgICBvYmouZnVuYyA9IGZ1bmN0aW9uIChmdW5jTmFtZSwgdmFsdWVzLCBxcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5xdWVyeS5jYWxsKHRoaXMsIHtlbnRpdHk6IGZ1bmNOYW1lLCB0eXBlOiAnZnVuYyd9LCB2YWx1ZXMsIHFybSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNwcm9jXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBzdG9yZWQgcHJvY2VkdXJlIGJ5IG5hbWUsIGFiYnJldmlhdGluZyB0aGUgZnVsbCBzeW50YXggb2ZcclxuICAgICAgICAgKiBgb25lT3JOb25lKCdDQUxMICQxOmFsaWFzKCQyOmNzdiknLCBbcHJvY05hbWUsIHZhbHVlc10sIGNiLCB0aGlzQXJnKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKk5PVEU6KiogVGhpcyBtZXRob2QgdXNlcyB0aGUgbmV3IGBDQUxMYCBzeW50YXggdGhhdCByZXF1aXJlcyBQb3N0Z3JlU1FMIHYxMSBvciBsYXRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jTmFtZVxyXG4gICAgICAgICAqIE5hbWUgb2YgdGhlIHN0b3JlZCBwcm9jZWR1cmUgdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICogV2hlbiBpdCBpcyBub3Qgc2FtZS1jYXNlLCBvciBjb250YWlucyBleHRlbmRlZCBzeW1ib2xzLCBpdCBpcyBkb3VibGUtcXVvdGVkLCBhcyBwZXIgdGhlIGA6YWxpYXNgIGZpbHRlcixcclxuICAgICAgICAgKiB3aGljaCBhbHNvIHN1cHBvcnRzIGAuYCwgdG8gYXV0by1zcGxpdCBpbnRvIGEgY29tcG9zaXRlIFNRTCBuYW1lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheXx2YWx1ZXxmdW5jdGlvbn0gW3ZhbHVlc11cclxuICAgICAgICAgKiBQYXJhbWV0ZXJzIGZvciB0aGUgcHJvY2VkdXJlIC0gb25lIHZhbHVlIHwgYXJyYXkgb2YgdmFsdWVzIHwgZnVuY3Rpb24gcmV0dXJuaW5nIHZhbHVlKHMpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NiXVxyXG4gICAgICAgICAqIFZhbHVlLXRyYW5zZm9ybWF0aW9uIGNhbGxiYWNrLCB0byBhbGxvdyBpbi1saW5lIHZhbHVlIGNoYW5nZS5cclxuICAgICAgICAgKiBXaGVuIHNwZWNpZmllZCwgdGhlIHJldHVybmVkIHZhbHVlIHJlcGxhY2VzIHRoZSBvcmlnaW5hbCBvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdGFrZXMgb25seSBvbmUgcGFyYW1ldGVyIC0gdmFsdWUgcmVzb2x2ZWQgZnJvbSB0aGUgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXVxyXG4gICAgICAgICAqIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIGNhbGxiYWNrLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAgICAgICAgICogV2hlbiB0aGUgcHJvY2VkdXJlIHRha2VzIG91dHB1dCBwYXJhbWV0ZXJzLCBhIHNpbmdsZSBvYmplY3QgaXMgcmV0dXJuZWQsIHdpdGhcclxuICAgICAgICAgKiBwcm9wZXJ0aWVzIGZvciB0aGUgb3V0cHV0IHZhbHVlcy4gT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIHJlc29sdmVzIHdpdGggYG51bGxgLlxyXG4gICAgICAgICAqIEFuZCBpZiB0aGUgdmFsdWUtdHJhbnNmb3JtYXRpb24gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIGl0IG92ZXJyaWRlcyB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZVxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNmdW5jIGZ1bmN9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLnByb2MgPSBmdW5jdGlvbiAocHJvY05hbWUsIHZhbHVlcywgY2IsIHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgY29uc3QgdiA9IG9iai5xdWVyeS5jYWxsKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eTogcHJvY05hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncHJvYydcclxuICAgICAgICAgICAgfSwgdmFsdWVzLCBxdWVyeVJlc3VsdC5vbmUgfCBxdWVyeVJlc3VsdC5ub25lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybSh2LCBjYiwgdGhpc0FyZyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNtYXBcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IG9mIHJvd3NcclxuICAgICAgICAgKiByZXNvbHZlZCBieSBtZXRob2Qge0BsaW5rIERhdGFiYXNlI2FueSBhbnl9LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QsIHRvIHJlZHVjZSB0aGUgZm9sbG93aW5nIGNvZGU6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIGRiLmFueShxdWVyeSwgdmFsdWVzKVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBkYXRhLm1hcCgocm93LCBpbmRleCwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAgICAgICAvLyByZXR1cm4gYSBuZXcgZWxlbWVudFxyXG4gICAgICAgICAqICAgICAgICAgfSk7XHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiByZWNlaXZpbmcgYSBtdWx0aS1xdWVyeSByZXN1bHQsIG9ubHkgdGhlIGxhc3QgcmVzdWx0IGlzIHByb2Nlc3NlZCwgaWdub3JpbmcgdGhlIHJlc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R9IHF1ZXJ5XHJcbiAgICAgICAgICogUXVlcnkgdG8gYmUgZXhlY3V0ZWQsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcclxuICAgICAgICAgKiAtIEEgbm9uLWVtcHR5IHF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgICAqIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBxdWVyeSBzdHJpbmcgb3IgYW5vdGhlciBmdW5jdGlvbiwgaS5lLiByZWN1cnNpdmUgcmVzb2x1dGlvblxyXG4gICAgICAgICAqICAgaXMgc3VwcG9ydGVkLCBwYXNzaW5nIGluIGB2YWx1ZXNgIGFzIGB0aGlzYCwgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogLSBQcmVwYXJlZCBTdGF0ZW1lbnQgYHtuYW1lLCB0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudH0gb2JqZWN0XHJcbiAgICAgICAgICogLSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IGB7dGV4dCwgdmFsdWVzLCAuLi59YCBvciB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSBvYmplY3RcclxuICAgICAgICAgKiAtIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHthcnJheXx2YWx1ZXxmdW5jdGlvbn0gdmFsdWVzXHJcbiAgICAgICAgICogUXVlcnkgZm9ybWF0dGluZyBwYXJhbWV0ZXIocyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QsIHRoZSBgdmFsdWVzYCBjYW4gYmU6XHJcbiAgICAgICAgICogLSBhIHNpbmdsZSB2YWx1ZSAtIHRvIHJlcGxhY2UgYWxsIGAkMWAgb2NjdXJyZW5jZXNcclxuICAgICAgICAgKiAtIGFuIGFycmF5IG9mIHZhbHVlcyAtIHRvIHJlcGxhY2UgYWxsIGAkMWAsIGAkMmAsIC4uLiB2YXJpYWJsZXNcclxuICAgICAgICAgKiAtIGFuIG9iamVjdCAtIHRvIGFwcGx5ICRbTmFtZWQgUGFyYW1ldGVyc10gZm9ybWF0dGluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBgcXVlcnlgIGlzIGEgUHJlcGFyZWQgU3RhdGVtZW50IG9yIGEgUGFyYW1ldGVyaXplZCBRdWVyeSAob3IgdGhlaXIgY2xhc3MgdHlwZXMpLFxyXG4gICAgICAgICAqIGFuZCBgdmFsdWVzYCBpcyBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aXRoaW4gc3VjaCBvYmplY3QsXHJcbiAgICAgICAgICogYXMgYW4gb3ZlcnJpZGUgZm9yIGl0cyBpbnRlcm5hbCBgdmFsdWVzYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXHJcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgYXJyYXksIHRha2luZyB0aHJlZSBhcmd1bWVudHM6XHJcbiAgICAgICAgICogLSBgcm93YCAtIHRoZSBjdXJyZW50IHJvdyBvYmplY3QgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBhcnJheVxyXG4gICAgICAgICAqIC0gYGluZGV4YCAtIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCByb3cgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBhcnJheVxyXG4gICAgICAgICAqIC0gYGRhdGFgIC0gdGhlIG9yaWdpbmFsIGFycmF5IG9mIHJvd3MgcmVzb2x2ZWQgYnkgbWV0aG9kIHtAbGluayBEYXRhYmFzZSNhbnkgYW55fVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ11cclxuICAgICAgICAgKiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIHRoZSBjYWxsYmFjay5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtleHRlcm5hbDpQcm9taXNlPEFycmF5Pn1cclxuICAgICAgICAgKiBSZXNvbHZlcyB3aXRoIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGZyb20gdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZVxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNhbnkgYW55fSxcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjZWFjaCBlYWNofSxcclxuICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwIEFycmF5Lm1hcH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBkYi5tYXAoJ1NFTEVDVCBpZCBGUk9NIFVzZXJzIFdIRVJFIHN0YXR1cyA9ICQxJywgWydhY3RpdmUnXSwgcm93ID0+IHJvdy5pZClcclxuICAgICAgICAgKiAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBkYXRhID0gYXJyYXkgb2YgYWN0aXZlIHVzZXIgaWQtc1xyXG4gICAgICAgICAqICAgICB9KVxyXG4gICAgICAgICAqICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAvLyBlcnJvclxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBkYi50eCh0ID0+IHtcclxuICAgICAgICAgKiAgICAgcmV0dXJuIHQubWFwKCdTRUxFQ1QgaWQgRlJPTSBVc2VycyBXSEVSRSBzdGF0dXMgPSAkMScsIFsnYWN0aXZlJ10sIHJvdyA9PiB7XHJcbiAgICAgICAgICogICAgICAgIHJldHVybiB0Lm5vbmUoJ1VQREFURSBFdmVudHMgU0VUIGNoZWNrZWQgPSAkMSBXSEVSRSB1c2VySWQgPSAkMicsIFt0cnVlLCByb3cuaWRdKTtcclxuICAgICAgICAgKiAgICAgfSkudGhlbih0LmJhdGNoKTtcclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgKiAgICAgfSlcclxuICAgICAgICAgKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIGVycm9yXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIEJ1aWxkIGEgbGlzdCBvZiBhY3RpdmUgdXNlcnMsIGVhY2ggd2l0aCB0aGUgbGlzdCBvZiB1c2VyIGV2ZW50czpcclxuICAgICAgICAgKiBkYi50YXNrKHQgPT4ge1xyXG4gICAgICAgICAqICAgICByZXR1cm4gdC5tYXAoJ1NFTEVDVCBpZCBGUk9NIFVzZXJzIFdIRVJFIHN0YXR1cyA9ICQxJywgWydhY3RpdmUnXSwgdXNlciA9PiB7XHJcbiAgICAgICAgICogICAgICAgICByZXR1cm4gdC5hbnkoJ1NFTEVDVCAqIEZST00gRXZlbnRzIFdIRVJFIHVzZXJJZCA9ICQxJywgdXNlci5pZClcclxuICAgICAgICAgKiAgICAgICAgICAgICAudGhlbihldmVudHM9PiB7XHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgIHVzZXIuZXZlbnRzID0gZXZlbnRzO1xyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICByZXR1cm4gdXNlcjtcclxuICAgICAgICAgKiAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgKiAgICAgfSkudGhlbih0LmJhdGNoKTtcclxuICAgICAgICAgKiB9KVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgKiAgICAgfSlcclxuICAgICAgICAgKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIGVycm9yXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLm1hcCA9IGZ1bmN0aW9uIChxdWVyeSwgdmFsdWVzLCBjYiwgdGhpc0FyZykge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmFueS5jYWxsKHRoaXMsIHF1ZXJ5LCB2YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IGRhdGEubWFwKGNiLCB0aGlzQXJnKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBEYXRhYmFzZSNlYWNoXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBhcnJheSBlbGVtZW50LCBmb3IgYW4gYXJyYXkgb2Ygcm93cyByZXNvbHZlZCBieSBtZXRob2Qge0BsaW5rIERhdGFiYXNlI2FueSBhbnl9LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gcmVkdWNlIHRoZSBmb2xsb3dpbmcgY29kZTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYGpzXHJcbiAgICAgICAgICogZGIuYW55KHF1ZXJ5LCB2YWx1ZXMpXHJcbiAgICAgICAgICogICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAgZGF0YS5mb3JFYWNoKChyb3csIGluZGV4LCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIHJvd1xyXG4gICAgICAgICAqICAgICAgICAgfSk7XHJcbiAgICAgICAgICogICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHJlY2VpdmluZyBhIG11bHRpLXF1ZXJ5IHJlc3VsdCwgb25seSB0aGUgbGFzdCByZXN1bHQgaXMgcHJvY2Vzc2VkLCBpZ25vcmluZyB0aGUgcmVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gcXVlcnlcclxuICAgICAgICAgKiBRdWVyeSB0byBiZSBleGVjdXRlZCwgd2hpY2ggY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gICAgICAgICAqIC0gQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nXHJcbiAgICAgICAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHF1ZXJ5IHN0cmluZyBvciBhbm90aGVyIGZ1bmN0aW9uLCBpLmUuIHJlY3Vyc2l2ZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICogICBpcyBzdXBwb3J0ZWQsIHBhc3NpbmcgaW4gYHZhbHVlc2AgYXMgYHRoaXNgLCBhbmQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAgICAgKiAtIFByZXBhcmVkIFN0YXRlbWVudCBge25hbWUsIHRleHQsIHZhbHVlcywgLi4ufWAgb3Ige0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3RcclxuICAgICAgICAgKiAtIFBhcmFtZXRlcml6ZWQgUXVlcnkgYHt0ZXh0LCB2YWx1ZXMsIC4uLn1gIG9yIHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnl9IG9iamVjdFxyXG4gICAgICAgICAqIC0ge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fHZhbHVlfGZ1bmN0aW9ufSBbdmFsdWVzXVxyXG4gICAgICAgICAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVyKHMpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LCB0aGUgYHZhbHVlc2AgY2FuIGJlOlxyXG4gICAgICAgICAqIC0gYSBzaW5nbGUgdmFsdWUgLSB0byByZXBsYWNlIGFsbCBgJDFgIG9jY3VycmVuY2VzXHJcbiAgICAgICAgICogLSBhbiBhcnJheSBvZiB2YWx1ZXMgLSB0byByZXBsYWNlIGFsbCBgJDFgLCBgJDJgLCAuLi4gdmFyaWFibGVzXHJcbiAgICAgICAgICogLSBhbiBvYmplY3QgLSB0byBhcHBseSAkW05hbWVkIFBhcmFtZXRlcnNdIGZvcm1hdHRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gYHF1ZXJ5YCBpcyBhIFByZXBhcmVkIFN0YXRlbWVudCBvciBhIFBhcmFtZXRlcml6ZWQgUXVlcnkgKG9yIHRoZWlyIGNsYXNzIHR5cGVzKSxcclxuICAgICAgICAgKiBhbmQgYHZhbHVlc2AgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgd2l0aGluIHN1Y2ggb2JqZWN0LFxyXG4gICAgICAgICAqIGFzIGFuIG92ZXJyaWRlIGZvciBpdHMgaW50ZXJuYWwgYHZhbHVlc2AuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxyXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggcm93LCB0YWtpbmcgdGhyZWUgYXJndW1lbnRzOlxyXG4gICAgICAgICAqIC0gYHJvd2AgLSB0aGUgY3VycmVudCByb3cgb2JqZWN0IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKiAtIGBpbmRleGAgLSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgcm93IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKiAtIGBkYXRhYCAtIHRoZSBhcnJheSBvZiByb3dzIHJlc29sdmVkIGJ5IG1ldGhvZCB7QGxpbmsgRGF0YWJhc2UjYW55IGFueX1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddXHJcbiAgICAgICAgICogVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cclxuICAgICAgICAgKiBSZXNvbHZlcyB3aXRoIHRoZSBvcmlnaW5hbCBhcnJheSBvZiByb3dzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZVxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSNhbnkgYW55fSxcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjbWFwIG1hcH0sXHJcbiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2ggQXJyYXkuZm9yRWFjaH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBkYi5lYWNoKCdTRUxFQ1QgaWQsIGNvZGUsIG5hbWUgRlJPTSBFdmVudHMnLCBbXSwgcm93ID0+IHtcclxuICAgICAgICAgKiAgICAgcm93LmNvZGUgPSBwYXJzZUludChyb3cuY29kZSk7XHJcbiAgICAgICAgICogfSlcclxuICAgICAgICAgKiAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBkYXRhID0gYXJyYXkgb2YgZXZlbnRzLCB3aXRoICdjb2RlJyBjb252ZXJ0ZWQgaW50byBpbnRlZ2VyXHJcbiAgICAgICAgICogICAgIH0pXHJcbiAgICAgICAgICogICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBlcnJvclxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai5lYWNoID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YWx1ZXMsIGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouYW55LmNhbGwodGhpcywgcXVlcnksIHZhbHVlcylcclxuICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChjYiwgdGhpc0FyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIERhdGFiYXNlI3Rhc2tcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYXV0b21hdGljYWxseSBtYW5hZ2VkIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGludm9rZWQgb24gdGhlIHJvb3Qge0BsaW5rIERhdGFiYXNlfSBvYmplY3QsIHRoZSBtZXRob2QgYWxsb2NhdGVzIHRoZSBjb25uZWN0aW9uIGZyb20gdGhlIHBvb2wsXHJcbiAgICAgICAgICogZXhlY3V0ZXMgdGhlIGNhbGxiYWNrLCBhbmQgb25jZSBmaW5pc2hlZCAtIHJlbGVhc2VzIHRoZSBjb25uZWN0aW9uIGJhY2sgdG8gdGhlIHBvb2wuXHJcbiAgICAgICAgICogSG93ZXZlciwgd2hlbiBpbnZva2VkIGluc2lkZSBhbm90aGVyIHRhc2sgb3IgdHJhbnNhY3Rpb24sIHRoZSBtZXRob2QgcmV1c2VzIHRoZSBwYXJlbnQgY29ubmVjdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHdoZW5ldmVyIGV4ZWN1dGluZyBtb3JlIHRoYW4gb25lIHF1ZXJ5IGF0IG9uY2UsIHNvIHRoZSBhbGxvY2F0ZWQgY29ubmVjdGlvblxyXG4gICAgICAgICAqIGlzIHJldXNlZCBiZXR3ZWVuIGFsbCBxdWVyaWVzLCBhbmQgcmVsZWFzZWQgb25seSBhZnRlciB0aGUgdGFzayBoYXMgZmluaXNoZWQgKHNlZSAkW0NoYWluaW5nIFF1ZXJpZXNdKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBvbmUgcGFyYW1ldGVyIC0gZGF0YWJhc2UgcHJvdG9jb2wgKHNhbWUgYXMgYHRoaXNgKSwgZXh0ZW5kZWQgd2l0aCBtZXRob2RzXHJcbiAgICAgICAgICoge0BsaW5rIFRhc2sjYmF0Y2ggYmF0Y2h9LCB7QGxpbmsgVGFzayNwYWdlIHBhZ2V9LCB7QGxpbmsgVGFzayNzZXF1ZW5jZSBzZXF1ZW5jZX0sIHBsdXMgcHJvcGVydHkge0BsaW5rIFRhc2sjY3R4IGN0eH0gLVxyXG4gICAgICAgICAqIHRoZSB0YXNrIGNvbnRleHQgb2JqZWN0LiBTZWUgY2xhc3Mge0BsaW5rIFRhc2t9IGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbCwgYW5kIHByZXN1bWVkIHNraXBwZWQgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gKGBjYmAgcGFyYW1ldGVyKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gaXQgaXMgb2YgdHlwZSBgc3RyaW5nYCBvciBgbnVtYmVyYCwgaXQgaXMgYXNzdW1lZCB0byBiZSBvcHRpb24gYHRhZ2AgcGFzc2VkIGluIGRpcmVjdGx5LiBPdGhlcndpc2UsXHJcbiAgICAgICAgICogaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGggb3B0aW9ucyBhcyBsaXN0ZWQgYmVsb3cuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge30gW29wdGlvbnMudGFnXVxyXG4gICAgICAgICAqIFRyYWNlYWJsZSBjb250ZXh0IGZvciB0aGUgdGFzayAoc2VlICRbdGFnc10pLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcclxuICAgICAgICAgKiBUYXNrIGNhbGxiYWNrIGZ1bmN0aW9uLCB0byByZXR1cm4gdGhlIHJlc3VsdCB0aGF0IHdpbGwgZGV0ZXJtaW5lIGVpdGhlciBzdWNjZXNzIG9yIGZhaWx1cmUgZm9yIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FuIGJlIGVpdGhlciB0aGUgZmlyc3Qgb2YgdGhlIHNlY29uZCBwYXJhbWV0ZXIgcGFzc2VkIGludG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IGFsc28gY2FuIGJlIGFuIEVTNyBgYXN5bmNgIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAgICAgICAgICogQSBwcm9taXNlIG9iamVjdCB3aXRoIHRoZSByZXN1bHQgZnJvbSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlXHJcbiAgICAgICAgICoge0BsaW5rIFRhc2t9LFxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSN0YXNrSWYgdGFza0lmfSxcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjdHggdHh9LFxyXG4gICAgICAgICAqICRbdGFnc10sXHJcbiAgICAgICAgICogJFtDaGFpbmluZyBRdWVyaWVzXVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGRiLnRhc2soJ215LXRhc2snLCB0ID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHQuY3R4ID0gdGFzayBjb250ZXh0IG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICByZXR1cm4gdC5vbmUoJ1NFTEVDVCBpZCBGUk9NIFVzZXJzIFdIRVJFIG5hbWUgPSAkMScsICdKb2huJylcclxuICAgICAgICAgKiAgICAgICAgICAgICAudGhlbih1c2VyID0+IHtcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgcmV0dXJuIHQuYW55KCdTRUxFQ1QgKiBGUk9NIEV2ZW50cyBXSEVSRSB1c2VySWQgPSAkMScsIHVzZXIuaWQpO1xyXG4gICAgICAgICAqICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAqICAgICB9KVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgKiAgICAgICAgIC8vIGRhdGEgPSBhcyByZXR1cm5lZCBmcm9tIHRoZSB0YXNrJ3MgY2FsbGJhY2tcclxuICAgICAgICAgKiAgICAgfSlcclxuICAgICAgICAgKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIGVycm9yXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIHVzaW5nIGFuIEVTNyBzeW50YXggZm9yIHRoZSBjYWxsYmFjazpcclxuICAgICAgICAgKiBkYi50YXNrKCdteS10YXNrJywgYXN5bmMgdCB7XHJcbiAgICAgICAgICogICAgICAgICAvLyB0LmN0eCA9IHRhc2sgY29udGV4dCBvYmplY3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHQub25lKCdTRUxFQ1QgaWQgRlJPTSBVc2VycyBXSEVSRSBuYW1lID0gJDEnLCAnSm9obicpO1xyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuIHQuYW55KCdTRUxFQ1QgKiBGUk9NIEV2ZW50cyBXSEVSRSB1c2VySWQgPSAkMScsIHVzZXIuaWQpO1xyXG4gICAgICAgICAqICAgICB9KVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgKiAgICAgICAgIC8vIGRhdGEgPSBhcyByZXR1cm5lZCBmcm9tIHRoZSB0YXNrJ3MgY2FsbGJhY2tcclxuICAgICAgICAgKiAgICAgfSlcclxuICAgICAgICAgKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIGVycm9yXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb2JqLnRhc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBucG0ucHViVXRpbHMudGFza0FyZ3MoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGFyZ3Mub3B0aW9ucywgWyd0YWcnXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXNrUHJvY2Vzc29yLmNhbGwodGhpcywgYXJncywgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2UjdGFza0lmXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBjb25kaXRpb25hbCB0YXNrIHRoYXQgcmVzdWx0cyBpbiBhbiBhY3R1YWwgbmV3IHtAbGluayBEYXRhYmFzZSN0YXNrIHRhc2t9LCBpZiBlaXRoZXIgY29uZGl0aW9uIGlzIG1ldCBvclxyXG4gICAgICAgICAqIHdoZW4gaXQgaXMgbmVjZXNzYXJ5IChvbiB0aGUgdG9wIGxldmVsKSwgb3IgZWxzZSBpdCByZXVzZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBjb250ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGlzIGBub3QgaW4gdGFzayBvciB0cmFuc2FjdGlvbmAsIHRvIHN0YXJ0IGEgdGFzayBvbmx5IGlmIGN1cnJlbnRseSBub3QgaW5zaWRlIGFub3RoZXIgdGFzayBvciB0cmFuc2FjdGlvbixcclxuICAgICAgICAgKiB3aGljaCBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIHRoZSBmb2xsb3dpbmc6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIGRiLnRhc2tJZih7Y25kOiB0ID0+ICF0LmN0eH0sIGNiID0+IHt9KVxyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgY2FuIGJlIHVzZWZ1bCwgaWYgeW91IHdhbnQgdG8gc2ltcGxpZnkvcmVkdWNlIHRoZSB0YXNrICsgbG9nIGV2ZW50cyBmb290cHJpbnQsIGJ5IGNyZWF0aW5nIG5ldyB0YXNrcyBvbmx5IHdoZW4gbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfE9iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwsIGFuZCBwcmVzdW1lZCBza2lwcGVkIHdoZW4gdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIChgY2JgIHBhcmFtZXRlcikuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIGl0IGlzIG9mIHR5cGUgYHN0cmluZ2Agb3IgYG51bWJlcmAsIGl0IGlzIGFzc3VtZWQgdG8gYmUgb3B0aW9uIGB0YWdgIHBhc3NlZCBpbiBkaXJlY3RseS4gT3RoZXJ3aXNlLFxyXG4gICAgICAgICAqIGl0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMgYXMgbGlzdGVkIGJlbG93LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHt9IFtvcHRpb25zLnRhZ11cclxuICAgICAgICAgKiBUcmFjZWFibGUgY29udGV4dCBmb3IgdGhlIHRhc2svdHJhbnNhY3Rpb24gKHNlZSAkW3RhZ3NdKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxmdW5jdGlvbn0gW29wdGlvbnMuY25kXVxyXG4gICAgICAgICAqIENvbmRpdGlvbiBmb3IgY3JlYXRpbmcgYSAoe0BsaW5rIERhdGFiYXNlI3Rhc2sgdGFza30pLCBpZiBpdCBpcyBtZXQuXHJcbiAgICAgICAgICogSXQgY2FuIGJlIGVpdGhlciBhIHNpbXBsZSBib29sZWFuLCBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHRhc2sgY29udGV4dCBhcyBgdGhpc2AgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBEZWZhdWx0IGNvbmRpdGlvbiAod2hlbiBpdCBpcyBub3Qgc3BlY2lmaWVkKTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYGpzXHJcbiAgICAgICAgICoge2NuZDogdCA9PiAhdC5jdHh9XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxyXG4gICAgICAgICAqIFRhc2sgY2FsbGJhY2sgZnVuY3Rpb24sIHRvIHJldHVybiB0aGUgcmVzdWx0IHRoYXQgd2lsbCBkZXRlcm1pbmUgZWl0aGVyIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBmb3IgdGhlIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYW4gYmUgZWl0aGVyIHRoZSBmaXJzdCBvciB0aGUgc2Vjb25kIHBhcmFtZXRlciBwYXNzZWQgaW50byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgYWxzbyBjYW4gYmUgYW4gRVM3IGBhc3luY2AgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWVcclxuICAgICAgICAgKiB7QGxpbmsgVGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Rhc2sgRGF0YWJhc2UudGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3R4IERhdGFiYXNlLnR4fSxcclxuICAgICAgICAgKiB7QGxpbmsgRGF0YWJhc2UjdHhJZiBEYXRhYmFzZS50eElmfSxcclxuICAgICAgICAgKiB7QGxpbmsgVGFza0NvbnRleHR9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBvYmoudGFza0lmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gbnBtLnB1YlV0aWxzLnRhc2tBcmdzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGFzc2VydChhcmdzLm9wdGlvbnMsIFsndGFnJywgJ2NuZCddKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCBjbmQgPSBhcmdzLm9wdGlvbnMuY25kO1xyXG4gICAgICAgICAgICAgICAgaWYgKCdjbmQnIGluIGFyZ3Mub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNuZCA9IHR5cGVvZiBjbmQgPT09ICdmdW5jdGlvbicgPyBjbmQuY2FsbChvYmosIG9iaikgOiAhIWNuZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY25kID0gIW9iai5jdHg7IC8vIGNyZWF0ZSB0YXNrLCBpZiBpdCBpcyB0aGUgdG9wIGxldmVsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXVzYWJsZSBvbmx5IGlmIGNvbmRpdGlvbiBmYWlscywgYW5kIG5vdCB0b3AtbGV2ZWw6XHJcbiAgICAgICAgICAgICAgICBhcmdzLm9wdGlvbnMucmV1c2FibGUgPSAhY25kICYmICEhb2JqLmN0eDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwLnJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFza1Byb2Nlc3Nvci5jYWxsKHRoaXMsIGFyZ3MsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIERhdGFiYXNlI3R4XHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiBhcyBhIHRyYW5zYWN0aW9uLCB3aXRoIGF1dG9tYXRpY2FsbHkgbWFuYWdlZCBjb25uZWN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBpbnZva2VkIG9uIHRoZSByb290IHtAbGluayBEYXRhYmFzZX0gb2JqZWN0LCB0aGUgbWV0aG9kIGFsbG9jYXRlcyB0aGUgY29ubmVjdGlvbiBmcm9tIHRoZSBwb29sLFxyXG4gICAgICAgICAqIGV4ZWN1dGVzIHRoZSBjYWxsYmFjaywgYW5kIG9uY2UgZmluaXNoZWQgLSByZWxlYXNlcyB0aGUgY29ubmVjdGlvbiBiYWNrIHRvIHRoZSBwb29sLlxyXG4gICAgICAgICAqIEhvd2V2ZXIsIHdoZW4gaW52b2tlZCBpbnNpZGUgYW5vdGhlciB0YXNrIG9yIHRyYW5zYWN0aW9uLCB0aGUgbWV0aG9kIHJldXNlcyB0aGUgcGFyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBIHRyYW5zYWN0aW9uIHdyYXBzIGEgcmVndWxhciB7QGxpbmsgRGF0YWJhc2UjdGFzayB0YXNrfSBpbnRvIGFkZGl0aW9uYWwgcXVlcmllczpcclxuICAgICAgICAgKiAtIGl0IGV4ZWN1dGVzIGBCRUdJTmAganVzdCBiZWZvcmUgaW52b2tpbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgICAgICogLSBpdCBleGVjdXRlcyBgQ09NTUlUYCwgaWYgdGhlIGNhbGxiYWNrIGRpZG4ndCB0aHJvdyBhbnkgZXJyb3Igb3IgcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAgICAgICAqIC0gaXQgZXhlY3V0ZXMgYFJPTExCQUNLYCwgaWYgdGhlIGNhbGxiYWNrIGRpZCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlXHJcbiAgICAgICAgICogLSBpdCBleGVjdXRlcyBjb3JyZXNwb25kaW5nIGBTQVZFUE9JTlRgIGNvbW1hbmRzIHdoZW4gdGhlIG1ldGhvZCBpcyBjYWxsZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggb25lIHBhcmFtZXRlciAtIGRhdGFiYXNlIHByb3RvY29sIChzYW1lIGFzIGB0aGlzYCksIGV4dGVuZGVkIHdpdGggbWV0aG9kc1xyXG4gICAgICAgICAqIHtAbGluayBUYXNrI2JhdGNoIGJhdGNofSwge0BsaW5rIFRhc2sjcGFnZSBwYWdlfSwge0BsaW5rIFRhc2sjc2VxdWVuY2Ugc2VxdWVuY2V9LCBwbHVzIHByb3BlcnR5IHtAbGluayBUYXNrI2N0eCBjdHh9IC1cclxuICAgICAgICAgKiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dCBvYmplY3QuIFNlZSBjbGFzcyB7QGxpbmsgVGFza30gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0cmFuc2FjdGlvbnMgc2hvdWxkIGJlIGNob3NlbiBvdmVyIHRhc2tzIG9ubHkgd2hlcmUgbmVjZXNzYXJ5LCBiZWNhdXNlIHVubGlrZSByZWd1bGFyIHRhc2tzLFxyXG4gICAgICAgICAqIHRyYW5zYWN0aW9ucyBhcmUgYmxvY2tpbmcgb3BlcmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLCBhbmQgcHJlc3VtZWQgc2tpcHBlZCB3aGVuIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiAoYGNiYCBwYXJhbWV0ZXIpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBpdCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGBudW1iZXJgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIG9wdGlvbiBgdGFnYCBwYXNzZWQgaW4gZGlyZWN0bHkuIE90aGVyd2lzZSxcclxuICAgICAgICAgKiBpdCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zIGFzIGxpc3RlZCBiZWxvdy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7fSBbb3B0aW9ucy50YWddXHJcbiAgICAgICAgICogVHJhY2VhYmxlIGNvbnRleHQgZm9yIHRoZSB0cmFuc2FjdGlvbiAoc2VlICRbdGFnc10pLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHt0eE1vZGUuVHJhbnNhY3Rpb25Nb2RlfSBbb3B0aW9ucy5tb2RlXVxyXG4gICAgICAgICAqIFRyYW5zYWN0aW9uIENvbmZpZ3VyYXRpb24gTW9kZSAtIGV4dGVuZHMgdGhlIHRyYW5zYWN0aW9uLW9wZW5pbmcgY29tbWFuZCB3aXRoIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXHJcbiAgICAgICAgICogVHJhbnNhY3Rpb24gY2FsbGJhY2sgZnVuY3Rpb24sIHRvIHJldHVybiB0aGUgcmVzdWx0IHRoYXQgd2lsbCBkZXRlcm1pbmUgZWl0aGVyIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBmb3IgdGhlIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYW4gYmUgZWl0aGVyIHRoZSBmaXJzdCBvZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBwYXNzZWQgaW50byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgYWxzbyBjYW4gYmUgYW4gRVM3IGBhc3luY2AgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWVcclxuICAgICAgICAgKiB7QGxpbmsgVGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Rhc2sgRGF0YWJhc2UudGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Rhc2tJZiBEYXRhYmFzZS50YXNrSWZ9LFxyXG4gICAgICAgICAqIHtAbGluayBUYXNrQ29udGV4dH0sXHJcbiAgICAgICAgICogJFt0YWdzXSxcclxuICAgICAgICAgKiAkW0NoYWluaW5nIFF1ZXJpZXNdXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogZGIudHgoJ215LXRyYW5zYWN0aW9uJywgdCA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyB0LmN0eCA9IHRyYW5zYWN0aW9uIGNvbnRleHQgb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIHJldHVybiB0Lm9uZSgnSU5TRVJUIElOVE8gVXNlcnMobmFtZSwgYWdlKSBWQUxVRVMoJDEsICQyKSBSRVRVUk5JTkcgaWQnLCBbJ01pa2UnLCAyNV0pXHJcbiAgICAgICAgICogICAgICAgICAgICAgLnRoZW4odXNlciA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgIHJldHVybiB0LmJhdGNoKFtcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIHQubm9uZSgnSU5TRVJUIElOVE8gRXZlbnRzKHVzZXJJZCwgbmFtZSkgVkFMVUVTKCQxLCAkMiknLCBbdXNlci5pZCwgJ2NyZWF0ZWQnXSksXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICB0Lm5vbmUoJ0lOU0VSVCBJTlRPIEV2ZW50cyh1c2VySWQsIG5hbWUpIFZBTFVFUygkMSwgJDIpJywgW3VzZXIuaWQsICdsb2dpbiddKVxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgKiAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgKiAgICAgfSlcclxuICAgICAgICAgKiAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICogICAgICAgICAvLyBkYXRhID0gYXMgcmV0dXJuZWQgZnJvbSB0aGUgdHJhbnNhY3Rpb24ncyBjYWxsYmFja1xyXG4gICAgICAgICAqICAgICB9KVxyXG4gICAgICAgICAqICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gZXJyb3JcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gdXNpbmcgYW4gRVM3IHN5bnRheCBmb3IgdGhlIGNhbGxiYWNrOlxyXG4gICAgICAgICAqIGRiLnR4KCdteS10cmFuc2FjdGlvbicsIGFzeW5jIHQge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gdC5jdHggPSB0cmFuc2FjdGlvbiBjb250ZXh0IG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgdC5vbmUoJ0lOU0VSVCBJTlRPIFVzZXJzKG5hbWUsIGFnZSkgVkFMVUVTKCQxLCAkMikgUkVUVVJOSU5HIGlkJywgWydNaWtlJywgMjVdKTtcclxuICAgICAgICAgKiAgICAgICAgIHJldHVybiB0Lm5vbmUoJ0lOU0VSVCBJTlRPIEV2ZW50cyh1c2VySWQsIG5hbWUpIFZBTFVFUygkMSwgJDIpJywgW3VzZXIuaWQsICdjcmVhdGVkJ10pO1xyXG4gICAgICAgICAqICAgICB9KVxyXG4gICAgICAgICAqICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN1Y2Nlc3NcclxuICAgICAgICAgKiAgICAgICAgIC8vIGRhdGEgPSBhcyByZXR1cm5lZCBmcm9tIHRoZSB0cmFuc2FjdGlvbidzIGNhbGxiYWNrXHJcbiAgICAgICAgICogICAgIH0pXHJcbiAgICAgICAgICogICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBlcnJvclxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai50eCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IG5wbS5wdWJVdGlscy50YXNrQXJncyhhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBhc3NlcnQoYXJncy5vcHRpb25zLCBbJ3RhZycsICdtb2RlJ10pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFza1Byb2Nlc3Nvci5jYWxsKHRoaXMsIGFyZ3MsIHRydWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2QgRGF0YWJhc2UjdHhJZlxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIEV4ZWN1dGVzIGEgY29uZGl0aW9uYWwgdHJhbnNhY3Rpb24gdGhhdCByZXN1bHRzIGluIGFuIGFjdHVhbCB0cmFuc2FjdGlvbiAoe0BsaW5rIERhdGFiYXNlI3R4IHR4fSksIGlmIHRoZSBjb25kaXRpb24gaXMgbWV0LFxyXG4gICAgICAgICAqIG9yIGVsc2UgaXQgZXhlY3V0ZXMgYSByZWd1bGFyIHtAbGluayBEYXRhYmFzZSN0YXNrIHRhc2t9LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGlzIGBub3QgaW4gdHJhbnNhY3Rpb25gLCB0byBzdGFydCBhIHRyYW5zYWN0aW9uIG9ubHkgaWYgY3VycmVudGx5IG5vdCBpbiB0cmFuc2FjdGlvbixcclxuICAgICAgICAgKiBvciBlbHNlIHN0YXJ0IGEgdGFzaywgd2hpY2ggaXMgdGhlIHNhbWUgYXMgY2FsbGluZyB0aGUgZm9sbG93aW5nOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBganNcclxuICAgICAgICAgKiBkYi50eElmKHtjbmQ6IHQgPT4gIXQuY3R4IHx8ICF0LmN0eC5pblRyYW5zYWN0aW9ufSwgY2IgPT4ge30pXHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBhdm9pZCAkW05lc3RlZCBUcmFuc2FjdGlvbnNdIC0gc2F2ZXBvaW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLCBhbmQgcHJlc3VtZWQgc2tpcHBlZCB3aGVuIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiAoYGNiYCBwYXJhbWV0ZXIpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiBpdCBpcyBvZiB0eXBlIGBzdHJpbmdgIG9yIGBudW1iZXJgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIG9wdGlvbiBgdGFnYCBwYXNzZWQgaW4gZGlyZWN0bHkuIE90aGVyd2lzZSxcclxuICAgICAgICAgKiBpdCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zIGFzIGxpc3RlZCBiZWxvdy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7fSBbb3B0aW9ucy50YWddXHJcbiAgICAgICAgICogVHJhY2VhYmxlIGNvbnRleHQgZm9yIHRoZSB0YXNrL3RyYW5zYWN0aW9uIChzZWUgJFt0YWdzXSkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3R4TW9kZS5UcmFuc2FjdGlvbk1vZGV9IFtvcHRpb25zLm1vZGVdXHJcbiAgICAgICAgICogVHJhbnNhY3Rpb24gQ29uZmlndXJhdGlvbiBNb2RlIC0gZXh0ZW5kcyB0aGUgdHJhbnNhY3Rpb24tb3BlbmluZyBjb21tYW5kIHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufGZ1bmN0aW9ufSBbb3B0aW9ucy5jbmRdXHJcbiAgICAgICAgICogQ29uZGl0aW9uIGZvciBvcGVuaW5nIGEgdHJhbnNhY3Rpb24gKHtAbGluayBEYXRhYmFzZSN0eCB0eH0pLCBpZiBpdCBpcyBtZXQsIG9yIGEge0BsaW5rIERhdGFiYXNlI3Rhc2sgdGFza30gd2hlbiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXHJcbiAgICAgICAgICogSXQgY2FuIGJlIGVpdGhlciBhIHNpbXBsZSBib29sZWFuLCBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHRhc2svdHggY29udGV4dCBhcyBgdGhpc2AgYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBEZWZhdWx0IGNvbmRpdGlvbiAod2hlbiBpdCBpcyBub3Qgc3BlY2lmaWVkKTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYGpzXHJcbiAgICAgICAgICoge2NuZDogdCA9PiAhdC5jdHggfHwgIXQuY3R4LmluVHJhbnNhY3Rpb259XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58ZnVuY3Rpb259IFtvcHRpb25zLnJldXNhYmxlPWZhbHNlXVxyXG4gICAgICAgICAqIFdoZW4gYGNuZGAgaXMvcmV0dXJucyBmYWxzZSwgcmV1c2UgY29udGV4dCBvZiB0aGUgY3VycmVudCB0YXNrL3RyYW5zYWN0aW9uLCBpZiBvbmUgZXhpc3RzLlxyXG4gICAgICAgICAqIEl0IGNhbiBiZSBlaXRoZXIgYSBzaW1wbGUgYm9vbGVhbiwgb3IgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSB0YXNrL3R4IGNvbnRleHQgYXMgYHRoaXNgXHJcbiAgICAgICAgICogYW5kIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB3aGVuIGBjbmRgIGlzL3JldHVybnMgZmFsc2UsIHRoZSBtZXRob2QgY3JlYXRlcyBhIG5ldyB0YXNrLiBUaGlzIG9wdGlvbiB0ZWxsc1xyXG4gICAgICAgICAqIHRoZSBtZXRob2QgdG8gcmV1c2UgdGhlIGN1cnJlbnQgdGFzay90cmFuc2FjdGlvbiBjb250ZXh0LCBhbmQgbm90IGNyZWF0ZSBhIG5ldyB0YXNrLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGV4ZWN1dGluZyBhZ2FpbnN0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHByb3RvY29sLCBiZWNhdXNlIG9uXHJcbiAgICAgICAgICogdGhhdCBsZXZlbCwgaWYgbm8gdHJhbnNhY3Rpb24gaXMgc3VkZGVubHkgbmVlZGVkLCBhIG5ldyB0YXNrIGJlY29tZXMgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcclxuICAgICAgICAgKiBUcmFuc2FjdGlvbi90YXNrIGNhbGxiYWNrIGZ1bmN0aW9uLCB0byByZXR1cm4gdGhlIHJlc3VsdCB0aGF0IHdpbGwgZGV0ZXJtaW5lIGVpdGhlclxyXG4gICAgICAgICAqIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBmb3IgdGhlIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYW4gYmUgZWl0aGVyIHRoZSBmaXJzdCBvciB0aGUgc2Vjb25kIHBhcmFtZXRlciBwYXNzZWQgaW50byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgYWxzbyBjYW4gYmUgYW4gRVM3IGBhc3luY2AgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAgICAgKiBBIHByb21pc2Ugb2JqZWN0IHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWVcclxuICAgICAgICAgKiB7QGxpbmsgVGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Rhc2sgRGF0YWJhc2UudGFza30sXHJcbiAgICAgICAgICoge0BsaW5rIERhdGFiYXNlI3Rhc2tJZiBEYXRhYmFzZS50YXNrSWZ9LFxyXG4gICAgICAgICAqIHtAbGluayBEYXRhYmFzZSN0eCBEYXRhYmFzZS50eH0sXHJcbiAgICAgICAgICoge0BsaW5rIFRhc2tDb250ZXh0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9iai50eElmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gbnBtLnB1YlV0aWxzLnRhc2tBcmdzKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGFzc2VydChhcmdzLm9wdGlvbnMsIFsndGFnJywgJ21vZGUnLCAnY25kJywgJ3JldXNhYmxlJ10pO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNuZDtcclxuICAgICAgICAgICAgICAgIGlmICgnY25kJyBpbiBhcmdzLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbmQgPSBhcmdzLm9wdGlvbnMuY25kO1xyXG4gICAgICAgICAgICAgICAgICAgIGNuZCA9IHR5cGVvZiBjbmQgPT09ICdmdW5jdGlvbicgPyBjbmQuY2FsbChvYmosIG9iaikgOiAhIWNuZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY25kID0gIW9iai5jdHggfHwgIW9iai5jdHguaW5UcmFuc2FjdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFyZ3Mub3B0aW9ucy5jbmQgPSBjbmQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXVzYWJsZSA9IGFyZ3Mub3B0aW9ucy5yZXVzYWJsZTtcclxuICAgICAgICAgICAgICAgIGFyZ3Mub3B0aW9ucy5yZXVzYWJsZSA9ICFjbmQgJiYgb2JqLmN0eCAmJiB0eXBlb2YgcmV1c2FibGUgPT09ICdmdW5jdGlvbicgPyByZXVzYWJsZS5jYWxsKG9iaiwgb2JqKSA6ICEhcmV1c2FibGU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhc2tQcm9jZXNzb3IuY2FsbCh0aGlzLCBhcmdzLCBhcmdzLm9wdGlvbnMuY25kKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBUYXNrIG1ldGhvZDtcclxuICAgICAgICAvLyBSZXNvbHZlcyB3aXRoIHJlc3VsdCBmcm9tIHRoZSBjYWxsYmFjayBmdW5jdGlvbjtcclxuICAgICAgICBmdW5jdGlvbiB0YXNrUHJvY2Vzc29yKHBhcmFtcywgaXNUWCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuY2IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QobmV3IFR5cGVFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gaXMgcmVxdWlyZWQuJykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLm9wdGlvbnMucmV1c2FibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuJG5wbS50YXNrLmNhbGxiYWNrKG9iai5jdHgsIG9iaiwgcGFyYW1zLmNiLCBjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0YXNrQ3R4ID0gY3R4LmNsb25lKCk7IC8vIHRhc2sgY29udGV4dCBvYmplY3Q7XHJcbiAgICAgICAgICAgIGlmIChpc1RYKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrQ3R4LnR4TGV2ZWwgPSB0YXNrQ3R4LnR4TGV2ZWwgPj0gMCA/ICh0YXNrQ3R4LnR4TGV2ZWwgKyAxKSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFza0N0eC5pblRyYW5zYWN0aW9uID0gdGFza0N0eC50eExldmVsID49IDA7XHJcbiAgICAgICAgICAgIHRhc2tDdHgubGV2ZWwgPSB0YXNrQ3R4LmxldmVsID49IDAgPyAodGFza0N0eC5sZXZlbCArIDEpIDogMDtcclxuICAgICAgICAgICAgdGFza0N0eC5jYiA9IHBhcmFtcy5jYjsgLy8gY2FsbGJhY2sgZnVuY3Rpb247XHJcbiAgICAgICAgICAgIHRhc2tDdHgubW9kZSA9IHBhcmFtcy5vcHRpb25zLm1vZGU7IC8vIHRyYW5zYWN0aW9uIG1vZGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBvYmopIHtcclxuICAgICAgICAgICAgICAgIHRhc2tDdHguY29udGV4dCA9IHRoaXM7IC8vIGNhbGxpbmcgY29udGV4dCBvYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRzayA9IG5ldyBjb25maWcuJG5wbS50YXNrLlRhc2sodGFza0N0eCwgcGFyYW1zLm9wdGlvbnMudGFnLCBpc1RYLCBjb25maWcpO1xyXG4gICAgICAgICAgICB0YXNrQ3R4LnRhc2tDdHggPSB0c2suY3R4O1xyXG4gICAgICAgICAgICBleHRlbmQodGFza0N0eCwgdHNrKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YXNrQ3R4LmRiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXVzZSBleGlzdGluZyBjb25uZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKHRzay5jdHgsICd1c2VDb3VudCcsIHRhc2tDdHguZGIudXNlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgYWRkU2VydmVyVmVyc2lvbih0c2suY3R4LCB0YXNrQ3R4LmRiLmNsaWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLiRucG0udGFzay5leGVjdXRlKHRhc2tDdHgsIHRzaywgaXNUWCwgY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiByZXF1aXJlZDtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy4kbnBtLmNvbm5lY3QucG9vbCh0YXNrQ3R4LCBkYlRoaXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihkYiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFza0N0eC5jb25uZWN0KGRiKTtcclxuICAgICAgICAgICAgICAgICAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodHNrLmN0eCwgJ3VzZUNvdW50JywgZGIudXNlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlcnZlclZlcnNpb24odHNrLmN0eCwgZGIuY2xpZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLiRucG0udGFzay5leGVjdXRlKHRhc2tDdHgsIHRzaywgaXNUWCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrQ3R4LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2tDdHguZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRTZXJ2ZXJWZXJzaW9uKHRhcmdldCwgY2xpZW50KSB7XHJcbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgZWxzZS1jYXNlIGZyb20gY292ZXJhZ2UsIGJlY2F1c2UgaXQgY2FuIG9ubHkgb2NjdXIgd2l0aCBOYXRpdmUgQmluZGluZ3MuXHJcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXHJcbiAgICAgICAgICAgIGlmIChjbGllbnQuc2VydmVyVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKHRhcmdldCwgJ3NlcnZlclZlcnNpb24nLCBjbGllbnQuc2VydmVyVmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGV4dGVuZGluZyB0aGUgcHJvdG9jb2w7XHJcbiAgICAgICAgRXZlbnRzLmV4dGVuZChjdHgub3B0aW9ucywgb2JqLCBjdHguZGMpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLy8gdGhpcyBldmVudCBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBsb3N0IHBoeXNpY2FsbHksXHJcbi8vIHdoaWNoIGNhbm5vdCBiZSB0ZXN0ZWQgYXV0b21hdGljYWxseTsgcmVtb3ZpbmcgZnJvbSBjb3ZlcmFnZTpcclxuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcclxuZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcclxuICAgIC8vIHRoaXMgY2xpZW50IHdhcyBuZXZlciBzZWVuIGJ5IHBnLXByb21pc2UsIHdoaWNoXHJcbiAgICAvLyBjYW4gaGFwcGVuIGlmIGl0IGZhaWxlZCB0byBpbml0aWFsaXplXHJcbiAgICBpZiAoIWVyci5jbGllbnQuJGN0eCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGN0eCA9IGVyci5jbGllbnQuJGN0eDtcclxuICAgIEV2ZW50cy5lcnJvcihjdHgub3B0aW9ucywgZXJyLCB7XHJcbiAgICAgICAgY246IG5wbS51dGlscy5nZXRTYWZlQ29ubmVjdGlvbihjdHguY24pLFxyXG4gICAgICAgIGRjOiBjdHguZGNcclxuICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZyA9PiB7XHJcbiAgICBjb25zdCBucG1Mb2NhbCA9IGNvbmZpZy4kbnBtO1xyXG4gICAgbnBtTG9jYWwuY29ubmVjdCA9IG5wbUxvY2FsLmNvbm5lY3QgfHwgbnBtLmNvbm5lY3QoY29uZmlnKTtcclxuICAgIG5wbUxvY2FsLnF1ZXJ5ID0gbnBtTG9jYWwucXVlcnkgfHwgbnBtLnF1ZXJ5KGNvbmZpZyk7XHJcbiAgICBucG1Mb2NhbC50YXNrID0gbnBtTG9jYWwudGFzayB8fCBucG0udGFzayhjb25maWcpO1xyXG4gICAgcmV0dXJuIERhdGFiYXNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBEYXRhYmFzZS5zdHJlYW1Jbml0Q0JcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFN0cmVhbSBpbml0aWFsaXphdGlvbiBjYWxsYmFjaywgdXNlZCBieSB7QGxpbmsgRGF0YWJhc2Ujc3RyZWFtIERhdGFiYXNlLnN0cmVhbX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6U3RyZWFtfSBzdHJlYW1cclxuICogU3RyZWFtIG9iamVjdCB0byBpbml0aWFsaXplIHN0cmVhbWluZy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgUXVlcnlTdHJlYW0gPSByZXF1aXJlKCdwZy1xdWVyeS1zdHJlYW0nKTtcclxuICogY29uc3QgSlNPTlN0cmVhbSA9IHJlcXVpcmUoJ0pTT05TdHJlYW0nKTtcclxuICpcclxuICogLy8geW91IGNhbiBhbHNvIHVzZSBwZ3AuYXMuZm9ybWF0KHF1ZXJ5LCB2YWx1ZXMsIG9wdGlvbnMpXHJcbiAqIC8vIHRvIGZvcm1hdCBxdWVyaWVzIHByb3Blcmx5LCB2aWEgcGctcHJvbWlzZTtcclxuICogY29uc3QgcXMgPSBuZXcgUXVlcnlTdHJlYW0oJ1NFTEVDVCAqIEZST00gdXNlcnMnKTtcclxuICpcclxuICogZGIuc3RyZWFtKHFzLCBzdHJlYW0gPT4ge1xyXG4gKiAgICAgICAgIC8vIGluaXRpYXRlIHN0cmVhbWluZyBpbnRvIHRoZSBjb25zb2xlOlxyXG4gKiAgICAgICAgIHN0cmVhbS5waXBlKEpTT05TdHJlYW0uc3RyaW5naWZ5KCkpLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xyXG4gKiAgICAgfSlcclxuICogICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdUb3RhbCByb3dzIHByb2Nlc3NlZDonLCBkYXRhLnByb2Nlc3NlZCxcclxuICogICAgICAgICAgICdEdXJhdGlvbiBpbiBtaWxsaXNlY29uZHM6JywgZGF0YS5kdXJhdGlvbik7XHJcbiAqICAgICB9KVxyXG4gKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICogICAgICAgICAvLyBlcnJvcjtcclxuICogICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgU3RyZWFtXHJcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgcGctcG9vbFxyXG4gKiBAYWxpYXMgcGctcG9vbFxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icmlhbmMvbm9kZS1wZy1wb29sXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBleHRlcm5hbCBSZXN1bHRcclxuICogQHNlZSBodHRwczovL25vZGUtcG9zdGdyZXMuY29tL2FwaS9yZXN1bHRcclxuICovXHJcbiJdLCJuYW1lcyI6WyJFdmVudHMiLCJyZXF1aXJlIiwiYXNzZXJ0IiwicmVzdWx0UXVlcnkiLCJtdWx0aVJlc3VsdFF1ZXJ5Iiwic3RyZWFtUXVlcnkiLCJDb25uZWN0aW9uQ29udGV4dCIsIkRhdGFiYXNlUG9vbCIsInF1ZXJ5UmVzdWx0IiwibnBtIiwidXRpbHMiLCJwdWJVdGlscyIsImNvbm5lY3QiLCJxdWVyeSIsInRhc2siLCJ0ZXh0IiwiRGF0YWJhc2UiLCJjbiIsImRjIiwiY29uZmlnIiwiZGJUaGlzIiwiJHAiLCJwcm9taXNlIiwicG9vbENvbm5lY3Rpb24iLCJjb25uZWN0aW9uU3RyaW5nIiwicG9vbCIsInBncCIsInBnIiwiUG9vbCIsImVuZE1ldGhvZCIsImVuZCIsImRlc3Ryb3llZCIsImNiIiwicmVzIiwiY2FsbCIsIiRkZXN0cm95Iiwib24iLCJvbkVycm9yIiwib3B0aW9ucyIsImN0eCIsImNyZWF0ZUNvbnRleHQiLCJjbk9wdGlvbnMiLCJzZWxmIiwidmFsdWVzIiwicXJtIiwiZGIiLCJyZWplY3QiLCJFcnJvciIsInF1ZXJ5RGlzY29ubmVjdGVkIiwiJG5wbSIsImRvbmUiLCJraWxsIiwibG9vc2VRdWVyeSIsImRpc2Nvbm5lY3QiLCJiYXRjaCIsIm9wdCIsInNwZXgiLCJwYWdlIiwic291cmNlIiwic2VxdWVuY2UiLCJjb25uZWN0aW9uIiwiZGlyZWN0IiwidGhlbiIsImNsaWVudCIsImV4dGVuZCIsImRhdGEiLCJjYXRjaCIsImVycm9yIiwiYWRkUmVhZFByb3AiLCJlbmRpbmciLCJ1bnJlZ2lzdGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJyZWdpc3RlciIsInRyYW5zZm9ybSIsInZhbHVlIiwidGhpc0FyZyIsIm9iaiIsIm5vbmUiLCJvbmUiLCJ2IiwibWFueSIsIm9uZU9yTm9uZSIsIm1hbnlPck5vbmUiLCJhbnkiLCJyZXN1bHQiLCJtdWx0aVJlc3VsdCIsIm11bHRpIiwibWFwIiwiYSIsInJvd3MiLCJzdHJlYW0iLCJxcyIsImluaXQiLCJmdW5jIiwiZnVuY05hbWUiLCJlbnRpdHkiLCJ0eXBlIiwicHJvYyIsInByb2NOYW1lIiwiZWFjaCIsImZvckVhY2giLCJhcmdzIiwidGFza0FyZ3MiLCJhcmd1bWVudHMiLCJ0YXNrUHJvY2Vzc29yIiwidGFza0lmIiwiY25kIiwicmV1c2FibGUiLCJlIiwidHgiLCJ0eElmIiwiaW5UcmFuc2FjdGlvbiIsInBhcmFtcyIsImlzVFgiLCJUeXBlRXJyb3IiLCJjYWxsYmFjayIsInRhc2tDdHgiLCJjbG9uZSIsInR4TGV2ZWwiLCJsZXZlbCIsIm1vZGUiLCJjb250ZXh0IiwidHNrIiwiVGFzayIsInRhZyIsInVzZUNvdW50IiwiYWRkU2VydmVyVmVyc2lvbiIsImV4ZWN1dGUiLCJ0YXJnZXQiLCJzZXJ2ZXJWZXJzaW9uIiwiZXJyIiwiJGN0eCIsImdldFNhZmVDb25uZWN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsIm5wbUxvY2FsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/database.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/errors/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/pg-promise/lib/errors/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { QueryResultError, queryResultErrorCode } = __webpack_require__(/*! ./query-result-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/query-result-error.js\");\nconst { PreparedStatementError } = __webpack_require__(/*! ./prepared-statement-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/prepared-statement-error.js\");\nconst { ParameterizedQueryError } = __webpack_require__(/*! ./parameterized-query-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/parameterized-query-error.js\");\nconst { QueryFileError } = __webpack_require__(/*! ./query-file-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/query-file-error.js\");\n/**\r\n * @namespace errors\r\n * @description\r\n * Error types namespace, available as `pgp.errors`, before and after initializing the library.\r\n *\r\n * @property {function} PreparedStatementError\r\n * {@link errors.PreparedStatementError PreparedStatementError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link PreparedStatement}.\r\n *\r\n * @property {function} ParameterizedQueryError\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link ParameterizedQuery}.\r\n *\r\n * @property {function} QueryFileError\r\n * {@link errors.QueryFileError QueryFileError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link QueryFile}.\r\n *\r\n * @property {function} QueryResultError\r\n * {@link errors.QueryResultError QueryResultError} class constructor.\r\n *\r\n * Represents all result-specific errors from query methods.\r\n *\r\n * @property {errors.queryResultErrorCode} queryResultErrorCode\r\n * Error codes `enum` used by class {@link errors.QueryResultError QueryResultError}.\r\n *\r\n */ module.exports = {\n    QueryResultError,\n    queryResultErrorCode,\n    PreparedStatementError,\n    ParameterizedQueryError,\n    QueryFileError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLGdCQUFnQixFQUFFQyxvQkFBb0IsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUN6RCxNQUFNLEVBQUNDLHNCQUFzQixFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU0sRUFBQ0UsdUJBQXVCLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFDMUMsTUFBTSxFQUFDRyxjQUFjLEVBQUMsR0FBR0gsbUJBQU9BLENBQUM7QUFFakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FFREksT0FBT0MsT0FBTyxHQUFHO0lBQ2JQO0lBQ0FDO0lBQ0FFO0lBQ0FDO0lBQ0FDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9lcnJvcnMvaW5kZXguanM/YjE0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1F1ZXJ5UmVzdWx0RXJyb3IsIHF1ZXJ5UmVzdWx0RXJyb3JDb2RlfSA9IHJlcXVpcmUoJy4vcXVlcnktcmVzdWx0LWVycm9yJyk7XHJcbmNvbnN0IHtQcmVwYXJlZFN0YXRlbWVudEVycm9yfSA9IHJlcXVpcmUoJy4vcHJlcGFyZWQtc3RhdGVtZW50LWVycm9yJyk7XHJcbmNvbnN0IHtQYXJhbWV0ZXJpemVkUXVlcnlFcnJvcn0gPSByZXF1aXJlKCcuL3BhcmFtZXRlcml6ZWQtcXVlcnktZXJyb3InKTtcclxuY29uc3Qge1F1ZXJ5RmlsZUVycm9yfSA9IHJlcXVpcmUoJy4vcXVlcnktZmlsZS1lcnJvcicpO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgZXJyb3JzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBFcnJvciB0eXBlcyBuYW1lc3BhY2UsIGF2YWlsYWJsZSBhcyBgcGdwLmVycm9yc2AsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBQcmVwYXJlZFN0YXRlbWVudEVycm9yXHJcbiAqIHtAbGluayBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciBQcmVwYXJlZFN0YXRlbWVudEVycm9yfSBjbGFzcyBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogUmVwcmVzZW50cyBhbGwgZXJyb3JzIHRoYXQgY2FuIGJlIHJlcG9ydGVkIGJ5IGNsYXNzIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudH0uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFBhcmFtZXRlcml6ZWRRdWVyeUVycm9yXHJcbiAqIHtAbGluayBlcnJvcnMuUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3IgUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3J9IGNsYXNzIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFsbCBlcnJvcnMgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgY2xhc3Mge0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFF1ZXJ5RmlsZUVycm9yXHJcbiAqIHtAbGluayBlcnJvcnMuUXVlcnlGaWxlRXJyb3IgUXVlcnlGaWxlRXJyb3J9IGNsYXNzIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFsbCBlcnJvcnMgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgY2xhc3Mge0BsaW5rIFF1ZXJ5RmlsZX0uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFF1ZXJ5UmVzdWx0RXJyb3JcclxuICoge0BsaW5rIGVycm9ycy5RdWVyeVJlc3VsdEVycm9yIFF1ZXJ5UmVzdWx0RXJyb3J9IGNsYXNzIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFsbCByZXN1bHQtc3BlY2lmaWMgZXJyb3JzIGZyb20gcXVlcnkgbWV0aG9kcy5cclxuICpcclxuICogQHByb3BlcnR5IHtlcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGV9IHF1ZXJ5UmVzdWx0RXJyb3JDb2RlXHJcbiAqIEVycm9yIGNvZGVzIGBlbnVtYCB1c2VkIGJ5IGNsYXNzIHtAbGluayBlcnJvcnMuUXVlcnlSZXN1bHRFcnJvciBRdWVyeVJlc3VsdEVycm9yfS5cclxuICpcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFF1ZXJ5UmVzdWx0RXJyb3IsXHJcbiAgICBxdWVyeVJlc3VsdEVycm9yQ29kZSxcclxuICAgIFByZXBhcmVkU3RhdGVtZW50RXJyb3IsXHJcbiAgICBQYXJhbWV0ZXJpemVkUXVlcnlFcnJvcixcclxuICAgIFF1ZXJ5RmlsZUVycm9yXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJRdWVyeVJlc3VsdEVycm9yIiwicXVlcnlSZXN1bHRFcnJvckNvZGUiLCJyZXF1aXJlIiwiUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciIsIlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIiwiUXVlcnlGaWxlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/errors/parameterized-query-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pg-promise/lib/errors/parameterized-query-error.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { QueryFileError } = __webpack_require__(/*! ./query-file-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/query-file-error.js\");\nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @class errors.ParameterizedQueryError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError} class, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors that can be reported by class {@link ParameterizedQuery}, whether it is used\r\n * explicitly or implicitly (via a simple `{text, values}` object).\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `ParameterizedQueryError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {errors.QueryFileError} error\r\n * Internal {@link errors.QueryFileError} object.\r\n *\r\n * It is set only when the source {@link ParameterizedQuery} used a {@link QueryFile} which threw the error.\r\n *\r\n * @property {object} result\r\n * Resulting Parameterized Query object.\r\n *\r\n * @see ParameterizedQuery\r\n */ class ParameterizedQueryError extends Error {\n    constructor(error, pq){\n        const isQueryFileError = error instanceof QueryFileError;\n        const message = isQueryFileError ? \"Failed to initialize 'text' from a QueryFile.\" : error;\n        super(message);\n        this.name = this.constructor.name;\n        if (isQueryFileError) {\n            this.error = error;\n        }\n        this.result = pq;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.ParameterizedQueryError#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ ParameterizedQueryError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), gap2 = npm.utils.messageGap(level + 2), lines = [\n        \"ParameterizedQueryError {\",\n        gap1 + 'message: \"' + this.message + '\"',\n        gap1 + \"result: {\",\n        gap2 + \"text: \" + npm.utils.toJson(this.result.text),\n        gap2 + \"values: \" + npm.utils.toJson(this.result.values),\n        gap1 + \"}\"\n    ];\n    if (this.error) {\n        lines.push(gap1 + \"error: \" + this.error.toString(level + 1));\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(ParameterizedQueryError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    ParameterizedQueryError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3BhcmFtZXRlcml6ZWQtcXVlcnktZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsY0FBYyxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWpDLE1BQU1DLE1BQU07SUFDUkMsSUFBSUYsbUJBQU9BLENBQUM7SUFDWkcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLEdBQ0QsTUFBTUksZ0NBQWdDQztJQUNsQ0MsWUFBWUMsS0FBSyxFQUFFQyxFQUFFLENBQUU7UUFDbkIsTUFBTUMsbUJBQW1CRixpQkFBaUJSO1FBQzFDLE1BQU1XLFVBQVVELG1CQUFtQixrREFBb0RGO1FBQ3ZGLEtBQUssQ0FBQ0c7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNMLFdBQVcsQ0FBQ0ssSUFBSTtRQUNqQyxJQUFJRixrQkFBa0I7WUFDbEIsSUFBSSxDQUFDRixLQUFLLEdBQUdBO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDSyxNQUFNLEdBQUdKO1FBQ2RILE1BQU1RLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNQLFdBQVc7SUFDbEQ7QUFDSjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0RGLHdCQUF3QlUsU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBVUMsS0FBSztJQUN4REEsUUFBUUEsUUFBUSxJQUFJQyxTQUFTRCxTQUFTO0lBQ3RDLE1BQU1FLE9BQU9qQixJQUFJRSxLQUFLLENBQUNnQixVQUFVLENBQUNILFFBQzlCSSxPQUFPbkIsSUFBSUUsS0FBSyxDQUFDZ0IsVUFBVSxDQUFDSCxRQUFRLElBQ3BDSyxPQUFPcEIsSUFBSUUsS0FBSyxDQUFDZ0IsVUFBVSxDQUFDSCxRQUFRLElBQ3BDTSxRQUFRO1FBQ0o7UUFDQUYsT0FBTyxlQUFlLElBQUksQ0FBQ1YsT0FBTyxHQUFHO1FBQ3JDVSxPQUFPO1FBQ1BDLE9BQU8sV0FBV3BCLElBQUlFLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksSUFBSTtRQUNuREgsT0FBTyxhQUFhcEIsSUFBSUUsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQ1gsTUFBTSxDQUFDYSxNQUFNO1FBQ3ZETCxPQUFPO0tBQ1Y7SUFDTCxJQUFJLElBQUksQ0FBQ2IsS0FBSyxFQUFFO1FBQ1plLE1BQU1JLElBQUksQ0FBQ04sT0FBTyxZQUFZLElBQUksQ0FBQ2IsS0FBSyxDQUFDUSxRQUFRLENBQUNDLFFBQVE7SUFDOUQ7SUFDQU0sTUFBTUksSUFBSSxDQUFDUixPQUFPO0lBQ2xCLE9BQU9JLE1BQU1LLElBQUksQ0FBQzFCLElBQUlDLEVBQUUsQ0FBQzBCLEdBQUc7QUFDaEM7QUFFQTNCLElBQUlFLEtBQUssQ0FBQzBCLGFBQWEsQ0FBQ3pCLHlCQUF5QjtJQUM3QyxPQUFPLElBQUksQ0FBQ1csUUFBUTtBQUN4QjtBQUVBZSxPQUFPQyxPQUFPLEdBQUc7SUFBQzNCO0FBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3BhcmFtZXRlcml6ZWQtcXVlcnktZXJyb3IuanM/Yzk2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1F1ZXJ5RmlsZUVycm9yfSA9IHJlcXVpcmUoJy4vcXVlcnktZmlsZS1lcnJvcicpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgb3M6IHJlcXVpcmUoJ29zJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vdXRpbHMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBlcnJvcnMuUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3JcclxuICogQGF1Z21lbnRzIGV4dGVybmFsOkVycm9yXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiB7QGxpbmsgZXJyb3JzLlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIFBhcmFtZXRlcml6ZWRRdWVyeUVycm9yfSBjbGFzcywgYXZhaWxhYmxlIGZyb20gdGhlIHtAbGluayBlcnJvcnN9IG5hbWVzcGFjZS5cclxuICpcclxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIGVycm9ycyB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSBjbGFzcyB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSwgd2hldGhlciBpdCBpcyB1c2VkXHJcbiAqIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSAodmlhIGEgc2ltcGxlIGB7dGV4dCwgdmFsdWVzfWAgb2JqZWN0KS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcclxuICogU3RhbmRhcmQge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSBwcm9wZXJ0eSAtIGVycm9yIHR5cGUgbmFtZSA9IGBQYXJhbWV0ZXJpemVkUXVlcnlFcnJvcmAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YWNrXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgc3RhY2sgdHJhY2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZXJyb3JzLlF1ZXJ5RmlsZUVycm9yfSBlcnJvclxyXG4gKiBJbnRlcm5hbCB7QGxpbmsgZXJyb3JzLlF1ZXJ5RmlsZUVycm9yfSBvYmplY3QuXHJcbiAqXHJcbiAqIEl0IGlzIHNldCBvbmx5IHdoZW4gdGhlIHNvdXJjZSB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSB1c2VkIGEge0BsaW5rIFF1ZXJ5RmlsZX0gd2hpY2ggdGhyZXcgdGhlIGVycm9yLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gcmVzdWx0XHJcbiAqIFJlc3VsdGluZyBQYXJhbWV0ZXJpemVkIFF1ZXJ5IG9iamVjdC5cclxuICpcclxuICogQHNlZSBQYXJhbWV0ZXJpemVkUXVlcnlcclxuICovXHJcbmNsYXNzIFBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHBxKSB7XHJcbiAgICAgICAgY29uc3QgaXNRdWVyeUZpbGVFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgUXVlcnlGaWxlRXJyb3I7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlzUXVlcnlGaWxlRXJyb3IgPyAnRmFpbGVkIHRvIGluaXRpYWxpemUgXFwndGV4dFxcJyBmcm9tIGEgUXVlcnlGaWxlLicgOiBlcnJvcjtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgaWYgKGlzUXVlcnlGaWxlRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3VsdCA9IHBxO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlcnJvcnMuUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3IjdG9TdHJpbmdcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB3ZWxsLWZvcm1hdHRlZCBtdWx0aS1saW5lIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGVycm9yLlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblBhcmFtZXRlcml6ZWRRdWVyeUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChsZXZlbCkge1xyXG4gICAgbGV2ZWwgPSBsZXZlbCA+IDAgPyBwYXJzZUludChsZXZlbCkgOiAwO1xyXG4gICAgY29uc3QgZ2FwMCA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsKSxcclxuICAgICAgICBnYXAxID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwgKyAxKSxcclxuICAgICAgICBnYXAyID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwgKyAyKSxcclxuICAgICAgICBsaW5lcyA9IFtcclxuICAgICAgICAgICAgJ1BhcmFtZXRlcml6ZWRRdWVyeUVycm9yIHsnLFxyXG4gICAgICAgICAgICBnYXAxICsgJ21lc3NhZ2U6IFwiJyArIHRoaXMubWVzc2FnZSArICdcIicsXHJcbiAgICAgICAgICAgIGdhcDEgKyAncmVzdWx0OiB7JyxcclxuICAgICAgICAgICAgZ2FwMiArICd0ZXh0OiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnJlc3VsdC50ZXh0KSxcclxuICAgICAgICAgICAgZ2FwMiArICd2YWx1ZXM6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMucmVzdWx0LnZhbHVlcyksXHJcbiAgICAgICAgICAgIGdhcDEgKyAnfSdcclxuICAgICAgICBdO1xyXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAnZXJyb3I6ICcgKyB0aGlzLmVycm9yLnRvU3RyaW5nKGxldmVsICsgMSkpO1xyXG4gICAgfVxyXG4gICAgbGluZXMucHVzaChnYXAwICsgJ30nKTtcclxuICAgIHJldHVybiBsaW5lcy5qb2luKG5wbS5vcy5FT0wpO1xyXG59O1xyXG5cclxubnBtLnV0aWxzLmFkZEluc3BlY3Rpb24oUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3IsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7UGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3J9O1xyXG4iXSwibmFtZXMiOlsiUXVlcnlGaWxlRXJyb3IiLCJyZXF1aXJlIiwibnBtIiwib3MiLCJ1dGlscyIsIlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVycm9yIiwicHEiLCJpc1F1ZXJ5RmlsZUVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJyZXN1bHQiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwibGV2ZWwiLCJwYXJzZUludCIsImdhcDAiLCJtZXNzYWdlR2FwIiwiZ2FwMSIsImdhcDIiLCJsaW5lcyIsInRvSnNvbiIsInRleHQiLCJ2YWx1ZXMiLCJwdXNoIiwiam9pbiIsIkVPTCIsImFkZEluc3BlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/errors/parameterized-query-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/errors/prepared-statement-error.js":
/*!************************************************************************!*\
  !*** ./node_modules/pg-promise/lib/errors/prepared-statement-error.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { QueryFileError } = __webpack_require__(/*! ./query-file-error */ \"(rsc)/./node_modules/pg-promise/lib/errors/query-file-error.js\");\nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @class errors.PreparedStatementError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.PreparedStatementError PreparedStatementError} class, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors that can be reported by class {@link PreparedStatement}, whether it is used\r\n * explicitly or implicitly (via a simple `{name, text, values}` object).\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `PreparedStatementError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {errors.QueryFileError} error\r\n * Internal {@link errors.QueryFileError} object.\r\n *\r\n * It is set only when the source {@link PreparedStatement} used a {@link QueryFile} which threw the error.\r\n *\r\n * @property {object} result\r\n * Resulting Prepared Statement object.\r\n *\r\n * @see PreparedStatement\r\n */ class PreparedStatementError extends Error {\n    constructor(error, ps){\n        const isQueryFileError = error instanceof QueryFileError;\n        const message = isQueryFileError ? \"Failed to initialize 'text' from a QueryFile.\" : error;\n        super(message);\n        this.name = this.constructor.name;\n        if (isQueryFileError) {\n            this.error = error;\n        }\n        this.result = ps;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.PreparedStatementError#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ PreparedStatementError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), gap2 = npm.utils.messageGap(level + 2), lines = [\n        \"PreparedStatementError {\",\n        gap1 + 'message: \"' + this.message + '\"',\n        gap1 + \"result: {\",\n        gap2 + \"name: \" + npm.utils.toJson(this.result.name),\n        gap2 + \"text: \" + npm.utils.toJson(this.result.text),\n        gap2 + \"values: \" + npm.utils.toJson(this.result.values),\n        gap1 + \"}\"\n    ];\n    if (this.error) {\n        lines.push(gap1 + \"error: \" + this.error.toString(level + 1));\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(PreparedStatementError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    PreparedStatementError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3ByZXBhcmVkLXN0YXRlbWVudC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxjQUFjLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFakMsTUFBTUMsTUFBTTtJQUNSQyxJQUFJRixtQkFBT0EsQ0FBQztJQUNaRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDRCxNQUFNSSwrQkFBK0JDO0lBQ2pDQyxZQUFZQyxLQUFLLEVBQUVDLEVBQUUsQ0FBRTtRQUNuQixNQUFNQyxtQkFBbUJGLGlCQUFpQlI7UUFDMUMsTUFBTVcsVUFBVUQsbUJBQW1CLGtEQUFvREY7UUFDdkYsS0FBSyxDQUFDRztRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0wsV0FBVyxDQUFDSyxJQUFJO1FBQ2pDLElBQUlGLGtCQUFrQjtZQUNsQixJQUFJLENBQUNGLEtBQUssR0FBR0E7UUFDakI7UUFDQSxJQUFJLENBQUNLLE1BQU0sR0FBR0o7UUFDZEgsTUFBTVEsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ1AsV0FBVztJQUNsRDtBQUNKO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDREYsdUJBQXVCVSxTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFVQyxLQUFLO0lBQ3ZEQSxRQUFRQSxRQUFRLElBQUlDLFNBQVNELFNBQVM7SUFDdEMsTUFBTUUsT0FBT2pCLElBQUlFLEtBQUssQ0FBQ2dCLFVBQVUsQ0FBQ0gsUUFDOUJJLE9BQU9uQixJQUFJRSxLQUFLLENBQUNnQixVQUFVLENBQUNILFFBQVEsSUFDcENLLE9BQU9wQixJQUFJRSxLQUFLLENBQUNnQixVQUFVLENBQUNILFFBQVEsSUFDcENNLFFBQVE7UUFDSjtRQUNBRixPQUFPLGVBQWUsSUFBSSxDQUFDVixPQUFPLEdBQUc7UUFDckNVLE9BQU87UUFDUEMsT0FBTyxXQUFXcEIsSUFBSUUsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLElBQUksQ0FBQ1gsTUFBTSxDQUFDRCxJQUFJO1FBQ25EVSxPQUFPLFdBQVdwQixJQUFJRSxLQUFLLENBQUNvQixNQUFNLENBQUMsSUFBSSxDQUFDWCxNQUFNLENBQUNZLElBQUk7UUFDbkRILE9BQU8sYUFBYXBCLElBQUlFLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUNYLE1BQU0sQ0FBQ2EsTUFBTTtRQUN2REwsT0FBTztLQUNWO0lBQ0wsSUFBSSxJQUFJLENBQUNiLEtBQUssRUFBRTtRQUNaZSxNQUFNSSxJQUFJLENBQUNOLE9BQU8sWUFBWSxJQUFJLENBQUNiLEtBQUssQ0FBQ1EsUUFBUSxDQUFDQyxRQUFRO0lBQzlEO0lBQ0FNLE1BQU1JLElBQUksQ0FBQ1IsT0FBTztJQUNsQixPQUFPSSxNQUFNSyxJQUFJLENBQUMxQixJQUFJQyxFQUFFLENBQUMwQixHQUFHO0FBQ2hDO0FBRUEzQixJQUFJRSxLQUFLLENBQUMwQixhQUFhLENBQUN6Qix3QkFBd0I7SUFDNUMsT0FBTyxJQUFJLENBQUNXLFFBQVE7QUFDeEI7QUFFQWUsT0FBT0MsT0FBTyxHQUFHO0lBQUMzQjtBQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2Vycm9ycy9wcmVwYXJlZC1zdGF0ZW1lbnQtZXJyb3IuanM/YmNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1F1ZXJ5RmlsZUVycm9yfSA9IHJlcXVpcmUoJy4vcXVlcnktZmlsZS1lcnJvcicpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgb3M6IHJlcXVpcmUoJ29zJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vdXRpbHMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvclxyXG4gKiBAYXVnbWVudHMgZXh0ZXJuYWw6RXJyb3JcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIHtAbGluayBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciBQcmVwYXJlZFN0YXRlbWVudEVycm9yfSBjbGFzcywgYXZhaWxhYmxlIGZyb20gdGhlIHtAbGluayBlcnJvcnN9IG5hbWVzcGFjZS5cclxuICpcclxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIGVycm9ycyB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSBjbGFzcyB7QGxpbmsgUHJlcGFyZWRTdGF0ZW1lbnR9LCB3aGV0aGVyIGl0IGlzIHVzZWRcclxuICogZXhwbGljaXRseSBvciBpbXBsaWNpdGx5ICh2aWEgYSBzaW1wbGUgYHtuYW1lLCB0ZXh0LCB2YWx1ZXN9YCBvYmplY3QpLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gZXJyb3IgdHlwZSBuYW1lID0gYFByZXBhcmVkU3RhdGVtZW50RXJyb3JgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZVxyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGFja1xyXG4gKiBTdGFuZGFyZCB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9IHByb3BlcnR5IC0gdGhlIHN0YWNrIHRyYWNlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Vycm9ycy5RdWVyeUZpbGVFcnJvcn0gZXJyb3JcclxuICogSW50ZXJuYWwge0BsaW5rIGVycm9ycy5RdWVyeUZpbGVFcnJvcn0gb2JqZWN0LlxyXG4gKlxyXG4gKiBJdCBpcyBzZXQgb25seSB3aGVuIHRoZSBzb3VyY2Uge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSB1c2VkIGEge0BsaW5rIFF1ZXJ5RmlsZX0gd2hpY2ggdGhyZXcgdGhlIGVycm9yLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gcmVzdWx0XHJcbiAqIFJlc3VsdGluZyBQcmVwYXJlZCBTdGF0ZW1lbnQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc2VlIFByZXBhcmVkU3RhdGVtZW50XHJcbiAqL1xyXG5jbGFzcyBQcmVwYXJlZFN0YXRlbWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHBzKSB7XHJcbiAgICAgICAgY29uc3QgaXNRdWVyeUZpbGVFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgUXVlcnlGaWxlRXJyb3I7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlzUXVlcnlGaWxlRXJyb3IgPyAnRmFpbGVkIHRvIGluaXRpYWxpemUgXFwndGV4dFxcJyBmcm9tIGEgUXVlcnlGaWxlLicgOiBlcnJvcjtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgaWYgKGlzUXVlcnlGaWxlRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3VsdCA9IHBzO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciN0b1N0cmluZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHdlbGwtZm9ybWF0dGVkIG11bHRpLWxpbmUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgZXJyb3IuXHJcbiAqXHJcbiAqIEl0IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gd3JpdGluZyB0aGUgb2JqZWN0IGludG8gdGhlIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWw9MF1cclxuICogTmVzdGVkIG91dHB1dCBsZXZlbCwgdG8gcHJvdmlkZSB2aXN1YWwgb2Zmc2V0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcDAgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCksXHJcbiAgICAgICAgZ2FwMSA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSksXHJcbiAgICAgICAgZ2FwMiA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMiksXHJcbiAgICAgICAgbGluZXMgPSBbXHJcbiAgICAgICAgICAgICdQcmVwYXJlZFN0YXRlbWVudEVycm9yIHsnLFxyXG4gICAgICAgICAgICBnYXAxICsgJ21lc3NhZ2U6IFwiJyArIHRoaXMubWVzc2FnZSArICdcIicsXHJcbiAgICAgICAgICAgIGdhcDEgKyAncmVzdWx0OiB7JyxcclxuICAgICAgICAgICAgZ2FwMiArICduYW1lOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnJlc3VsdC5uYW1lKSxcclxuICAgICAgICAgICAgZ2FwMiArICd0ZXh0OiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnJlc3VsdC50ZXh0KSxcclxuICAgICAgICAgICAgZ2FwMiArICd2YWx1ZXM6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMucmVzdWx0LnZhbHVlcyksXHJcbiAgICAgICAgICAgIGdhcDEgKyAnfSdcclxuICAgICAgICBdO1xyXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAnZXJyb3I6ICcgKyB0aGlzLmVycm9yLnRvU3RyaW5nKGxldmVsICsgMSkpO1xyXG4gICAgfVxyXG4gICAgbGluZXMucHVzaChnYXAwICsgJ30nKTtcclxuICAgIHJldHVybiBsaW5lcy5qb2luKG5wbS5vcy5FT0wpO1xyXG59O1xyXG5cclxubnBtLnV0aWxzLmFkZEluc3BlY3Rpb24oUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtQcmVwYXJlZFN0YXRlbWVudEVycm9yfTtcclxuIl0sIm5hbWVzIjpbIlF1ZXJ5RmlsZUVycm9yIiwicmVxdWlyZSIsIm5wbSIsIm9zIiwidXRpbHMiLCJQcmVwYXJlZFN0YXRlbWVudEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVycm9yIiwicHMiLCJpc1F1ZXJ5RmlsZUVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJyZXN1bHQiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwibGV2ZWwiLCJwYXJzZUludCIsImdhcDAiLCJtZXNzYWdlR2FwIiwiZ2FwMSIsImdhcDIiLCJsaW5lcyIsInRvSnNvbiIsInRleHQiLCJ2YWx1ZXMiLCJwdXNoIiwiam9pbiIsIkVPTCIsImFkZEluc3BlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/errors/prepared-statement-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/errors/query-file-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/pg-promise/lib/errors/query-file-error.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    minify: __webpack_require__(/*! pg-minify */ \"(rsc)/./node_modules/pg-minify/lib/index.js\")\n};\n/**\r\n * @class errors.QueryFileError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.QueryFileError QueryFileError} class, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors related to {@link QueryFile}.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `QueryFileError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {string} file\r\n * File path/name that was passed into the {@link QueryFile} constructor.\r\n *\r\n * @property {object} options\r\n * Set of options that was used by the {@link QueryFile} object.\r\n *\r\n * @property {SQLParsingError} error\r\n * Internal $[SQLParsingError] object.\r\n *\r\n * It is set only when the error was thrown by $[pg-minify] while parsing the SQL file.\r\n *\r\n * @see QueryFile\r\n *\r\n */ class QueryFileError extends Error {\n    constructor(error, qf){\n        const isSqlError = error instanceof npm.minify.SQLParsingError;\n        const message = isSqlError ? \"Failed to parse the SQL.\" : error.message;\n        super(message);\n        this.name = this.constructor.name;\n        if (isSqlError) {\n            this.error = error;\n        }\n        this.file = qf.file;\n        this.options = qf.options;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.QueryFileError#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ QueryFileError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        \"QueryFileError {\",\n        gap1 + 'message: \"' + this.message + '\"',\n        gap1 + \"options: \" + npm.utils.toJson(this.options),\n        gap1 + 'file: \"' + this.file + '\"'\n    ];\n    if (this.error) {\n        lines.push(gap1 + \"error: \" + this.error.toString(level + 1));\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(QueryFileError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    QueryFileError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3F1ZXJ5LWZpbGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU1BLE1BQU07SUFDUkMsSUFBSUMsbUJBQU9BLENBQUM7SUFDWkMsT0FBT0QsbUJBQU9BLENBQUM7SUFDZkUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ0QsTUFBTUcsdUJBQXVCQztJQUN6QkMsWUFBWUMsS0FBSyxFQUFFQyxFQUFFLENBQUU7UUFDbkIsTUFBTUMsYUFBYUYsaUJBQWlCUixJQUFJSSxNQUFNLENBQUNPLGVBQWU7UUFDOUQsTUFBTUMsVUFBVUYsYUFBYSw2QkFBNkJGLE1BQU1JLE9BQU87UUFDdkUsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ04sV0FBVyxDQUFDTSxJQUFJO1FBQ2pDLElBQUlILFlBQVk7WUFDWixJQUFJLENBQUNGLEtBQUssR0FBR0E7UUFDakI7UUFDQSxJQUFJLENBQUNNLElBQUksR0FBR0wsR0FBR0ssSUFBSTtRQUNuQixJQUFJLENBQUNDLE9BQU8sR0FBR04sR0FBR00sT0FBTztRQUN6QlQsTUFBTVUsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ1QsV0FBVztJQUNsRDtBQUNKO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDREYsZUFBZVksU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBVUMsS0FBSztJQUMvQ0EsUUFBUUEsUUFBUSxJQUFJQyxTQUFTRCxTQUFTO0lBQ3RDLE1BQU1FLE9BQU9yQixJQUFJRyxLQUFLLENBQUNtQixVQUFVLENBQUNILFFBQzlCSSxPQUFPdkIsSUFBSUcsS0FBSyxDQUFDbUIsVUFBVSxDQUFDSCxRQUFRLElBQ3BDSyxRQUFRO1FBQ0o7UUFDQUQsT0FBTyxlQUFlLElBQUksQ0FBQ1gsT0FBTyxHQUFHO1FBQ3JDVyxPQUFPLGNBQWN2QixJQUFJRyxLQUFLLENBQUNzQixNQUFNLENBQUMsSUFBSSxDQUFDVixPQUFPO1FBQ2xEUSxPQUFPLFlBQVksSUFBSSxDQUFDVCxJQUFJLEdBQUc7S0FDbEM7SUFDTCxJQUFJLElBQUksQ0FBQ04sS0FBSyxFQUFFO1FBQ1pnQixNQUFNRSxJQUFJLENBQUNILE9BQU8sWUFBWSxJQUFJLENBQUNmLEtBQUssQ0FBQ1UsUUFBUSxDQUFDQyxRQUFRO0lBQzlEO0lBQ0FLLE1BQU1FLElBQUksQ0FBQ0wsT0FBTztJQUNsQixPQUFPRyxNQUFNRyxJQUFJLENBQUMzQixJQUFJQyxFQUFFLENBQUMyQixHQUFHO0FBQ2hDO0FBRUE1QixJQUFJRyxLQUFLLENBQUMwQixhQUFhLENBQUN4QixnQkFBZ0I7SUFDcEMsT0FBTyxJQUFJLENBQUNhLFFBQVE7QUFDeEI7QUFFQVksT0FBT0MsT0FBTyxHQUFHO0lBQUMxQjtBQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3F1ZXJ5LWZpbGUtZXJyb3IuanM/MjRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgb3M6IHJlcXVpcmUoJ29zJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vdXRpbHMnKSxcclxuICAgIG1pbmlmeTogcmVxdWlyZSgncGctbWluaWZ5JylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgZXJyb3JzLlF1ZXJ5RmlsZUVycm9yXHJcbiAqIEBhdWdtZW50cyBleHRlcm5hbDpFcnJvclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICoge0BsaW5rIGVycm9ycy5RdWVyeUZpbGVFcnJvciBRdWVyeUZpbGVFcnJvcn0gY2xhc3MsIGF2YWlsYWJsZSBmcm9tIHRoZSB7QGxpbmsgZXJyb3JzfSBuYW1lc3BhY2UuXHJcbiAqXHJcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCBlcnJvcnMgcmVsYXRlZCB0byB7QGxpbmsgUXVlcnlGaWxlfS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcclxuICogU3RhbmRhcmQge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSBwcm9wZXJ0eSAtIGVycm9yIHR5cGUgbmFtZSA9IGBRdWVyeUZpbGVFcnJvcmAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YWNrXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgc3RhY2sgdHJhY2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlXHJcbiAqIEZpbGUgcGF0aC9uYW1lIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSB7QGxpbmsgUXVlcnlGaWxlfSBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogQHByb3BlcnR5IHtvYmplY3R9IG9wdGlvbnNcclxuICogU2V0IG9mIG9wdGlvbnMgdGhhdCB3YXMgdXNlZCBieSB0aGUge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge1NRTFBhcnNpbmdFcnJvcn0gZXJyb3JcclxuICogSW50ZXJuYWwgJFtTUUxQYXJzaW5nRXJyb3JdIG9iamVjdC5cclxuICpcclxuICogSXQgaXMgc2V0IG9ubHkgd2hlbiB0aGUgZXJyb3Igd2FzIHRocm93biBieSAkW3BnLW1pbmlmeV0gd2hpbGUgcGFyc2luZyB0aGUgU1FMIGZpbGUuXHJcbiAqXHJcbiAqIEBzZWUgUXVlcnlGaWxlXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUZpbGVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGVycm9yLCBxZikge1xyXG4gICAgICAgIGNvbnN0IGlzU3FsRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIG5wbS5taW5pZnkuU1FMUGFyc2luZ0Vycm9yO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpc1NxbEVycm9yID8gJ0ZhaWxlZCB0byBwYXJzZSB0aGUgU1FMLicgOiBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBpZiAoaXNTcWxFcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmlsZSA9IHFmLmZpbGU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gcWYub3B0aW9ucztcclxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXJyb3JzLlF1ZXJ5RmlsZUVycm9yI3RvU3RyaW5nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgd2VsbC1mb3JtYXR0ZWQgbXVsdGktbGluZSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBlcnJvci5cclxuICpcclxuICogSXQgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB3cml0aW5nIHRoZSBvYmplY3QgaW50byB0aGUgY29uc29sZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbD0wXVxyXG4gKiBOZXN0ZWQgb3V0cHV0IGxldmVsLCB0byBwcm92aWRlIHZpc3VhbCBvZmZzZXQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5RdWVyeUZpbGVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcDAgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCksXHJcbiAgICAgICAgZ2FwMSA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSksXHJcbiAgICAgICAgbGluZXMgPSBbXHJcbiAgICAgICAgICAgICdRdWVyeUZpbGVFcnJvciB7JyxcclxuICAgICAgICAgICAgZ2FwMSArICdtZXNzYWdlOiBcIicgKyB0aGlzLm1lc3NhZ2UgKyAnXCInLFxyXG4gICAgICAgICAgICBnYXAxICsgJ29wdGlvbnM6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMub3B0aW9ucyksXHJcbiAgICAgICAgICAgIGdhcDEgKyAnZmlsZTogXCInICsgdGhpcy5maWxlICsgJ1wiJ1xyXG4gICAgICAgIF07XHJcbiAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwMSArICdlcnJvcjogJyArIHRoaXMuZXJyb3IudG9TdHJpbmcobGV2ZWwgKyAxKSk7XHJcbiAgICB9XHJcbiAgICBsaW5lcy5wdXNoKGdhcDAgKyAnfScpO1xyXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obnBtLm9zLkVPTCk7XHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkSW5zcGVjdGlvbihRdWVyeUZpbGVFcnJvciwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtRdWVyeUZpbGVFcnJvcn07XHJcbiJdLCJuYW1lcyI6WyJucG0iLCJvcyIsInJlcXVpcmUiLCJ1dGlscyIsIm1pbmlmeSIsIlF1ZXJ5RmlsZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVycm9yIiwicWYiLCJpc1NxbEVycm9yIiwiU1FMUGFyc2luZ0Vycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJmaWxlIiwib3B0aW9ucyIsImNhcHR1cmVTdGFja1RyYWNlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJsZXZlbCIsInBhcnNlSW50IiwiZ2FwMCIsIm1lc3NhZ2VHYXAiLCJnYXAxIiwibGluZXMiLCJ0b0pzb24iLCJwdXNoIiwiam9pbiIsIkVPTCIsImFkZEluc3BlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/errors/query-file-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/errors/query-result-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/pg-promise/lib/errors/query-result-error.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    text: __webpack_require__(/*! ../text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\n/**\r\n * @enum {number}\r\n * @alias errors.queryResultErrorCode\r\n * @readonly\r\n * @description\r\n * `queryResultErrorCode` enumerator, available from the {@link errors} namespace.\r\n *\r\n * Represents an integer code for each type of error supported by type {@link errors.QueryResultError}.\r\n *\r\n * @see {@link errors.QueryResultError}\r\n */ const queryResultErrorCode = {\n    /** No data returned from the query. */ noData: 0,\n    /** No return data was expected. */ notEmpty: 1,\n    /** Multiple rows were not expected. */ multiple: 2\n};\nconst errorMessages = [\n    {\n        name: \"noData\",\n        message: npm.text.noData\n    },\n    {\n        name: \"notEmpty\",\n        message: npm.text.notEmpty\n    },\n    {\n        name: \"multiple\",\n        message: npm.text.multiple\n    }\n];\n/**\r\n * @class errors.QueryResultError\r\n * @augments external:Error\r\n * @description\r\n *\r\n * This error is specified as the rejection reason for all result-specific methods when the result doesn't match\r\n * the expectation, i.e. when a query result doesn't match its Query Result Mask - the value of {@link queryResult}.\r\n *\r\n * The error applies to the result from the following methods: {@link Database#none none},\r\n * {@link Database#one one}, {@link Database#oneOrNone oneOrNone} and {@link Database#many many}.\r\n *\r\n * Supported errors:\r\n *\r\n * - `No return data was expected.`, method {@link Database#none none}\r\n * - `No data returned from the query.`, methods {@link Database#one one} and {@link Database#many many}\r\n * - `Multiple rows were not expected.`, methods {@link Database#one one} and {@link Database#oneOrNone oneOrNone}\r\n *\r\n * Like any other error, this one is notified with through the global event {@link event:error error}.\r\n *\r\n * The type is available from the {@link errors} namespace.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `QueryResultError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {object} result\r\n * The original $[Result] object that was received.\r\n *\r\n * @property {number} received\r\n * Total number of rows received. It is simply the value of `result.rows.length`.\r\n *\r\n * @property {number} code\r\n * Error code - {@link errors.queryResultErrorCode queryResultErrorCode} value.\r\n *\r\n * @property {string} query\r\n * Query that was executed.\r\n *\r\n * Normally, it is the query already formatted with values, if there were any.\r\n * But if you are using initialization option `pgFormatting`, then the query string is before formatting.\r\n *\r\n * @property {*} values\r\n * Values passed in as query parameters. Available only when initialization option `pgFormatting` is used.\r\n * Otherwise, the values are within the pre-formatted `query` string.\r\n *\r\n * @example\r\n *\r\n * const QueryResultError = pgp.errors.QueryResultError;\r\n * const qrec = pgp.errors.queryResultErrorCode;\r\n *\r\n * const initOptions = {\r\n *\r\n *   // pg-promise initialization options...\r\n *\r\n *   error(err, e) {\r\n *       if (err instanceof QueryResultError) {\r\n *           // A query returned unexpected number of records, and thus rejected;\r\n *           \r\n *           // we can check the error code, if we want specifics:\r\n *           if(err.code === qrec.noData) {\r\n *               // expected some data, but received none;\r\n *           }\r\n *\r\n *           // If you write QueryResultError into the console,\r\n *           // you will get a nicely formatted output.\r\n *\r\n *           console.log(err);\r\n *           \r\n *           // See also: err, e.query, e.params, etc.\r\n *       }\r\n *   }\r\n * };\r\n *\r\n * @see\r\n * {@link queryResult}, {@link Database#none none}, {@link Database#one one},\r\n * {@link Database#oneOrNone oneOrNone}, {@link Database#many many}\r\n *\r\n */ class QueryResultError extends Error {\n    constructor(code, result, query, values){\n        const message = errorMessages[code].message;\n        super(message);\n        this.name = this.constructor.name;\n        this.code = code;\n        this.result = result;\n        this.query = query;\n        this.values = values;\n        this.received = result.rows.length;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/**\r\n * @method errors.QueryResultError#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ QueryResultError.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        \"QueryResultError {\",\n        gap1 + \"code: queryResultErrorCode.\" + errorMessages[this.code].name,\n        gap1 + 'message: \"' + this.message + '\"',\n        gap1 + \"received: \" + this.received,\n        gap1 + \"query: \" + (typeof this.query === \"string\" ? '\"' + this.query + '\"' : npm.utils.toJson(this.query))\n    ];\n    if (this.values !== undefined) {\n        lines.push(gap1 + \"values: \" + npm.utils.toJson(this.values));\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(QueryResultError, function() {\n    return this.toString();\n});\nmodule.exports = {\n    QueryResultError,\n    queryResultErrorCode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3F1ZXJ5LXJlc3VsdC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTUEsTUFBTTtJQUNSQyxJQUFJQyxtQkFBT0EsQ0FBQztJQUNaQyxPQUFPRCxtQkFBT0EsQ0FBQztJQUNmRSxNQUFNRixtQkFBT0EsQ0FBQztBQUNsQjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNRyx1QkFBdUI7SUFDekIscUNBQXFDLEdBQ3JDQyxRQUFRO0lBRVIsaUNBQWlDLEdBQ2pDQyxVQUFVO0lBRVYscUNBQXFDLEdBQ3JDQyxVQUFVO0FBQ2Q7QUFFQSxNQUFNQyxnQkFBZ0I7SUFDbEI7UUFBQ0MsTUFBTTtRQUFVQyxTQUFTWCxJQUFJSSxJQUFJLENBQUNFLE1BQU07SUFBQTtJQUN6QztRQUFDSSxNQUFNO1FBQVlDLFNBQVNYLElBQUlJLElBQUksQ0FBQ0csUUFBUTtJQUFBO0lBQzdDO1FBQUNHLE1BQU07UUFBWUMsU0FBU1gsSUFBSUksSUFBSSxDQUFDSSxRQUFRO0lBQUE7Q0FDaEQ7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUZDLEdBQ0QsTUFBTUkseUJBQXlCQztJQUMzQkMsWUFBWUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxDQUFFO1FBQ3JDLE1BQU1QLFVBQVVGLGFBQWEsQ0FBQ00sS0FBSyxDQUFDSixPQUFPO1FBQzNDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNJLFdBQVcsQ0FBQ0osSUFBSTtRQUNqQyxJQUFJLENBQUNLLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFFBQVEsR0FBR0gsT0FBT0ksSUFBSSxDQUFDQyxNQUFNO1FBQ2xDUixNQUFNUyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDUixXQUFXO0lBQ2xEO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNERixpQkFBaUJXLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVVDLEtBQUs7SUFDakRBLFFBQVFBLFFBQVEsSUFBSUMsU0FBU0QsU0FBUztJQUN0QyxNQUFNRSxPQUFPM0IsSUFBSUcsS0FBSyxDQUFDeUIsVUFBVSxDQUFDSCxRQUM5QkksT0FBTzdCLElBQUlHLEtBQUssQ0FBQ3lCLFVBQVUsQ0FBQ0gsUUFBUSxJQUNwQ0ssUUFBUTtRQUNKO1FBQ0FELE9BQU8sZ0NBQWdDcEIsYUFBYSxDQUFDLElBQUksQ0FBQ00sSUFBSSxDQUFDLENBQUNMLElBQUk7UUFDcEVtQixPQUFPLGVBQWUsSUFBSSxDQUFDbEIsT0FBTyxHQUFHO1FBQ3JDa0IsT0FBTyxlQUFlLElBQUksQ0FBQ1YsUUFBUTtRQUNuQ1UsT0FBTyxZQUFhLFFBQU8sSUFBSSxDQUFDWixLQUFLLEtBQUssV0FBVyxNQUFNLElBQUksQ0FBQ0EsS0FBSyxHQUFHLE1BQU1qQixJQUFJRyxLQUFLLENBQUM0QixNQUFNLENBQUMsSUFBSSxDQUFDZCxLQUFLO0tBQzVHO0lBQ0wsSUFBSSxJQUFJLENBQUNDLE1BQU0sS0FBS2MsV0FBVztRQUMzQkYsTUFBTUcsSUFBSSxDQUFDSixPQUFPLGFBQWE3QixJQUFJRyxLQUFLLENBQUM0QixNQUFNLENBQUMsSUFBSSxDQUFDYixNQUFNO0lBQy9EO0lBQ0FZLE1BQU1HLElBQUksQ0FBQ04sT0FBTztJQUNsQixPQUFPRyxNQUFNSSxJQUFJLENBQUNsQyxJQUFJQyxFQUFFLENBQUNrQyxHQUFHO0FBQ2hDO0FBRUFuQyxJQUFJRyxLQUFLLENBQUNpQyxhQUFhLENBQUN4QixrQkFBa0I7SUFDdEMsT0FBTyxJQUFJLENBQUNZLFFBQVE7QUFDeEI7QUFFQWEsT0FBT0MsT0FBTyxHQUFHO0lBQ2IxQjtJQUNBUDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXJyb3JzL3F1ZXJ5LXJlc3VsdC1lcnJvci5qcz81MmFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICBvczogcmVxdWlyZSgnb3MnKSxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuLi91dGlscycpLFxyXG4gICAgdGV4dDogcmVxdWlyZSgnLi4vdGV4dCcpXHJcbn07XHJcblxyXG4vKipcclxuICogQGVudW0ge251bWJlcn1cclxuICogQGFsaWFzIGVycm9ycy5xdWVyeVJlc3VsdEVycm9yQ29kZVxyXG4gKiBAcmVhZG9ubHlcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIGBxdWVyeVJlc3VsdEVycm9yQ29kZWAgZW51bWVyYXRvciwgYXZhaWxhYmxlIGZyb20gdGhlIHtAbGluayBlcnJvcnN9IG5hbWVzcGFjZS5cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpbnRlZ2VyIGNvZGUgZm9yIGVhY2ggdHlwZSBvZiBlcnJvciBzdXBwb3J0ZWQgYnkgdHlwZSB7QGxpbmsgZXJyb3JzLlF1ZXJ5UmVzdWx0RXJyb3J9LlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBlcnJvcnMuUXVlcnlSZXN1bHRFcnJvcn1cclxuICovXHJcbmNvbnN0IHF1ZXJ5UmVzdWx0RXJyb3JDb2RlID0ge1xyXG4gICAgLyoqIE5vIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgcXVlcnkuICovXHJcbiAgICBub0RhdGE6IDAsXHJcblxyXG4gICAgLyoqIE5vIHJldHVybiBkYXRhIHdhcyBleHBlY3RlZC4gKi9cclxuICAgIG5vdEVtcHR5OiAxLFxyXG5cclxuICAgIC8qKiBNdWx0aXBsZSByb3dzIHdlcmUgbm90IGV4cGVjdGVkLiAqL1xyXG4gICAgbXVsdGlwbGU6IDJcclxufTtcclxuXHJcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXHJcbiAgICB7bmFtZTogJ25vRGF0YScsIG1lc3NhZ2U6IG5wbS50ZXh0Lm5vRGF0YX0sXHJcbiAgICB7bmFtZTogJ25vdEVtcHR5JywgbWVzc2FnZTogbnBtLnRleHQubm90RW1wdHl9LFxyXG4gICAge25hbWU6ICdtdWx0aXBsZScsIG1lc3NhZ2U6IG5wbS50ZXh0Lm11bHRpcGxlfVxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBlcnJvcnMuUXVlcnlSZXN1bHRFcnJvclxyXG4gKiBAYXVnbWVudHMgZXh0ZXJuYWw6RXJyb3JcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRoaXMgZXJyb3IgaXMgc3BlY2lmaWVkIGFzIHRoZSByZWplY3Rpb24gcmVhc29uIGZvciBhbGwgcmVzdWx0LXNwZWNpZmljIG1ldGhvZHMgd2hlbiB0aGUgcmVzdWx0IGRvZXNuJ3QgbWF0Y2hcclxuICogdGhlIGV4cGVjdGF0aW9uLCBpLmUuIHdoZW4gYSBxdWVyeSByZXN1bHQgZG9lc24ndCBtYXRjaCBpdHMgUXVlcnkgUmVzdWx0IE1hc2sgLSB0aGUgdmFsdWUgb2Yge0BsaW5rIHF1ZXJ5UmVzdWx0fS5cclxuICpcclxuICogVGhlIGVycm9yIGFwcGxpZXMgdG8gdGhlIHJlc3VsdCBmcm9tIHRoZSBmb2xsb3dpbmcgbWV0aG9kczoge0BsaW5rIERhdGFiYXNlI25vbmUgbm9uZX0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNvbmUgb25lfSwge0BsaW5rIERhdGFiYXNlI29uZU9yTm9uZSBvbmVPck5vbmV9IGFuZCB7QGxpbmsgRGF0YWJhc2UjbWFueSBtYW55fS5cclxuICpcclxuICogU3VwcG9ydGVkIGVycm9yczpcclxuICpcclxuICogLSBgTm8gcmV0dXJuIGRhdGEgd2FzIGV4cGVjdGVkLmAsIG1ldGhvZCB7QGxpbmsgRGF0YWJhc2Ujbm9uZSBub25lfVxyXG4gKiAtIGBObyBkYXRhIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LmAsIG1ldGhvZHMge0BsaW5rIERhdGFiYXNlI29uZSBvbmV9IGFuZCB7QGxpbmsgRGF0YWJhc2UjbWFueSBtYW55fVxyXG4gKiAtIGBNdWx0aXBsZSByb3dzIHdlcmUgbm90IGV4cGVjdGVkLmAsIG1ldGhvZHMge0BsaW5rIERhdGFiYXNlI29uZSBvbmV9IGFuZCB7QGxpbmsgRGF0YWJhc2Ujb25lT3JOb25lIG9uZU9yTm9uZX1cclxuICpcclxuICogTGlrZSBhbnkgb3RoZXIgZXJyb3IsIHRoaXMgb25lIGlzIG5vdGlmaWVkIHdpdGggdGhyb3VnaCB0aGUgZ2xvYmFsIGV2ZW50IHtAbGluayBldmVudDplcnJvciBlcnJvcn0uXHJcbiAqXHJcbiAqIFRoZSB0eXBlIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSB7QGxpbmsgZXJyb3JzfSBuYW1lc3BhY2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSBlcnJvciB0eXBlIG5hbWUgPSBgUXVlcnlSZXN1bHRFcnJvcmAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YWNrXHJcbiAqIFN0YW5kYXJkIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gcHJvcGVydHkgLSB0aGUgc3RhY2sgdHJhY2UuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByZXN1bHRcclxuICogVGhlIG9yaWdpbmFsICRbUmVzdWx0XSBvYmplY3QgdGhhdCB3YXMgcmVjZWl2ZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWNlaXZlZFxyXG4gKiBUb3RhbCBudW1iZXIgb2Ygcm93cyByZWNlaXZlZC4gSXQgaXMgc2ltcGx5IHRoZSB2YWx1ZSBvZiBgcmVzdWx0LnJvd3MubGVuZ3RoYC5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGVcclxuICogRXJyb3IgY29kZSAtIHtAbGluayBlcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGUgcXVlcnlSZXN1bHRFcnJvckNvZGV9IHZhbHVlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcXVlcnlcclxuICogUXVlcnkgdGhhdCB3YXMgZXhlY3V0ZWQuXHJcbiAqXHJcbiAqIE5vcm1hbGx5LCBpdCBpcyB0aGUgcXVlcnkgYWxyZWFkeSBmb3JtYXR0ZWQgd2l0aCB2YWx1ZXMsIGlmIHRoZXJlIHdlcmUgYW55LlxyXG4gKiBCdXQgaWYgeW91IGFyZSB1c2luZyBpbml0aWFsaXphdGlvbiBvcHRpb24gYHBnRm9ybWF0dGluZ2AsIHRoZW4gdGhlIHF1ZXJ5IHN0cmluZyBpcyBiZWZvcmUgZm9ybWF0dGluZy5cclxuICpcclxuICogQHByb3BlcnR5IHsqfSB2YWx1ZXNcclxuICogVmFsdWVzIHBhc3NlZCBpbiBhcyBxdWVyeSBwYXJhbWV0ZXJzLiBBdmFpbGFibGUgb25seSB3aGVuIGluaXRpYWxpemF0aW9uIG9wdGlvbiBgcGdGb3JtYXR0aW5nYCBpcyB1c2VkLlxyXG4gKiBPdGhlcndpc2UsIHRoZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgcHJlLWZvcm1hdHRlZCBgcXVlcnlgIHN0cmluZy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgUXVlcnlSZXN1bHRFcnJvciA9IHBncC5lcnJvcnMuUXVlcnlSZXN1bHRFcnJvcjtcclxuICogY29uc3QgcXJlYyA9IHBncC5lcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGU7XHJcbiAqXHJcbiAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gKlxyXG4gKiAgIC8vIHBnLXByb21pc2UgaW5pdGlhbGl6YXRpb24gb3B0aW9ucy4uLlxyXG4gKlxyXG4gKiAgIGVycm9yKGVyciwgZSkge1xyXG4gKiAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUXVlcnlSZXN1bHRFcnJvcikge1xyXG4gKiAgICAgICAgICAgLy8gQSBxdWVyeSByZXR1cm5lZCB1bmV4cGVjdGVkIG51bWJlciBvZiByZWNvcmRzLCBhbmQgdGh1cyByZWplY3RlZDtcclxuICogICAgICAgICAgIFxyXG4gKiAgICAgICAgICAgLy8gd2UgY2FuIGNoZWNrIHRoZSBlcnJvciBjb2RlLCBpZiB3ZSB3YW50IHNwZWNpZmljczpcclxuICogICAgICAgICAgIGlmKGVyci5jb2RlID09PSBxcmVjLm5vRGF0YSkge1xyXG4gKiAgICAgICAgICAgICAgIC8vIGV4cGVjdGVkIHNvbWUgZGF0YSwgYnV0IHJlY2VpdmVkIG5vbmU7XHJcbiAqICAgICAgICAgICB9XHJcbiAqXHJcbiAqICAgICAgICAgICAvLyBJZiB5b3Ugd3JpdGUgUXVlcnlSZXN1bHRFcnJvciBpbnRvIHRoZSBjb25zb2xlLFxyXG4gKiAgICAgICAgICAgLy8geW91IHdpbGwgZ2V0IGEgbmljZWx5IGZvcm1hdHRlZCBvdXRwdXQuXHJcbiAqXHJcbiAqICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gKiAgICAgICAgICAgXHJcbiAqICAgICAgICAgICAvLyBTZWUgYWxzbzogZXJyLCBlLnF1ZXJ5LCBlLnBhcmFtcywgZXRjLlxyXG4gKiAgICAgICB9XHJcbiAqICAgfVxyXG4gKiB9O1xyXG4gKlxyXG4gKiBAc2VlXHJcbiAqIHtAbGluayBxdWVyeVJlc3VsdH0sIHtAbGluayBEYXRhYmFzZSNub25lIG5vbmV9LCB7QGxpbmsgRGF0YWJhc2Ujb25lIG9uZX0sXHJcbiAqIHtAbGluayBEYXRhYmFzZSNvbmVPck5vbmUgb25lT3JOb25lfSwge0BsaW5rIERhdGFiYXNlI21hbnkgbWFueX1cclxuICpcclxuICovXHJcbmNsYXNzIFF1ZXJ5UmVzdWx0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCByZXN1bHQsIHF1ZXJ5LCB2YWx1ZXMpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JNZXNzYWdlc1tjb2RlXS5tZXNzYWdlO1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICB0aGlzLnJlY2VpdmVkID0gcmVzdWx0LnJvd3MubGVuZ3RoO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBlcnJvcnMuUXVlcnlSZXN1bHRFcnJvciN0b1N0cmluZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHdlbGwtZm9ybWF0dGVkIG11bHRpLWxpbmUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgZXJyb3IuXHJcbiAqXHJcbiAqIEl0IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gd3JpdGluZyB0aGUgb2JqZWN0IGludG8gdGhlIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWw9MF1cclxuICogTmVzdGVkIG91dHB1dCBsZXZlbCwgdG8gcHJvdmlkZSB2aXN1YWwgb2Zmc2V0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuUXVlcnlSZXN1bHRFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcDAgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCksXHJcbiAgICAgICAgZ2FwMSA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSksXHJcbiAgICAgICAgbGluZXMgPSBbXHJcbiAgICAgICAgICAgICdRdWVyeVJlc3VsdEVycm9yIHsnLFxyXG4gICAgICAgICAgICBnYXAxICsgJ2NvZGU6IHF1ZXJ5UmVzdWx0RXJyb3JDb2RlLicgKyBlcnJvck1lc3NhZ2VzW3RoaXMuY29kZV0ubmFtZSxcclxuICAgICAgICAgICAgZ2FwMSArICdtZXNzYWdlOiBcIicgKyB0aGlzLm1lc3NhZ2UgKyAnXCInLFxyXG4gICAgICAgICAgICBnYXAxICsgJ3JlY2VpdmVkOiAnICsgdGhpcy5yZWNlaXZlZCxcclxuICAgICAgICAgICAgZ2FwMSArICdxdWVyeTogJyArICh0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ3N0cmluZycgPyAnXCInICsgdGhpcy5xdWVyeSArICdcIicgOiBucG0udXRpbHMudG9Kc29uKHRoaXMucXVlcnkpKVxyXG4gICAgICAgIF07XHJcbiAgICBpZiAodGhpcy52YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwMSArICd2YWx1ZXM6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMudmFsdWVzKSk7XHJcbiAgICB9XHJcbiAgICBsaW5lcy5wdXNoKGdhcDAgKyAnfScpO1xyXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obnBtLm9zLkVPTCk7XHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkSW5zcGVjdGlvbihRdWVyeVJlc3VsdEVycm9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUXVlcnlSZXN1bHRFcnJvcixcclxuICAgIHF1ZXJ5UmVzdWx0RXJyb3JDb2RlXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJucG0iLCJvcyIsInJlcXVpcmUiLCJ1dGlscyIsInRleHQiLCJxdWVyeVJlc3VsdEVycm9yQ29kZSIsIm5vRGF0YSIsIm5vdEVtcHR5IiwibXVsdGlwbGUiLCJlcnJvck1lc3NhZ2VzIiwibmFtZSIsIm1lc3NhZ2UiLCJRdWVyeVJlc3VsdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJyZXN1bHQiLCJxdWVyeSIsInZhbHVlcyIsInJlY2VpdmVkIiwicm93cyIsImxlbmd0aCIsImNhcHR1cmVTdGFja1RyYWNlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJsZXZlbCIsInBhcnNlSW50IiwiZ2FwMCIsIm1lc3NhZ2VHYXAiLCJnYXAxIiwibGluZXMiLCJ0b0pzb24iLCJ1bmRlZmluZWQiLCJwdXNoIiwiam9pbiIsIkVPTCIsImFkZEluc3BlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/errors/query-result-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/events.js":
/*!***********************************************!*\
  !*** ./node_modules/pg-promise/lib/events.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ColorConsole } = __webpack_require__(/*! ./utils/color */ \"(rsc)/./node_modules/pg-promise/lib/utils/color.js\");\nconst npm = {\n    main: __webpack_require__(/*! ./ */ \"(rsc)/./node_modules/pg-promise/lib/index.js\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/////////////////////////////////\n// Client notification helpers;\nclass Events {\n    /**\r\n     * @event connect\r\n     * @description\r\n     * Global notification of acquiring a new database connection from the connection pool, i.e. a virtual connection.\r\n     *\r\n     * However, for direct calls to method {@link Database#connect Database.connect} with parameter `{direct: true}`,\r\n     * this event represents a physical connection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {external:Client} e.client\r\n     * $[pg.Client] object that represents the connection.\r\n     *\r\n     * @param {*} e.dc\r\n     * Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @param {number} e.useCount\r\n     * Number of times the connection has been previously used, starting with 0, for a freshly\r\n     * allocated physical connection.\r\n     *\r\n     * This parameter is always 0 for direct connections (created by calling {@link Database#connect Database.connect}\r\n     * with parameter `{direct: true}`).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     connect(e) {\r\n     *         const cp = e.client.connectionParameters;\r\n     *         console.log('Connected to database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */ static connect(ctx, client, useCount) {\n        if (typeof ctx.options.connect === \"function\") {\n            try {\n                ctx.options.connect({\n                    client,\n                    dc: ctx.dc,\n                    useCount\n                });\n            } catch (e) {\n                // have to silence errors here;\n                // cannot allow unhandled errors while connecting to the database,\n                // as it will break the connection logic;\n                Events.unexpected(\"connect\", e);\n            }\n        }\n    }\n    /**\r\n     * @event disconnect\r\n     * @description\r\n     * Global notification of releasing a database connection back to the connection pool, i.e. releasing the virtual connection.\r\n     *\r\n     * However, when releasing a direct connection (created by calling {@link Database#connect Database.connect} with parameter\r\n     * `{direct: true}`), this event represents a physical disconnection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {external:Client} e.client - $[pg.Client] object that represents connection with the database.\r\n     *\r\n     * @param {*} e.dc - Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     disconnect(e) {\r\n     *        const cp = e.client.connectionParameters;\r\n     *        console.log('Disconnecting from database:', cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */ static disconnect(ctx, client) {\n        if (typeof ctx.options.disconnect === \"function\") {\n            try {\n                ctx.options.disconnect({\n                    client,\n                    dc: ctx.dc\n                });\n            } catch (e) {\n                // have to silence errors here;\n                // cannot allow unhandled errors while disconnecting from the database,\n                // as it will break the disconnection logic;\n                Events.unexpected(\"disconnect\", e);\n            }\n        }\n    }\n    /**\r\n     * @event query\r\n     * @description\r\n     *\r\n     * Global notification of a query that's about to execute.\r\n     *\r\n     * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n     * will be rejected with that error.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     query(e) {\r\n     *         console.log('QUERY:', e.query);\r\n     *     }\r\n     * };\r\n     */ static query(options, context) {\n        if (typeof options.query === \"function\") {\n            try {\n                options.query(context);\n            } catch (e) {\n                // throwing an error during event 'query'\n                // will result in a reject for the request.\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\n            }\n        }\n    }\n    /**\r\n     * @event receive\r\n     * @description\r\n     * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n     *\r\n     * The event is fired before the data reaches the client, and it serves two purposes:\r\n     *  - Providing selective data logging for debugging;\r\n     *  - Pre-processing data before it reaches the client.\r\n     *\r\n     * **NOTES:**\r\n     * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n     *   validation for regular queries, which is executed right after.\r\n     * - Any data pre-processing needs to be fast here, to avoid performance penalties.\r\n     * - If the event handler throws an error, the original request will be rejected with that error.\r\n     *\r\n     * For methods {@link Database#multi Database.multi} and {@link Database#multiResult Database.multiResult},\r\n     * this event is called for every result that's returned. And for method {@link Database#stream Database.stream},\r\n     * the event occurs for every record.\r\n     *\r\n     * @param {{}} e Event Properties\r\n     *\r\n     * @param {Array<Object>} e.data\r\n     * Array of received objects/rows.\r\n     *\r\n     * If any of those objects are modified during notification, the client will receive the modified data.\r\n     *\r\n     * @param {external:Result} e.result\r\n     * - Original $[Result] object, if the data is from a non-stream query, in which case `data = result.rows`.\r\n     *   For single-query requests, $[Result] object is extended with property `duration` - number of milliseconds\r\n     *   it took to send the query, execute it and get the result back.\r\n     * - It is `undefined` when the data comes from a stream (method {@link Database#stream Database.stream}).\r\n     *\r\n     * @param {EventContext} e.ctx\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * // Example below shows the fastest way to camelize all column names.\r\n     * // NOTE: The example does not do processing for nested JSON objects.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     receive(e) {\r\n     *         camelizeColumns(e.data);\r\n     *     }\r\n     * };\r\n     *\r\n     * function camelizeColumns(data) {\r\n     *     const tmp = data[0];\r\n     *     for (const prop in tmp) {\r\n     *         const camel = pgp.utils.camelize(prop);\r\n     *         if (!(camel in tmp)) {\r\n     *             for (let i = 0; i < data.length; i++) {\r\n     *                 const d = data[i];\r\n     *                 d[camel] = d[prop];\r\n     *                 delete d[prop];\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * }\r\n     */ static receive(options, data, result, ctx) {\n        if (typeof options.receive === \"function\") {\n            try {\n                options.receive({\n                    data,\n                    result,\n                    ctx\n                });\n            } catch (e) {\n                // throwing an error during event 'receive'\n                // will result in a reject for the request.\n                return e instanceof Error ? e : new npm.utils.InternalError(e);\n            }\n        }\n    }\n    /**\r\n     * @event task\r\n     * @description\r\n     * Global notification of a task start / finish events, as executed via\r\n     * {@link Database#task Database.task} or {@link Database#taskIf Database.taskIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     task(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a task->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a task->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */ static task(options, context) {\n        if (typeof options.task === \"function\") {\n            try {\n                options.task(context);\n            } catch (e) {\n                // silencing the error, to avoid breaking the task;\n                Events.unexpected(\"task\", e);\n            }\n        }\n    }\n    /**\r\n     * @event transact\r\n     * @description\r\n     * Global notification of a transaction start / finish events, as executed via {@link Database#tx Database.tx}\r\n     * or {@link Database#txIf Database.txIf}.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     transact(e) {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a transaction->finish event;\r\n     *             console.log('Duration:', e.ctx.duration);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a transaction->start event;\r\n     *             console.log('Start Time:', e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */ static transact(options, context) {\n        if (typeof options.transact === \"function\") {\n            try {\n                options.transact(context);\n            } catch (e) {\n                // silencing the error, to avoid breaking the transaction;\n                Events.unexpected(\"transact\", e);\n            }\n        }\n    }\n    /**\r\n     * @event error\r\n     * @description\r\n     * Global notification of every error encountered by this library.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {*} err\r\n     * The error encountered, of the same value and type as it was reported.\r\n     *\r\n     * @param {EventContext} e\r\n     * Event Context Object.\r\n     *\r\n     * @example\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     error(err, e) {\r\n     *\r\n     *         if (e.cn) {\r\n     *             // this is a connection-related error\r\n     *             // cn = safe connection details passed into the library:\r\n     *             //      if password is present, it is masked by #\r\n     *         }\r\n     *\r\n     *         if (e.query) {\r\n     *             // query string is available\r\n     *             if (e.params) {\r\n     *                 // query parameters are available\r\n     *             }\r\n     *         }\r\n     *\r\n     *         if (e.ctx) {\r\n     *             // occurred inside a task or transaction\r\n     *         }\r\n     *       }\r\n     * };\r\n     *\r\n     */ static error(options, err, context) {\n        if (typeof options.error === \"function\") {\n            try {\n                options.error(err, context);\n            } catch (e) {\n                // have to silence errors here;\n                // throwing unhandled errors while handling an error\n                // notification is simply not acceptable.\n                Events.unexpected(\"error\", e);\n            }\n        }\n    }\n    /**\r\n     * @event extend\r\n     * @description\r\n     * Extends {@link Database} protocol with custom methods and properties.\r\n     *\r\n     * Override this event to extend the existing access layer with your own functions and\r\n     * properties best suited for your application.\r\n     *\r\n     * The extension thus becomes available across all access layers:\r\n     *\r\n     * - Within the root/default database protocol;\r\n     * - Inside transactions, including nested ones;\r\n     * - Inside tasks, including nested ones.\r\n     *\r\n     * All pre-defined methods and properties are read-only, so you will get an error,\r\n     * if you try overriding them.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} obj - Protocol object to be extended.\r\n     *\r\n     * @param {*} dc - Database Context that was used when creating the {@link Database} object.\r\n     *\r\n     * @see $[pg-promise-demo]\r\n     *\r\n     * @example\r\n     *\r\n     * // In the example below we extend the protocol with function `addImage`\r\n     * // that will insert one binary image and resolve with the new record id.\r\n     *\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.addImage = data => {\r\n     *             // adds a new image and resolves with its record id:\r\n     *             return obj.one('INSERT INTO images(data) VALUES($1) RETURNING id', data, a => a.id);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     * @example\r\n     *\r\n     * // It is best to extend the protocol by adding whole entity repositories to it as shown in the following example.\r\n     * // For a comprehensive example see https://github.com/vitaly-t/pg-promise-demo\r\n     *\r\n     * class UsersRepository {\r\n     *     constructor(rep, pgp) {\r\n     *         this.rep = rep;\r\n     *         this.pgp = pgp;\r\n     *     }\r\n     *\r\n     *     add(name) {\r\n     *         return this.rep.one('INSERT INTO users(name) VALUES($1) RETURNING id', name, a => a.id);\r\n     *     }\r\n     *\r\n     *     remove(id) {\r\n     *         return this.rep.none('DELETE FROM users WHERE id = $1', id);\r\n     *     }\r\n     * }\r\n     *\r\n     * // Overriding 'extend' event;\r\n     * const initOptions = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     extend(obj, dc) {\r\n     *         // dc = database context;\r\n     *         obj.users = new UsersRepository(obj, pgp);\r\n     *         // You can set different repositories based on `dc`\r\n     *     }\r\n     * };\r\n     *\r\n     * // Usage example:\r\n     * db.users.add('John', true)\r\n     *     .then(id => {\r\n     *         // user added successfully, id = new user's id\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // failed to add the user;\r\n     *     });\r\n     *\r\n     */ static extend(options, obj, dc) {\n        if (typeof options.extend === \"function\") {\n            try {\n                options.extend.call(obj, obj, dc);\n            } catch (e) {\n                // have to silence errors here;\n                // the result of throwing unhandled errors while\n                // extending the protocol would be unpredictable.\n                Events.unexpected(\"extend\", e);\n            }\n        }\n    }\n    /**\r\n     * @event unexpected\r\n     * @param {string} event - unhandled event name.\r\n     * @param {string|Error} e - unhandled error.\r\n     * @private\r\n     */ static unexpected(event, e) {\n        // If you should ever get here, your app is definitely broken, and you need to fix\n        // your event handler to prevent unhandled errors during event notifications.\n        //\n        // Console output is suppressed when running tests, to avoid polluting test output\n        // with error messages that are intentional and of no value to the test.\n        /* istanbul ignore if */ if (!npm.main.suppressErrors) {\n            const stack = e instanceof Error ? e.stack : new Error().stack;\n            ColorConsole.error(`Unexpected error in '${event}' event handler.\\n${stack}\\n`);\n        }\n    }\n}\nmodule.exports = {\n    Events\n}; /**\r\n * @typedef EventContext\r\n * @description\r\n * This common type is used for the following events: {@link event:query query}, {@link event:receive receive},\r\n * {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n *\r\n * @property {string|object} cn\r\n *\r\n * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n *\r\n * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n *\r\n * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n * can be logged safely, without exposing the password.\r\n *\r\n * @property {*} dc\r\n * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n *\r\n * @property {string|object} query\r\n *\r\n * Query string/object that was passed into the query method. This property is only set during events {@link event:query query},\r\n * {@link event:receive receive} and {@link event:error error} (only when the error is query-related).\r\n *\r\n * @property {external:Client} client\r\n *\r\n * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n * when it is connection-related. Note that sometimes the value may be unset when the connection is lost.\r\n *\r\n * @property {*} params - Formatting parameters for the query.\r\n *\r\n * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n * to the event logging:\r\n * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n * handles the query formatting.\r\n *\r\n * When this parameter is not set, it means one of the two things:\r\n * - there were no parameters passed into the query method;\r\n * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n *\r\n * @property {TaskContext} ctx\r\n * _Task/Transaction Context_ object.\r\n *\r\n * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when they occur\r\n * inside a task or transaction.\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLFlBQVksRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUUvQixNQUFNQyxNQUFNO0lBQ1JDLE1BQU1GLG1CQUFPQSxDQUFDO0lBQ2RHLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ25CO0FBRUEsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixNQUFNSTtJQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUNDLEdBQ0QsT0FBT0MsUUFBUUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRTtRQUNsQyxJQUFJLE9BQU9GLElBQUlHLE9BQU8sQ0FBQ0osT0FBTyxLQUFLLFlBQVk7WUFDM0MsSUFBSTtnQkFDQUMsSUFBSUcsT0FBTyxDQUFDSixPQUFPLENBQUM7b0JBQUNFO29CQUFRRyxJQUFJSixJQUFJSSxFQUFFO29CQUFFRjtnQkFBUTtZQUNyRCxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1IsK0JBQStCO2dCQUMvQixrRUFBa0U7Z0JBQ2xFLHlDQUF5QztnQkFDekNQLE9BQU9RLFVBQVUsQ0FBQyxXQUFXRDtZQUNqQztRQUNKO0lBQ0o7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTRCQyxHQUNELE9BQU9FLFdBQVdQLEdBQUcsRUFBRUMsTUFBTSxFQUFFO1FBQzNCLElBQUksT0FBT0QsSUFBSUcsT0FBTyxDQUFDSSxVQUFVLEtBQUssWUFBWTtZQUM5QyxJQUFJO2dCQUNBUCxJQUFJRyxPQUFPLENBQUNJLFVBQVUsQ0FBQztvQkFBQ047b0JBQVFHLElBQUlKLElBQUlJLEVBQUU7Z0JBQUE7WUFDOUMsRUFBRSxPQUFPQyxHQUFHO2dCQUNSLCtCQUErQjtnQkFDL0IsdUVBQXVFO2dCQUN2RSw0Q0FBNEM7Z0JBQzVDUCxPQUFPUSxVQUFVLENBQUMsY0FBY0Q7WUFDcEM7UUFD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QUFFO1FBQ3hCLGtGQUFrRjtRQUNsRiw2RUFBNkU7UUFDN0UsRUFBRTtRQUNGLGtGQUFrRjtRQUNsRix3RUFBd0U7UUFFeEUsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ1YsSUFBSUMsSUFBSSxDQUFDMkIsY0FBYyxFQUFFO1lBQzFCLE1BQU1DLFFBQVFuQixhQUFhSyxRQUFRTCxFQUFFbUIsS0FBSyxHQUFHLElBQUlkLFFBQVFjLEtBQUs7WUFDOUQvQixhQUFhd0IsS0FBSyxDQUFDLENBQUMscUJBQXFCLEVBQUVLLE1BQU0sa0JBQWtCLEVBQUVFLE1BQU0sRUFBRSxDQUFDO1FBQ2xGO0lBQ0o7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFBQzVCO0FBQU0sR0FFeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdEQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2V2ZW50cy5qcz9jOThkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7Q29sb3JDb25zb2xlfSA9IHJlcXVpcmUoJy4vdXRpbHMvY29sb3InKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIG1haW46IHJlcXVpcmUoJy4vJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpXHJcbn07XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQ2xpZW50IG5vdGlmaWNhdGlvbiBoZWxwZXJzO1xyXG5jbGFzcyBFdmVudHMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IGNvbm5lY3RcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogR2xvYmFsIG5vdGlmaWNhdGlvbiBvZiBhY3F1aXJpbmcgYSBuZXcgZGF0YWJhc2UgY29ubmVjdGlvbiBmcm9tIHRoZSBjb25uZWN0aW9uIHBvb2wsIGkuZS4gYSB2aXJ0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogSG93ZXZlciwgZm9yIGRpcmVjdCBjYWxscyB0byBtZXRob2Qge0BsaW5rIERhdGFiYXNlI2Nvbm5lY3QgRGF0YWJhc2UuY29ubmVjdH0gd2l0aCBwYXJhbWV0ZXIgYHtkaXJlY3Q6IHRydWV9YCxcclxuICAgICAqIHRoaXMgZXZlbnQgcmVwcmVzZW50cyBhIHBoeXNpY2FsIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxpYnJhcnkgd2lsbCBzdXBwcmVzcyBhbnkgZXJyb3IgdGhyb3duIGJ5IHRoZSBoYW5kbGVyIGFuZCB3cml0ZSBpdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e319IGUgRXZlbnQgUHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXh0ZXJuYWw6Q2xpZW50fSBlLmNsaWVudFxyXG4gICAgICogJFtwZy5DbGllbnRdIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBlLmRjXHJcbiAgICAgKiBEYXRhYmFzZSBDb250ZXh0IHRoYXQgd2FzIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgZGF0YWJhc2Ugb2JqZWN0IChzZWUge0BsaW5rIERhdGFiYXNlfSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGUudXNlQ291bnRcclxuICAgICAqIE51bWJlciBvZiB0aW1lcyB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBwcmV2aW91c2x5IHVzZWQsIHN0YXJ0aW5nIHdpdGggMCwgZm9yIGEgZnJlc2hseVxyXG4gICAgICogYWxsb2NhdGVkIHBoeXNpY2FsIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBwYXJhbWV0ZXIgaXMgYWx3YXlzIDAgZm9yIGRpcmVjdCBjb25uZWN0aW9ucyAoY3JlYXRlZCBieSBjYWxsaW5nIHtAbGluayBEYXRhYmFzZSNjb25uZWN0IERhdGFiYXNlLmNvbm5lY3R9XHJcbiAgICAgKiB3aXRoIHBhcmFtZXRlciBge2RpcmVjdDogdHJ1ZX1gKS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgY29ubmVjdChlKSB7XHJcbiAgICAgKiAgICAgICAgIGNvbnN0IGNwID0gZS5jbGllbnQuY29ubmVjdGlvblBhcmFtZXRlcnM7XHJcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gZGF0YWJhc2U6JywgY3AuZGF0YWJhc2UpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiB9O1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29ubmVjdChjdHgsIGNsaWVudCwgdXNlQ291bnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGN0eC5vcHRpb25zLmNvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGN0eC5vcHRpb25zLmNvbm5lY3Qoe2NsaWVudCwgZGM6IGN0eC5kYywgdXNlQ291bnR9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBzaWxlbmNlIGVycm9ycyBoZXJlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IGFsbG93IHVuaGFuZGxlZCBlcnJvcnMgd2hpbGUgY29ubmVjdGluZyB0byB0aGUgZGF0YWJhc2UsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCB3aWxsIGJyZWFrIHRoZSBjb25uZWN0aW9uIGxvZ2ljO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRzLnVuZXhwZWN0ZWQoJ2Nvbm5lY3QnLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBldmVudCBkaXNjb25uZWN0XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEdsb2JhbCBub3RpZmljYXRpb24gb2YgcmVsZWFzaW5nIGEgZGF0YWJhc2UgY29ubmVjdGlvbiBiYWNrIHRvIHRoZSBjb25uZWN0aW9uIHBvb2wsIGkuZS4gcmVsZWFzaW5nIHRoZSB2aXJ0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogSG93ZXZlciwgd2hlbiByZWxlYXNpbmcgYSBkaXJlY3QgY29ubmVjdGlvbiAoY3JlYXRlZCBieSBjYWxsaW5nIHtAbGluayBEYXRhYmFzZSNjb25uZWN0IERhdGFiYXNlLmNvbm5lY3R9IHdpdGggcGFyYW1ldGVyXHJcbiAgICAgKiBge2RpcmVjdDogdHJ1ZX1gKSwgdGhpcyBldmVudCByZXByZXNlbnRzIGEgcGh5c2ljYWwgZGlzY29ubmVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbGlicmFyeSB3aWxsIHN1cHByZXNzIGFueSBlcnJvciB0aHJvd24gYnkgdGhlIGhhbmRsZXIgYW5kIHdyaXRlIGl0IGludG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7fX0gZSBFdmVudCBQcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtleHRlcm5hbDpDbGllbnR9IGUuY2xpZW50IC0gJFtwZy5DbGllbnRdIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgY29ubmVjdGlvbiB3aXRoIHRoZSBkYXRhYmFzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IGUuZGMgLSBEYXRhYmFzZSBDb250ZXh0IHRoYXQgd2FzIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgZGF0YWJhc2Ugb2JqZWN0IChzZWUge0BsaW5rIERhdGFiYXNlfSkuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBpbml0T3B0aW9ucyA9IHtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcGctcHJvbWlzZSBpbml0aWFsaXphdGlvbiBvcHRpb25zLi4uXHJcbiAgICAgKlxyXG4gICAgICogICAgIGRpc2Nvbm5lY3QoZSkge1xyXG4gICAgICogICAgICAgIGNvbnN0IGNwID0gZS5jbGllbnQuY29ubmVjdGlvblBhcmFtZXRlcnM7XHJcbiAgICAgKiAgICAgICAgY29uc29sZS5sb2coJ0Rpc2Nvbm5lY3RpbmcgZnJvbSBkYXRhYmFzZTonLCBjcC5kYXRhYmFzZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqIH07XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkaXNjb25uZWN0KGN0eCwgY2xpZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdHgub3B0aW9ucy5kaXNjb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjdHgub3B0aW9ucy5kaXNjb25uZWN0KHtjbGllbnQsIGRjOiBjdHguZGN9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBzaWxlbmNlIGVycm9ycyBoZXJlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2Fubm90IGFsbG93IHVuaGFuZGxlZCBlcnJvcnMgd2hpbGUgZGlzY29ubmVjdGluZyBmcm9tIHRoZSBkYXRhYmFzZSxcclxuICAgICAgICAgICAgICAgIC8vIGFzIGl0IHdpbGwgYnJlYWsgdGhlIGRpc2Nvbm5lY3Rpb24gbG9naWM7XHJcbiAgICAgICAgICAgICAgICBFdmVudHMudW5leHBlY3RlZCgnZGlzY29ubmVjdCcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IHF1ZXJ5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBHbG9iYWwgbm90aWZpY2F0aW9uIG9mIGEgcXVlcnkgdGhhdCdzIGFib3V0IHRvIGV4ZWN1dGUuXHJcbiAgICAgKlxyXG4gICAgICogTm90aWZpY2F0aW9uIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIHF1ZXJ5IGV4ZWN1dGlvbi4gQW5kIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBlcnJvciwgdGhlIHF1ZXJ5IGV4ZWN1dGlvblxyXG4gICAgICogd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoYXQgZXJyb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudENvbnRleHR9IGVcclxuICAgICAqIEV2ZW50IENvbnRleHQgT2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgaW5pdE9wdGlvbnMgPSB7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHBnLXByb21pc2UgaW5pdGlhbGl6YXRpb24gb3B0aW9ucy4uLlxyXG4gICAgICpcclxuICAgICAqICAgICBxdWVyeShlKSB7XHJcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdRVUVSWTonLCBlLnF1ZXJ5KTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9O1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcXVlcnkob3B0aW9ucywgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5xdWVyeSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeShjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhyb3dpbmcgYW4gZXJyb3IgZHVyaW5nIGV2ZW50ICdxdWVyeSdcclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGEgcmVqZWN0IGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IG5wbS51dGlscy5JbnRlcm5hbEVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IHJlY2VpdmVcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogR2xvYmFsIG5vdGlmaWNhdGlvbiBvZiBhbnkgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBkYXRhYmFzZSwgY29taW5nIGZyb20gYSByZWd1bGFyIHF1ZXJ5IG9yIGZyb20gYSBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSB0aGUgZGF0YSByZWFjaGVzIHRoZSBjbGllbnQsIGFuZCBpdCBzZXJ2ZXMgdHdvIHB1cnBvc2VzOlxyXG4gICAgICogIC0gUHJvdmlkaW5nIHNlbGVjdGl2ZSBkYXRhIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZztcclxuICAgICAqICAtIFByZS1wcm9jZXNzaW5nIGRhdGEgYmVmb3JlIGl0IHJlYWNoZXMgdGhlIGNsaWVudC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5PVEVTOioqXHJcbiAgICAgKiAtIElmIHlvdSBhbHRlciB0aGUgc2l6ZSBvZiBgZGF0YWAgZGlyZWN0bHkgb3IgdGhyb3VnaCB0aGUgYHJlc3VsdGAgb2JqZWN0LCBpdCBtYXkgYWZmZWN0IGBRdWVyeVJlc3VsdE1hc2tgXHJcbiAgICAgKiAgIHZhbGlkYXRpb24gZm9yIHJlZ3VsYXIgcXVlcmllcywgd2hpY2ggaXMgZXhlY3V0ZWQgcmlnaHQgYWZ0ZXIuXHJcbiAgICAgKiAtIEFueSBkYXRhIHByZS1wcm9jZXNzaW5nIG5lZWRzIHRvIGJlIGZhc3QgaGVyZSwgdG8gYXZvaWQgcGVyZm9ybWFuY2UgcGVuYWx0aWVzLlxyXG4gICAgICogLSBJZiB0aGUgZXZlbnQgaGFuZGxlciB0aHJvd3MgYW4gZXJyb3IsIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGF0IGVycm9yLlxyXG4gICAgICpcclxuICAgICAqIEZvciBtZXRob2RzIHtAbGluayBEYXRhYmFzZSNtdWx0aSBEYXRhYmFzZS5tdWx0aX0gYW5kIHtAbGluayBEYXRhYmFzZSNtdWx0aVJlc3VsdCBEYXRhYmFzZS5tdWx0aVJlc3VsdH0sXHJcbiAgICAgKiB0aGlzIGV2ZW50IGlzIGNhbGxlZCBmb3IgZXZlcnkgcmVzdWx0IHRoYXQncyByZXR1cm5lZC4gQW5kIGZvciBtZXRob2Qge0BsaW5rIERhdGFiYXNlI3N0cmVhbSBEYXRhYmFzZS5zdHJlYW19LFxyXG4gICAgICogdGhlIGV2ZW50IG9jY3VycyBmb3IgZXZlcnkgcmVjb3JkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e319IGUgRXZlbnQgUHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZS5kYXRhXHJcbiAgICAgKiBBcnJheSBvZiByZWNlaXZlZCBvYmplY3RzL3Jvd3MuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYW55IG9mIHRob3NlIG9iamVjdHMgYXJlIG1vZGlmaWVkIGR1cmluZyBub3RpZmljYXRpb24sIHRoZSBjbGllbnQgd2lsbCByZWNlaXZlIHRoZSBtb2RpZmllZCBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXh0ZXJuYWw6UmVzdWx0fSBlLnJlc3VsdFxyXG4gICAgICogLSBPcmlnaW5hbCAkW1Jlc3VsdF0gb2JqZWN0LCBpZiB0aGUgZGF0YSBpcyBmcm9tIGEgbm9uLXN0cmVhbSBxdWVyeSwgaW4gd2hpY2ggY2FzZSBgZGF0YSA9IHJlc3VsdC5yb3dzYC5cclxuICAgICAqICAgRm9yIHNpbmdsZS1xdWVyeSByZXF1ZXN0cywgJFtSZXN1bHRdIG9iamVjdCBpcyBleHRlbmRlZCB3aXRoIHByb3BlcnR5IGBkdXJhdGlvbmAgLSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXHJcbiAgICAgKiAgIGl0IHRvb2sgdG8gc2VuZCB0aGUgcXVlcnksIGV4ZWN1dGUgaXQgYW5kIGdldCB0aGUgcmVzdWx0IGJhY2suXHJcbiAgICAgKiAtIEl0IGlzIGB1bmRlZmluZWRgIHdoZW4gdGhlIGRhdGEgY29tZXMgZnJvbSBhIHN0cmVhbSAobWV0aG9kIHtAbGluayBEYXRhYmFzZSNzdHJlYW0gRGF0YWJhc2Uuc3RyZWFtfSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudENvbnRleHR9IGUuY3R4XHJcbiAgICAgKiBFdmVudCBDb250ZXh0IE9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIC8vIEV4YW1wbGUgYmVsb3cgc2hvd3MgdGhlIGZhc3Rlc3Qgd2F5IHRvIGNhbWVsaXplIGFsbCBjb2x1bW4gbmFtZXMuXHJcbiAgICAgKiAvLyBOT1RFOiBUaGUgZXhhbXBsZSBkb2VzIG5vdCBkbyBwcm9jZXNzaW5nIGZvciBuZXN0ZWQgSlNPTiBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgcmVjZWl2ZShlKSB7XHJcbiAgICAgKiAgICAgICAgIGNhbWVsaXplQ29sdW1ucyhlLmRhdGEpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gY2FtZWxpemVDb2x1bW5zKGRhdGEpIHtcclxuICAgICAqICAgICBjb25zdCB0bXAgPSBkYXRhWzBdO1xyXG4gICAgICogICAgIGZvciAoY29uc3QgcHJvcCBpbiB0bXApIHtcclxuICAgICAqICAgICAgICAgY29uc3QgY2FtZWwgPSBwZ3AudXRpbHMuY2FtZWxpemUocHJvcCk7XHJcbiAgICAgKiAgICAgICAgIGlmICghKGNhbWVsIGluIHRtcCkpIHtcclxuICAgICAqICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICogICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBkYXRhW2ldO1xyXG4gICAgICogICAgICAgICAgICAgICAgIGRbY2FtZWxdID0gZFtwcm9wXTtcclxuICAgICAqICAgICAgICAgICAgICAgICBkZWxldGUgZFtwcm9wXTtcclxuICAgICAqICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlY2VpdmUob3B0aW9ucywgZGF0YSwgcmVzdWx0LCBjdHgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVjZWl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWNlaXZlKHtkYXRhLCByZXN1bHQsIGN0eH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvd2luZyBhbiBlcnJvciBkdXJpbmcgZXZlbnQgJ3JlY2VpdmUnXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBhIHJlamVjdCBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBucG0udXRpbHMuSW50ZXJuYWxFcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBldmVudCB0YXNrXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEdsb2JhbCBub3RpZmljYXRpb24gb2YgYSB0YXNrIHN0YXJ0IC8gZmluaXNoIGV2ZW50cywgYXMgZXhlY3V0ZWQgdmlhXHJcbiAgICAgKiB7QGxpbmsgRGF0YWJhc2UjdGFzayBEYXRhYmFzZS50YXNrfSBvciB7QGxpbmsgRGF0YWJhc2UjdGFza0lmIERhdGFiYXNlLnRhc2tJZn0uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxpYnJhcnkgd2lsbCBzdXBwcmVzcyBhbnkgZXJyb3IgdGhyb3duIGJ5IHRoZSBoYW5kbGVyIGFuZCB3cml0ZSBpdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnRDb250ZXh0fSBlXHJcbiAgICAgKiBFdmVudCBDb250ZXh0IE9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgdGFzayhlKSB7XHJcbiAgICAgKiAgICAgICAgIGlmIChlLmN0eC5maW5pc2gpIHtcclxuICAgICAqICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSB0YXNrLT5maW5pc2ggZXZlbnQ7XHJcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRHVyYXRpb246JywgZS5jdHguZHVyYXRpb24pO1xyXG4gICAgICogICAgICAgICAgICAgaWYgKGUuY3R4LnN1Y2Nlc3MpIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAvLyBlLmN0eC5yZXN1bHQgPSByZXNvbHZlZCBkYXRhO1xyXG4gICAgICogICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAvLyBlLmN0eC5yZXN1bHQgPSBlcnJvci9yZWplY3Rpb24gcmVhc29uO1xyXG4gICAgICogICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICB9IGVsc2Uge1xyXG4gICAgICogICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHRhc2stPnN0YXJ0IGV2ZW50O1xyXG4gICAgICogICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0IFRpbWU6JywgZS5jdHguc3RhcnQpO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0YXNrKG9wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGFzayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YXNrKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWxlbmNpbmcgdGhlIGVycm9yLCB0byBhdm9pZCBicmVha2luZyB0aGUgdGFzaztcclxuICAgICAgICAgICAgICAgIEV2ZW50cy51bmV4cGVjdGVkKCd0YXNrJywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZXZlbnQgdHJhbnNhY3RcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogR2xvYmFsIG5vdGlmaWNhdGlvbiBvZiBhIHRyYW5zYWN0aW9uIHN0YXJ0IC8gZmluaXNoIGV2ZW50cywgYXMgZXhlY3V0ZWQgdmlhIHtAbGluayBEYXRhYmFzZSN0eCBEYXRhYmFzZS50eH1cclxuICAgICAqIG9yIHtAbGluayBEYXRhYmFzZSN0eElmIERhdGFiYXNlLnR4SWZ9LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBsaWJyYXJ5IHdpbGwgc3VwcHJlc3MgYW55IGVycm9yIHRocm93biBieSB0aGUgaGFuZGxlciBhbmQgd3JpdGUgaXQgaW50byB0aGUgY29uc29sZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50Q29udGV4dH0gZVxyXG4gICAgICogRXZlbnQgQ29udGV4dCBPYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBpbml0T3B0aW9ucyA9IHtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcGctcHJvbWlzZSBpbml0aWFsaXphdGlvbiBvcHRpb25zLi4uXHJcbiAgICAgKlxyXG4gICAgICogICAgIHRyYW5zYWN0KGUpIHtcclxuICAgICAqICAgICAgICAgaWYgKGUuY3R4LmZpbmlzaCkge1xyXG4gICAgICogICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHRyYW5zYWN0aW9uLT5maW5pc2ggZXZlbnQ7XHJcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRHVyYXRpb246JywgZS5jdHguZHVyYXRpb24pO1xyXG4gICAgICogICAgICAgICAgICAgaWYgKGUuY3R4LnN1Y2Nlc3MpIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAvLyBlLmN0eC5yZXN1bHQgPSByZXNvbHZlZCBkYXRhO1xyXG4gICAgICogICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAvLyBlLmN0eC5yZXN1bHQgPSBlcnJvci9yZWplY3Rpb24gcmVhc29uO1xyXG4gICAgICogICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICB9IGVsc2Uge1xyXG4gICAgICogICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHRyYW5zYWN0aW9uLT5zdGFydCBldmVudDtcclxuICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdGFydCBUaW1lOicsIGUuY3R4LnN0YXJ0KTtcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNhY3Qob3B0aW9ucywgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2FjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmFuc2FjdChjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2lsZW5jaW5nIHRoZSBlcnJvciwgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIHRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRzLnVuZXhwZWN0ZWQoJ3RyYW5zYWN0JywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZXZlbnQgZXJyb3JcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogR2xvYmFsIG5vdGlmaWNhdGlvbiBvZiBldmVyeSBlcnJvciBlbmNvdW50ZXJlZCBieSB0aGlzIGxpYnJhcnkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxpYnJhcnkgd2lsbCBzdXBwcmVzcyBhbnkgZXJyb3IgdGhyb3duIGJ5IHRoZSBoYW5kbGVyIGFuZCB3cml0ZSBpdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gZXJyXHJcbiAgICAgKiBUaGUgZXJyb3IgZW5jb3VudGVyZWQsIG9mIHRoZSBzYW1lIHZhbHVlIGFuZCB0eXBlIGFzIGl0IHdhcyByZXBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50Q29udGV4dH0gZVxyXG4gICAgICogRXZlbnQgQ29udGV4dCBPYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgZXJyb3IoZXJyLCBlKSB7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBpZiAoZS5jbikge1xyXG4gICAgICogICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbm5lY3Rpb24tcmVsYXRlZCBlcnJvclxyXG4gICAgICogICAgICAgICAgICAgLy8gY24gPSBzYWZlIGNvbm5lY3Rpb24gZGV0YWlscyBwYXNzZWQgaW50byB0aGUgbGlicmFyeTpcclxuICAgICAqICAgICAgICAgICAgIC8vICAgICAgaWYgcGFzc3dvcmQgaXMgcHJlc2VudCwgaXQgaXMgbWFza2VkIGJ5ICNcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgaWYgKGUucXVlcnkpIHtcclxuICAgICAqICAgICAgICAgICAgIC8vIHF1ZXJ5IHN0cmluZyBpcyBhdmFpbGFibGVcclxuICAgICAqICAgICAgICAgICAgIGlmIChlLnBhcmFtcykge1xyXG4gICAgICogICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICogICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBpZiAoZS5jdHgpIHtcclxuICAgICAqICAgICAgICAgICAgIC8vIG9jY3VycmVkIGluc2lkZSBhIHRhc2sgb3IgdHJhbnNhY3Rpb25cclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlcnJvcihvcHRpb25zLCBlcnIsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoZXJyLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBzaWxlbmNlIGVycm9ycyBoZXJlO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhyb3dpbmcgdW5oYW5kbGVkIGVycm9ycyB3aGlsZSBoYW5kbGluZyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgLy8gbm90aWZpY2F0aW9uIGlzIHNpbXBseSBub3QgYWNjZXB0YWJsZS5cclxuICAgICAgICAgICAgICAgIEV2ZW50cy51bmV4cGVjdGVkKCdlcnJvcicsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IGV4dGVuZFxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBFeHRlbmRzIHtAbGluayBEYXRhYmFzZX0gcHJvdG9jb2wgd2l0aCBjdXN0b20gbWV0aG9kcyBhbmQgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBPdmVycmlkZSB0aGlzIGV2ZW50IHRvIGV4dGVuZCB0aGUgZXhpc3RpbmcgYWNjZXNzIGxheWVyIHdpdGggeW91ciBvd24gZnVuY3Rpb25zIGFuZFxyXG4gICAgICogcHJvcGVydGllcyBiZXN0IHN1aXRlZCBmb3IgeW91ciBhcHBsaWNhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZXh0ZW5zaW9uIHRodXMgYmVjb21lcyBhdmFpbGFibGUgYWNyb3NzIGFsbCBhY2Nlc3MgbGF5ZXJzOlxyXG4gICAgICpcclxuICAgICAqIC0gV2l0aGluIHRoZSByb290L2RlZmF1bHQgZGF0YWJhc2UgcHJvdG9jb2w7XHJcbiAgICAgKiAtIEluc2lkZSB0cmFuc2FjdGlvbnMsIGluY2x1ZGluZyBuZXN0ZWQgb25lcztcclxuICAgICAqIC0gSW5zaWRlIHRhc2tzLCBpbmNsdWRpbmcgbmVzdGVkIG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIHByZS1kZWZpbmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXJlIHJlYWQtb25seSwgc28geW91IHdpbGwgZ2V0IGFuIGVycm9yLFxyXG4gICAgICogaWYgeW91IHRyeSBvdmVycmlkaW5nIHRoZW0uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxpYnJhcnkgd2lsbCBzdXBwcmVzcyBhbnkgZXJyb3IgdGhyb3duIGJ5IHRoZSBoYW5kbGVyIGFuZCB3cml0ZSBpdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBQcm90b2NvbCBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBkYyAtIERhdGFiYXNlIENvbnRleHQgdGhhdCB3YXMgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSB7QGxpbmsgRGF0YWJhc2V9IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlICRbcGctcHJvbWlzZS1kZW1vXVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogLy8gSW4gdGhlIGV4YW1wbGUgYmVsb3cgd2UgZXh0ZW5kIHRoZSBwcm90b2NvbCB3aXRoIGZ1bmN0aW9uIGBhZGRJbWFnZWBcclxuICAgICAqIC8vIHRoYXQgd2lsbCBpbnNlcnQgb25lIGJpbmFyeSBpbWFnZSBhbmQgcmVzb2x2ZSB3aXRoIHRoZSBuZXcgcmVjb3JkIGlkLlxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgZXh0ZW5kKG9iaiwgZGMpIHtcclxuICAgICAqICAgICAgICAgLy8gZGMgPSBkYXRhYmFzZSBjb250ZXh0O1xyXG4gICAgICogICAgICAgICBvYmouYWRkSW1hZ2UgPSBkYXRhID0+IHtcclxuICAgICAqICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgaW1hZ2UgYW5kIHJlc29sdmVzIHdpdGggaXRzIHJlY29yZCBpZDpcclxuICAgICAqICAgICAgICAgICAgIHJldHVybiBvYmoub25lKCdJTlNFUlQgSU5UTyBpbWFnZXMoZGF0YSkgVkFMVUVTKCQxKSBSRVRVUk5JTkcgaWQnLCBkYXRhLCBhID0+IGEuaWQpO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIC8vIEl0IGlzIGJlc3QgdG8gZXh0ZW5kIHRoZSBwcm90b2NvbCBieSBhZGRpbmcgd2hvbGUgZW50aXR5IHJlcG9zaXRvcmllcyB0byBpdCBhcyBzaG93biBpbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUuXHJcbiAgICAgKiAvLyBGb3IgYSBjb21wcmVoZW5zaXZlIGV4YW1wbGUgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbHktdC9wZy1wcm9taXNlLWRlbW9cclxuICAgICAqXHJcbiAgICAgKiBjbGFzcyBVc2Vyc1JlcG9zaXRvcnkge1xyXG4gICAgICogICAgIGNvbnN0cnVjdG9yKHJlcCwgcGdwKSB7XHJcbiAgICAgKiAgICAgICAgIHRoaXMucmVwID0gcmVwO1xyXG4gICAgICogICAgICAgICB0aGlzLnBncCA9IHBncDtcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIGFkZChuYW1lKSB7XHJcbiAgICAgKiAgICAgICAgIHJldHVybiB0aGlzLnJlcC5vbmUoJ0lOU0VSVCBJTlRPIHVzZXJzKG5hbWUpIFZBTFVFUygkMSkgUkVUVVJOSU5HIGlkJywgbmFtZSwgYSA9PiBhLmlkKTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIHJlbW92ZShpZCkge1xyXG4gICAgICogICAgICAgICByZXR1cm4gdGhpcy5yZXAubm9uZSgnREVMRVRFIEZST00gdXNlcnMgV0hFUkUgaWQgPSAkMScsIGlkKTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gT3ZlcnJpZGluZyAnZXh0ZW5kJyBldmVudDtcclxuICAgICAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwZy1wcm9taXNlIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuLi5cclxuICAgICAqXHJcbiAgICAgKiAgICAgZXh0ZW5kKG9iaiwgZGMpIHtcclxuICAgICAqICAgICAgICAgLy8gZGMgPSBkYXRhYmFzZSBjb250ZXh0O1xyXG4gICAgICogICAgICAgICBvYmoudXNlcnMgPSBuZXcgVXNlcnNSZXBvc2l0b3J5KG9iaiwgcGdwKTtcclxuICAgICAqICAgICAgICAgLy8gWW91IGNhbiBzZXQgZGlmZmVyZW50IHJlcG9zaXRvcmllcyBiYXNlZCBvbiBgZGNgXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2FnZSBleGFtcGxlOlxyXG4gICAgICogZGIudXNlcnMuYWRkKCdKb2huJywgdHJ1ZSlcclxuICAgICAqICAgICAudGhlbihpZCA9PiB7XHJcbiAgICAgKiAgICAgICAgIC8vIHVzZXIgYWRkZWQgc3VjY2Vzc2Z1bGx5LCBpZCA9IG5ldyB1c2VyJ3MgaWRcclxuICAgICAqICAgICB9KVxyXG4gICAgICogICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgKiAgICAgICAgIC8vIGZhaWxlZCB0byBhZGQgdGhlIHVzZXI7XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZXh0ZW5kKG9wdGlvbnMsIG9iaiwgZGMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0ZW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4dGVuZC5jYWxsKG9iaiwgb2JqLCBkYyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gc2lsZW5jZSBlcnJvcnMgaGVyZTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXN1bHQgb2YgdGhyb3dpbmcgdW5oYW5kbGVkIGVycm9ycyB3aGlsZVxyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIHRoZSBwcm90b2NvbCB3b3VsZCBiZSB1bnByZWRpY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgRXZlbnRzLnVuZXhwZWN0ZWQoJ2V4dGVuZCcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IHVuZXhwZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIHVuaGFuZGxlZCBldmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RXJyb3J9IGUgLSB1bmhhbmRsZWQgZXJyb3IuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdW5leHBlY3RlZChldmVudCwgZSkge1xyXG4gICAgICAgIC8vIElmIHlvdSBzaG91bGQgZXZlciBnZXQgaGVyZSwgeW91ciBhcHAgaXMgZGVmaW5pdGVseSBicm9rZW4sIGFuZCB5b3UgbmVlZCB0byBmaXhcclxuICAgICAgICAvLyB5b3VyIGV2ZW50IGhhbmRsZXIgdG8gcHJldmVudCB1bmhhbmRsZWQgZXJyb3JzIGR1cmluZyBldmVudCBub3RpZmljYXRpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gQ29uc29sZSBvdXRwdXQgaXMgc3VwcHJlc3NlZCB3aGVuIHJ1bm5pbmcgdGVzdHMsIHRvIGF2b2lkIHBvbGx1dGluZyB0ZXN0IG91dHB1dFxyXG4gICAgICAgIC8vIHdpdGggZXJyb3IgbWVzc2FnZXMgdGhhdCBhcmUgaW50ZW50aW9uYWwgYW5kIG9mIG5vIHZhbHVlIHRvIHRoZSB0ZXN0LlxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIW5wbS5tYWluLnN1cHByZXNzRXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5zdGFjayA6IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gICAgICAgICAgICBDb2xvckNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3IgaW4gJyR7ZXZlbnR9JyBldmVudCBoYW5kbGVyLlxcbiR7c3RhY2t9XFxuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtFdmVudHN9O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIEV2ZW50Q29udGV4dFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhpcyBjb21tb24gdHlwZSBpcyB1c2VkIGZvciB0aGUgZm9sbG93aW5nIGV2ZW50czoge0BsaW5rIGV2ZW50OnF1ZXJ5IHF1ZXJ5fSwge0BsaW5rIGV2ZW50OnJlY2VpdmUgcmVjZWl2ZX0sXHJcbiAqIHtAbGluayBldmVudDplcnJvciBlcnJvcn0sIHtAbGluayBldmVudDp0YXNrIHRhc2t9IGFuZCB7QGxpbmsgZXZlbnQ6dHJhbnNhY3QgdHJhbnNhY3R9LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R9IGNuXHJcbiAqXHJcbiAqIFNldCBvbmx5IGZvciBldmVudCB7QGxpbmsgZXZlbnQ6ZXJyb3IgZXJyb3J9LCBhbmQgb25seSB3aGVuIHRoZSBlcnJvciBpcyBjb25uZWN0aW9uLXJlbGF0ZWQuXHJcbiAqXHJcbiAqIEl0IGlzIGEgc2FmZSBjb3B5IG9mIHRoZSBjb25uZWN0aW9uIHN0cmluZy9vYmplY3QgdGhhdCB3YXMgdXNlZCB3aGVuIGluaXRpYWxpemluZyBgZGJgIC0gdGhlIGRhdGFiYXNlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBJZiB0aGUgb3JpZ2luYWwgY29ubmVjdGlvbiBjb250YWlucyBhIHBhc3N3b3JkLCB0aGUgc2FmZSBjb3B5IGNvbnRhaW5zIGl0IG1hc2tlZCB3aXRoIHN5bWJvbCBgI2AsIHNvIHRoZSBjb25uZWN0aW9uXHJcbiAqIGNhbiBiZSBsb2dnZWQgc2FmZWx5LCB3aXRob3V0IGV4cG9zaW5nIHRoZSBwYXNzd29yZC5cclxuICpcclxuICogQHByb3BlcnR5IHsqfSBkY1xyXG4gKiBEYXRhYmFzZSBDb250ZXh0IHRoYXQgd2FzIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgZGF0YWJhc2Ugb2JqZWN0IChzZWUge0BsaW5rIERhdGFiYXNlfSkuIEl0IGlzIHNldCBmb3IgYWxsIGV2ZW50cy5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBxdWVyeVxyXG4gKlxyXG4gKiBRdWVyeSBzdHJpbmcvb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBxdWVyeSBtZXRob2QuIFRoaXMgcHJvcGVydHkgaXMgb25seSBzZXQgZHVyaW5nIGV2ZW50cyB7QGxpbmsgZXZlbnQ6cXVlcnkgcXVlcnl9LFxyXG4gKiB7QGxpbmsgZXZlbnQ6cmVjZWl2ZSByZWNlaXZlfSBhbmQge0BsaW5rIGV2ZW50OmVycm9yIGVycm9yfSAob25seSB3aGVuIHRoZSBlcnJvciBpcyBxdWVyeS1yZWxhdGVkKS5cclxuICpcclxuICogQHByb3BlcnR5IHtleHRlcm5hbDpDbGllbnR9IGNsaWVudFxyXG4gKlxyXG4gKiAkW3BnLkNsaWVudF0gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY29ubmVjdGlvbi4gSXQgaXMgc2V0IGZvciBhbGwgZXZlbnRzLCBleGNlcHQgZm9yIGV2ZW50IHtAbGluayBldmVudDplcnJvciBlcnJvcn1cclxuICogd2hlbiBpdCBpcyBjb25uZWN0aW9uLXJlbGF0ZWQuIE5vdGUgdGhhdCBzb21ldGltZXMgdGhlIHZhbHVlIG1heSBiZSB1bnNldCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGxvc3QuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gcGFyYW1zIC0gRm9ybWF0dGluZyBwYXJhbWV0ZXJzIGZvciB0aGUgcXVlcnkuXHJcbiAqXHJcbiAqIEl0IGlzIHNldCBvbmx5IGZvciBldmVudHMge0BsaW5rIGV2ZW50OnF1ZXJ5IHF1ZXJ5fSwge0BsaW5rIGV2ZW50OnJlY2VpdmUgcmVjZWl2ZX0gYW5kIHtAbGluayBldmVudDplcnJvciBlcnJvcn0sIGFuZCBvbmx5XHJcbiAqIHdoZW4gaXQgaXMgbmVlZGVkIGZvciBsb2dnaW5nLiBUaGlzIGxpYnJhcnkgdGFrZXMgYW4gZXh0cmEgc3RlcCBpbiBmaWd1cmluZyBvdXQgd2hlbiBmb3JtYXR0aW5nIHBhcmFtZXRlcnMgYXJlIG9mIGFueSB2YWx1ZVxyXG4gKiB0byB0aGUgZXZlbnQgbG9nZ2luZzpcclxuICogLSB3aGVuIGFuIGVycm9yIG9jY3VycyByZWxhdGVkIHRvIHRoZSBxdWVyeSBmb3JtYXR0aW5nLCBldmVudCB7QGxpbmsgZXZlbnQ6ZXJyb3IgZXJyb3J9IGlzIHNlbnQgd2l0aCB0aGUgcHJvcGVydHkgc2V0LlxyXG4gKiAtIHdoZW4gaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVyIGBwZ0Zvcm1hdGAgaXMgdXNlZCwgYW5kIGFsbCBxdWVyeSBmb3JtYXR0aW5nIGlzIGRvbmUgd2l0aGluIHRoZSAkW1BHXSBsaWJyYXJ5LCBldmVudHNcclxuICoge0BsaW5rIGV2ZW50OnF1ZXJ5IHF1ZXJ5fSBhbmQge0BsaW5rIGV2ZW50OnJlY2VpdmUgcmVjZWl2ZX0gd2lsbCBoYXZlIHRoaXMgcHJvcGVydHkgc2V0IGFsc28sIHNpbmNlIHRoaXMgbGlicmFyeSBubyBsb25nZXJcclxuICogaGFuZGxlcyB0aGUgcXVlcnkgZm9ybWF0dGluZy5cclxuICpcclxuICogV2hlbiB0aGlzIHBhcmFtZXRlciBpcyBub3Qgc2V0LCBpdCBtZWFucyBvbmUgb2YgdGhlIHR3byB0aGluZ3M6XHJcbiAqIC0gdGhlcmUgd2VyZSBubyBwYXJhbWV0ZXJzIHBhc3NlZCBpbnRvIHRoZSBxdWVyeSBtZXRob2Q7XHJcbiAqIC0gcHJvcGVydHkgYHF1ZXJ5YCBvZiB0aGlzIG9iamVjdCBhbHJlYWR5IGNvbnRhaW5zIGFsbCB0aGUgZm9ybWF0dGluZyB2YWx1ZXMgaW4gaXQsIHNvIGxvZ2dpbmcgb25seSB0aGUgcXVlcnkgaXMgc3VmZmljaWVudC5cclxuICpcclxuICogQHByb3BlcnR5IHtUYXNrQ29udGV4dH0gY3R4XHJcbiAqIF9UYXNrL1RyYW5zYWN0aW9uIENvbnRleHRfIG9iamVjdC5cclxuICpcclxuICogVGhpcyBwcm9wZXJ0eSBpcyBhbHdheXMgc2V0IGZvciBldmVudHMge0BsaW5rIGV2ZW50OnRhc2sgdGFza30gYW5kIHtAbGluayBldmVudDp0cmFuc2FjdCB0cmFuc2FjdH0sIHdoaWxlIGZvciBldmVudHNcclxuICoge0BsaW5rIGV2ZW50OnF1ZXJ5IHF1ZXJ5fSwge0BsaW5rIGV2ZW50OnJlY2VpdmUgcmVjZWl2ZX0gYW5kIHtAbGluayBldmVudDplcnJvciBlcnJvcn0gaXQgaXMgb25seSBzZXQgd2hlbiB0aGV5IG9jY3VyXHJcbiAqIGluc2lkZSBhIHRhc2sgb3IgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG4iXSwibmFtZXMiOlsiQ29sb3JDb25zb2xlIiwicmVxdWlyZSIsIm5wbSIsIm1haW4iLCJ1dGlscyIsIkV2ZW50cyIsImNvbm5lY3QiLCJjdHgiLCJjbGllbnQiLCJ1c2VDb3VudCIsIm9wdGlvbnMiLCJkYyIsImUiLCJ1bmV4cGVjdGVkIiwiZGlzY29ubmVjdCIsInF1ZXJ5IiwiY29udGV4dCIsIkVycm9yIiwiSW50ZXJuYWxFcnJvciIsInJlY2VpdmUiLCJkYXRhIiwicmVzdWx0IiwidGFzayIsInRyYW5zYWN0IiwiZXJyb3IiLCJlcnIiLCJleHRlbmQiLCJvYmoiLCJjYWxsIiwiZXZlbnQiLCJzdXBwcmVzc0Vycm9ycyIsInN0YWNrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/formatting.js":
/*!***************************************************!*\
  !*** ./node_modules/pg-promise/lib/formatting.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    pgUtils: __webpack_require__(/*! pg/lib/utils */ \"pg/lib/utils\"),\n    patterns: __webpack_require__(/*! ./patterns */ \"(rsc)/./node_modules/pg-promise/lib/patterns.js\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n// Format Modification Flags;\nconst fmFlags = {\n    raw: 1,\n    alias: 2,\n    name: 4,\n    json: 8,\n    csv: 16,\n    value: 32 // escaped, but without ''\n};\n// Format Modification Map;\nconst fmMap = {\n    \"^\": fmFlags.raw,\n    \":raw\": fmFlags.raw,\n    \":alias\": fmFlags.alias,\n    \"~\": fmFlags.name,\n    \":name\": fmFlags.name,\n    \":json\": fmFlags.json,\n    \":csv\": fmFlags.csv,\n    \":list\": fmFlags.csv,\n    \":value\": fmFlags.value,\n    \"#\": fmFlags.value\n};\n// Global symbols for Custom Type Formatting:\nconst ctfSymbols = {\n    toPostgres: Symbol.for(\"ctf.toPostgres\"),\n    rawType: Symbol.for(\"ctf.rawType\")\n};\nconst maxVariable = 100000; // maximum supported variable is '$100000'\n////////////////////////////////////////////////////\n// Converts a single value into its Postgres format.\nfunction formatValue({ value, fm, cc, options }) {\n    if (typeof value === \"function\") {\n        return formatValue({\n            value: resolveFunc(value, cc),\n            fm,\n            cc\n        });\n    }\n    const ctf = getCTF(value); // Custom Type Formatting\n    if (ctf) {\n        fm |= ctf.rawType ? fmFlags.raw : 0;\n        return formatValue({\n            value: resolveFunc(ctf.toPostgres, value),\n            fm,\n            cc\n        });\n    }\n    const isRaw = !!(fm & fmFlags.raw);\n    fm &= ~fmFlags.raw;\n    switch(fm){\n        case fmFlags.alias:\n            return $as.alias(value);\n        case fmFlags.name:\n            return $as.name(value);\n        case fmFlags.json:\n            return $as.json(value, isRaw);\n        case fmFlags.csv:\n            return $to.csv(value, options);\n        case fmFlags.value:\n            return $as.value(value);\n        default:\n            break;\n    }\n    if (isNull(value)) {\n        throwIfRaw(isRaw);\n        return \"null\";\n    }\n    switch(typeof value){\n        case \"string\":\n            return $to.text(value, isRaw);\n        case \"boolean\":\n            return $to.bool(value);\n        case \"number\":\n        case \"bigint\":\n            return $to.number(value);\n        case \"symbol\":\n            throw new TypeError(`Type Symbol has no meaning for PostgreSQL: ${value.toString()}`);\n        default:\n            if (value instanceof Date) {\n                return $to.date(value, isRaw);\n            }\n            if (Array.isArray(value)) {\n                return $to.array(value, options);\n            }\n            if (Buffer.isBuffer(value)) {\n                return $to.buffer(value, isRaw);\n            }\n            return $to.json(value, isRaw);\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Converts array of values into PostgreSQL Array Constructor: array[...], as per PostgreSQL documentation:\n// http://www.postgresql.org/docs/9.6/static/arrays.html\n//\n// Arrays of any depth/dimension are supported.\n//\n// Top-level empty arrays are formatted as literal '{}' to avoid the necessity of explicit type casting,\n// as the server cannot automatically infer the type of empty non-literal array.\nfunction formatArray(array, options) {\n    const loop = (a)=>\"[\" + a.map((value)=>Array.isArray(value) ? loop(value) : formatValue({\n                value,\n                options\n            })).join() + \"]\";\n    const prefix = options && options.capSQL ? \"ARRAY\" : \"array\";\n    return array.length ? prefix + loop(array) : \"'{}'\";\n}\n///////////////////////////////////////////////////////////////////\n// Formats array/object/value as a list of comma-separated values.\nfunction formatCSV(values, options) {\n    if (Array.isArray(values)) {\n        return values.map((value)=>formatValue({\n                value,\n                options\n            })).join();\n    }\n    if (typeof values === \"object\" && values !== null) {\n        return Object.keys(values).map((v)=>formatValue({\n                value: values[v],\n                options\n            })).join();\n    }\n    return values === undefined ? \"\" : formatValue({\n        value: values,\n        options\n    });\n}\n///////////////////////////////\n// Query formatting helpers;\nconst formatAs = {\n    object ({ query, obj, raw, options }) {\n        options = options && typeof options === \"object\" ? options : {};\n        return query.replace(npm.patterns.namedParameters, (name)=>{\n            const v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, \"\"), raw), c = npm.utils.getIfHas(obj, v.name);\n            if (!c.valid) {\n                throw new Error(`Invalid property name '${v.name}'.`);\n            }\n            if (c.has) {\n                return formatValue({\n                    value: c.value,\n                    fm: v.fm,\n                    cc: c.target,\n                    options\n                });\n            }\n            if (v.name === \"this\") {\n                return formatValue({\n                    value: obj,\n                    fm: v.fm,\n                    options\n                });\n            }\n            if (\"def\" in options) {\n                const d = options.def, value = typeof d === \"function\" ? d.call(obj, v.name, obj) : d;\n                return formatValue({\n                    value,\n                    fm: v.fm,\n                    cc: obj,\n                    options\n                });\n            }\n            if (options.partial) {\n                return name;\n            }\n            // property must exist as the object's own or inherited;\n            throw new Error(`Property '${v.name}' doesn't exist.`);\n        });\n    },\n    array ({ query, array, raw, options }) {\n        options = options && typeof options === \"object\" ? options : {};\n        return query.replace(npm.patterns.multipleValues, (name)=>{\n            const v = formatAs.stripName(name.substr(1), raw);\n            const idx = v.name - 1;\n            if (idx >= maxVariable) {\n                throw new RangeError(`Variable $${v.name} exceeds supported maximum of $${maxVariable}`);\n            }\n            if (idx < array.length) {\n                return formatValue({\n                    value: array[idx],\n                    fm: v.fm,\n                    options\n                });\n            }\n            if (\"def\" in options) {\n                const d = options.def, value = typeof d === \"function\" ? d.call(array, idx, array) : d;\n                return formatValue({\n                    value,\n                    fm: v.fm,\n                    options\n                });\n            }\n            if (options.partial) {\n                return name;\n            }\n            throw new RangeError(`Variable $${v.name} out of range. Parameters array length: ${array.length}`);\n        });\n    },\n    value ({ query, value, raw, options }) {\n        return query.replace(npm.patterns.singleValue, (name)=>{\n            const v = formatAs.stripName(name, raw);\n            return formatValue({\n                value,\n                fm: v.fm,\n                options\n            });\n        });\n    },\n    stripName (name, raw) {\n        const mod = name.match(npm.patterns.hasValidModifier);\n        if (mod) {\n            return {\n                name: name.substr(0, mod.index),\n                fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\n            };\n        }\n        return {\n            name,\n            fm: raw ? fmFlags.raw : null\n        };\n    }\n};\n////////////////////////////////////////////\n// Simpler check for null/undefined;\nfunction isNull(value) {\n    return value === undefined || value === null;\n}\n//////////////////////////////////////////////////////////////////\n// Checks if the value supports Custom Type Formatting,\n// to return {toPostgres, rawType}, if it does, or null otherwise.\nfunction getCTF(value) {\n    if (!isNull(value)) {\n        let toPostgres = value[ctfSymbols.toPostgres], rawType = !!value[ctfSymbols.rawType];\n        if (typeof toPostgres !== \"function\") {\n            toPostgres = value.toPostgres;\n            rawType = !!value.rawType;\n        }\n        if (typeof toPostgres === \"function\") {\n            if (toPostgres.constructor.name !== \"Function\") {\n                throw new Error(\"CTF does not support asynchronous toPostgres functions.\");\n            }\n            return {\n                toPostgres,\n                rawType\n            };\n        }\n    }\n    return null;\n}\n/////////////////////////////////////////\n// Wraps a text string in single quotes;\nfunction wrapText(text) {\n    return `'${text}'`;\n}\n////////////////////////////////////////////////\n// Replaces each single-quote symbol ' with two,\n// for compliance with PostgreSQL strings.\nfunction safeText(text) {\n    return text.replace(/'/g, \"''\");\n}\n/////////////////////////////////////////////\n// Throws an exception, if flag 'raw' is set.\nfunction throwIfRaw(raw) {\n    if (raw) {\n        throw new TypeError(\"Values null/undefined cannot be used as raw text.\");\n    }\n}\n/////////////////////////////////////////////////////////////////////////////\n// Recursively resolves parameter-function, with an optional Calling Context.\nfunction resolveFunc(value, cc) {\n    while(typeof value === \"function\"){\n        if (value.constructor.name !== \"Function\") {\n            // Constructor name for asynchronous functions have different names:\n            // - 'GeneratorFunction' for ES6 generators\n            // - 'AsyncFunction' for ES7 async functions\n            throw new Error(\"Cannot use asynchronous functions with query formatting.\");\n        }\n        value = value.call(cc, cc);\n    }\n    return value;\n}\n///////////////////////////////////////////////////////////////////////////////////\n// It implements two types of formatting, depending on the 'values' passed:\n//\n// 1. format '$1, $2, etc', when 'values' is of type string, boolean, number, date,\n//    function or null (or an array of the same types, plus undefined values);\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\n//\nfunction formatQuery(query, values, raw, options) {\n    if (typeof query !== \"string\") {\n        throw new TypeError(\"Parameter 'query' must be a text string.\");\n    }\n    const ctf = getCTF(values);\n    if (ctf) {\n        // Custom Type Formatting\n        return formatQuery(query, resolveFunc(ctf.toPostgres, values), raw || ctf.rawType, options);\n    }\n    if (typeof values === \"object\" && values !== null) {\n        if (Array.isArray(values)) {\n            // $1, $2,... formatting to be applied;\n            return formatAs.array({\n                query,\n                array: values,\n                raw,\n                options\n            });\n        }\n        if (!(values instanceof Date || values instanceof Buffer)) {\n            // $*propName* formatting to be applied;\n            return formatAs.object({\n                query,\n                obj: values,\n                raw,\n                options\n            });\n        }\n    }\n    // $1 formatting to be applied, if values != undefined;\n    return values === undefined ? query : formatAs.value({\n        query,\n        value: values,\n        raw,\n        options\n    });\n}\n//////////////////////////////////////////////////////\n// Formats a function or stored procedure call query;\nfunction formatEntity(entity, values, { capSQL, type }) {\n    let prefix = type === \"func\" ? \"select * from\" : \"call\";\n    if (capSQL) {\n        prefix = prefix.toUpperCase();\n    }\n    return `${prefix} ${$as.alias(entity)}(${formatCSV(values, {\n        capSQL\n    })})`;\n}\nfunction formatSqlName(name) {\n    return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as` before and after initializing the library.\r\n *\r\n * @property {formatting.ctf} ctf\r\n * Namespace for symbols used by $[Custom Type Formatting].\r\n *\r\n * @property {function} alias\r\n * {@link formatting.alias alias} - formats an SQL alias.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL Name/Identifier.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} array\r\n * {@link formatting.array array} - formats an array of any depth.\r\n *\r\n * @property {function} csv\r\n * {@link formatting.csv csv} - formats an array as a list of comma-separated values.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query, according to parameters.\r\n *\r\n */ const $as = {\n    /**\r\n     * @namespace formatting.ctf\r\n     * @description\r\n     * Namespace for ES6 symbols used by $[Custom Type Formatting], available from `pgp.as.ctf` before and after initializing the library.\r\n     *\r\n     * It was added to avoid explicit/enumerable extension of types that need to be used as formatting parameters, to keep their type signature intact.\r\n     *\r\n     * @property {external:Symbol} toPostgres\r\n     * Property name for the $[Custom Type Formatting] callback function `toPostgres`.\r\n     *\r\n     * @property {external:Symbol} rawType\r\n     * Property name for the $[Custom Type Formatting] flag `rawType`.\r\n     *\r\n     * @example\r\n     * const ctf = pgp.as.ctf; // Custom Type Formatting symbols\r\n     *\r\n     * class MyType {\r\n     *     constructor() {\r\n     *         this[ctf.rawType] = true; // set it only when toPostgres returns a pre-formatted result\r\n     *     }\r\n     *\r\n     *     [ctf.toPostgres](self) {\r\n     *         // self = this\r\n     *\r\n     *         // return the custom/actual value here\r\n     *     }\r\n     * }\r\n     *\r\n     * const a = new MyType();\r\n     *\r\n     * const s = pgp.as.format('$1', a); // will be custom-formatted\r\n     */ ctf: ctfSymbols,\n    /**\r\n     * @method formatting.text\r\n     * @description\r\n     * Converts a value into PostgreSQL text presentation, escaped as required.\r\n     *\r\n     * Escaping the result means:\r\n     *  1. Every single-quote (apostrophe) is replaced with two\r\n     *  2. The resulting text is wrapped in apostrophes\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n     * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the resulting text.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * - `null` string, if the `value` resolves as `null` or `undefined`\r\n     * - escaped result of `value.toString()`, if the `value` isn't a string\r\n     * - escaped string version, if `value` is a string.\r\n     *\r\n     *  The result is not escaped, if `raw` was passed in as `true`.\r\n     */ text (value, raw) {\n        value = resolveFunc(value);\n        if (isNull(value)) {\n            throwIfRaw(raw);\n            return \"null\";\n        }\n        if (typeof value !== \"string\") {\n            value = value.toString();\n        }\n        return $to.text(value, raw);\n    },\n    /**\r\n     * @method formatting.name\r\n     * @description\r\n     * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n     *\r\n     * Implements a safe way to format $[SQL Names] that neutralizes SQL Injection.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:name` or `~`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function|array|object} name\r\n     * SQL name or identifier, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n     *\r\n     * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n     *\r\n     * - If `name` is an Array, it is formatted as a comma-separated list of $[SQL Names]\r\n     * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of $[SQL Names]\r\n     *\r\n     * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n     *\r\n     * @returns {string}\r\n     * The SQL Name/Identifier, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.alias alias},\r\n     * {@link formatting.format format}\r\n     *\r\n     * @example\r\n     *\r\n     * // automatically list object properties as sql names:\r\n     * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n     *     one: 1,\r\n     *     two: 2\r\n     * });\r\n     * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n     *\r\n     */ name (name) {\n        name = resolveFunc(name);\n        if (name) {\n            if (typeof name === \"string\") {\n                return /^\\s*\\*(\\s*)$/.test(name) ? name : formatSqlName(name);\n            }\n            if (typeof name === \"object\") {\n                const keys = Array.isArray(name) ? name : Object.keys(name);\n                if (!keys.length) {\n                    throw new Error(\"Cannot retrieve sql names from an empty array/object.\");\n                }\n                return keys.map((value)=>{\n                    if (!value || typeof value !== \"string\") {\n                        throw new Error(`Invalid sql name: ${npm.utils.toJson(value)}`);\n                    }\n                    return formatSqlName(value);\n                }).join();\n            }\n        }\n        throw new TypeError(`Invalid sql name: ${npm.utils.toJson(name)}`);\n    },\n    /**\r\n     * @method formatting.alias\r\n     * @description\r\n     * Simpler (non-verbose) version of method {@link formatting.name name}, to handle only a regular string-identifier\r\n     * that's mostly used as an SQL alias, i.e. it doesn't support `*` or an array/object of names, which in the context of\r\n     * an SQL alias would be incorrect. However, it supports `.` as name-separator, for simpler escaping of composite names.\r\n     *\r\n     * The surrounding double quotes are not added when the alias uses a simple syntax:\r\n     *  - it is a same-case single word, without spaces\r\n     *  - it can contain underscores, and can even start with them\r\n     *  - it can contain digits and `$`, but cannot start with those\r\n     *\r\n     * The method will automatically split the string with `.`, to support composite SQL names.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:alias`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {string|function} name\r\n     * SQL alias name, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long. And it can contain `.`, to split into multiple SQL names.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql alias: ...`\r\n     *\r\n     * @returns {string}\r\n     * The SQL alias, properly escaped for compliance with the PostgreSQL standard for $[SQL Names] and identifiers.\r\n     *\r\n     * @see\r\n     * {@link formatting.name name},\r\n     * {@link formatting.format format}\r\n     *\r\n     */ alias (name) {\n        name = resolveFunc(name);\n        if (name && typeof name === \"string\") {\n            return name.split(\".\").filter((f)=>f).map((a)=>{\n                const m = a.match(/^([a-z_][a-z0-9_$]*|[A-Z_][A-Z0-9_$]*)$/);\n                if (m && m[0] === a) {\n                    return a;\n                }\n                return `\"${a.replace(/\"/g, '\"\"')}\"`;\n            }).join(\".\");\n        }\n        throw new TypeError(`Invalid sql alias: ${npm.utils.toJson(name)}`);\n    },\n    /**\r\n     * @method formatting.value\r\n     * @description\r\n     * Represents an open value, one to be formatted according to its type, properly escaped, but without surrounding quotes for text types.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:value` or `#`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *\r\n     * @returns {string}\r\n     * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n     *\r\n     * @see {@link formatting.format format}\r\n     *\r\n     */ value (value) {\n        value = resolveFunc(value);\n        if (isNull(value)) {\n            throw new TypeError(\"Open values cannot be null or undefined.\");\n        }\n        return safeText(formatValue({\n            value,\n            fm: fmFlags.raw\n        }));\n    },\n    /**\r\n     * @method formatting.buffer\r\n     * @description\r\n     * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n     *\r\n     * @param {Buffer|function} obj\r\n     * Object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to wrap the resulting string in quotes.\r\n     *\r\n     * The generated hex string doesn't need to be escaped.\r\n     *\r\n     * @returns {string}\r\n     */ buffer (obj, raw) {\n        obj = resolveFunc(obj);\n        if (isNull(obj)) {\n            throwIfRaw(raw);\n            return \"null\";\n        }\n        if (obj instanceof Buffer) {\n            return $to.buffer(obj, raw);\n        }\n        throw new TypeError(`${wrapText(obj)} is not a Buffer object.`);\n    },\n    /**\r\n     * @method formatting.bool\r\n     * @description\r\n     * Converts a truthy value into PostgreSQL boolean presentation.\r\n     *\r\n     * @param {boolean|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * @returns {string}\r\n     */ bool (value) {\n        value = resolveFunc(value);\n        if (isNull(value)) {\n            return \"null\";\n        }\n        return $to.bool(value);\n    },\n    /**\r\n     * @method formatting.date\r\n     * @description\r\n     * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n     * wrapped in quotes (unless flag `raw` is set).\r\n     *\r\n     * @param {Date|function} d\r\n     * Date object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the value.\r\n     *\r\n     * @returns {string}\r\n     */ date (d, raw) {\n        d = resolveFunc(d);\n        if (isNull(d)) {\n            throwIfRaw(raw);\n            return \"null\";\n        }\n        if (d instanceof Date) {\n            return $to.date(d, raw);\n        }\n        throw new TypeError(`${wrapText(d)} is not a Date object.`);\n    },\n    /**\r\n     * @method formatting.number\r\n     * @description\r\n     * Converts a numeric value into its PostgreSQL number presentation, with support\r\n     * for special values of `NaN`, `+Infinity` and `-Infinity`.\r\n     *\r\n     * @param {number|bigint|function} num\r\n     * Number to be converted, or a function that returns one.\r\n     *\r\n     * @returns {string}\r\n     */ number (num) {\n        num = resolveFunc(num);\n        if (isNull(num)) {\n            return \"null\";\n        }\n        const t = typeof num;\n        if (t !== \"number\" && t !== \"bigint\") {\n            throw new TypeError(`${wrapText(num)} is not a number.`);\n        }\n        return $to.number(num);\n    },\n    /**\r\n     * @method formatting.array\r\n     * @description\r\n     * Converts an array of values into its PostgreSQL presentation as an Array-Type constructor string: `array[]`.\r\n     *\r\n     * Top-level empty arrays are formatted as literal `{}`, to avoid the necessity of explicit type casting,\r\n     * as the server cannot automatically infer type of empty non-literal array.\r\n     *\r\n     * @param {Array|function} arr\r\n     * Array to be converted, or a function that returns one.\r\n     *\r\n     * @param {{}} [options]\r\n     * Array-Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * When `true`, outputs `ARRAY` instead of `array`.\r\n     *\r\n     * @returns {string}\r\n     */ array (arr, options) {\n        options = assert(options, [\n            \"capSQL\"\n        ]);\n        arr = resolveFunc(arr);\n        if (isNull(arr)) {\n            return \"null\";\n        }\n        if (Array.isArray(arr)) {\n            return $to.array(arr, options);\n        }\n        throw new TypeError(`${wrapText(arr)} is not an Array object.`);\n    },\n    /**\r\n     * @method formatting.csv\r\n     * @description\r\n     * Converts a single value or an array of values into a CSV (comma-separated values) string, with all values formatted\r\n     * according to their JavaScript type.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:csv` or its alias `:list`.\r\n     *\r\n     * When `values` is an object that's not `null` or `Array`, its properties are enumerated for the actual values.\r\n     *\r\n     * @param {Array|Object|value|function} values\r\n     * Value(s) to be converted, or a function that returns it.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */ csv (values) {\n        return $to.csv(values);\n    },\n    /**\r\n     * @method formatting.json\r\n     * @description\r\n     * Converts any value into JSON (includes `BigInt` support), and returns it as a valid string,\r\n     * with single-quote symbols fixed, unless flag `raw` is set.\r\n     *\r\n     * When formatting a query, a variable makes use of this method via modifier `:json`. See method {@link formatting.format format}.\r\n     *\r\n     * @param {*} data\r\n     * Object/value to be converted, or a function that returns it.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * @see {@link formatting.format format}\r\n     */ json (data, raw) {\n        data = resolveFunc(data);\n        if (isNull(data)) {\n            throwIfRaw(raw);\n            return \"null\";\n        }\n        return $to.json(data, raw);\n    },\n    /**\r\n     * @method formatting.func\r\n     * @description\r\n     * Calls the function to get the actual value, and then formats the result according to its type + `raw` flag.\r\n     *\r\n     * @param {function} func\r\n     * Function to be called, with support for nesting.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @param {*} [cc]\r\n     * Calling Context: `this` + the only value to be passed into the function on all nested levels.\r\n     *\r\n     * @returns {string}\r\n     */ func (func, raw, cc) {\n        if (isNull(func)) {\n            throwIfRaw(raw);\n            return \"null\";\n        }\n        if (typeof func !== \"function\") {\n            throw new TypeError(`${wrapText(func)} is not a function.`);\n        }\n        const fm = raw ? fmFlags.raw : null;\n        return formatValue({\n            value: resolveFunc(func, cc),\n            fm,\n            cc\n        });\n    },\n    /**\r\n     * @method formatting.format\r\n     * @description\r\n     * Replaces variables in a string according to the type of `values`:\r\n     *\r\n     * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `bigint`, `Date`, `Buffer` or when it is `null`.\r\n     *\r\n     * - Replaces variables `$1`, `$2`, ...`$100000` when `values` is an array of parameters. It throws a {@link external:RangeError RangeError}\r\n     * when the values or variables are out of range.\r\n     *\r\n     * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n     * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n     *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n     *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n     *\r\n     * - Supports $[Nested Named Parameters] of any depth.\r\n     *\r\n     * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n     *\r\n     * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n     *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n     *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n     *\r\n     * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n     *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n     *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n     *\r\n     * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n     *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n     *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n     *\r\n     * - Modifier `:alias` - non-verbose $[SQL Names] escaping.\r\n     *\r\n     * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n     *\r\n     * - CSV override ends with `:csv` or `:list` to format an array as a properly escaped comma-separated list of values.\r\n     *\r\n     * @param {string|QueryFile|object} query\r\n     * A query string, a {@link QueryFile} or any object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n     *\r\n     * @param {array|object|value} [values]\r\n     * Formatting parameter(s) / variable value(s).\r\n     *\r\n     * @param {{}} [options]\r\n     * Formatting Options.\r\n     *\r\n     * @param {boolean} [options.capSQL=false]\r\n     * Formats reserved SQL words capitalized. Presently, this only concerns arrays, to output `ARRAY` when required.\r\n     *\r\n     * @param {boolean} [options.partial=false]\r\n     * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n     * property name that's missing within the formatting parameters.\r\n     *\r\n     * **NOTE:** This option has no meaning when option `def` is used.\r\n     *\r\n     * @param {*} [options.def]\r\n     * Sets default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n     * or property name that's missing within the formatting parameters.\r\n     *\r\n     * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n     * and to return the actual default value:\r\n     *\r\n     * - For $[Named Parameters] formatting:\r\n     *   - `name` - name of the property missing in the formatting object\r\n     *   - `obj` - the formatting object, and is the same as `this` context\r\n     *\r\n     * - For $[Index Variables] formatting:\r\n     *   - `index` - element's index (starts with 1) that's outside of the input array\r\n     *   - `arr` - the formatting/input array, and is the same as `this` context\r\n     *\r\n     *   You can tell which type of call it is by checking the type of the first parameter.\r\n     *\r\n     * @returns {string}\r\n     * Formatted query string.\r\n     *\r\n     * The function will throw an error, if any occurs during formatting.\r\n     */ format (query, values, options) {\n        options = assert(options, [\n            \"capSQL\",\n            \"partial\",\n            \"def\"\n        ]);\n        const ctf = getCTF(query);\n        if (ctf) {\n            query = ctf.toPostgres.call(query, query);\n        }\n        return formatQuery(query, values, false, options);\n    }\n};\n/* Pre-parsed type formatting */ const $to = {\n    array (arr, options) {\n        return formatArray(arr, options);\n    },\n    csv (values, options) {\n        return formatCSV(resolveFunc(values), options);\n    },\n    bool (value) {\n        return value ? \"true\" : \"false\";\n    },\n    buffer (obj, raw) {\n        const s = `\\\\x${obj.toString(\"hex\")}`;\n        return raw ? s : wrapText(s);\n    },\n    date (d, raw) {\n        const s = npm.pgUtils.prepareValue(d);\n        return raw ? s : wrapText(s);\n    },\n    json (data, raw) {\n        const s = npm.utils.toJson(data);\n        return raw ? s : wrapText(safeText(s));\n    },\n    number (num) {\n        if (typeof num === \"bigint\" || Number.isFinite(num)) {\n            return num.toString();\n        }\n        // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\n        // http://www.postgresql.org/docs/9.6/static/datatype-numeric.html#DATATYPE-FLOAT\n        //\n        // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\n        if (num === Number.POSITIVE_INFINITY) {\n            return wrapText(\"+Infinity\");\n        }\n        if (num === Number.NEGATIVE_INFINITY) {\n            return wrapText(\"-Infinity\");\n        }\n        return wrapText(\"NaN\");\n    },\n    text (value, raw) {\n        return raw ? value : wrapText(safeText(value));\n    }\n};\nmodule.exports = {\n    formatQuery,\n    formatEntity,\n    resolveFunc,\n    as: $as\n}; /**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */  /**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */  /**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */  /**\r\n * @external Symbol\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvZm9ybWF0dGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxNQUFNLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFekIsTUFBTUMsTUFBTTtJQUNSQyxTQUFTRixtQkFBT0EsQ0FBQztJQUNqQkcsVUFBVUgsbUJBQU9BLENBQUM7SUFDbEJJLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUEsNkJBQTZCO0FBQzdCLE1BQU1LLFVBQVU7SUFDWkMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU8sR0FBRywwQkFBMEI7QUFDeEM7QUFFQSwyQkFBMkI7QUFDM0IsTUFBTUMsUUFBUTtJQUNWLEtBQUtQLFFBQVFDLEdBQUc7SUFDaEIsUUFBUUQsUUFBUUMsR0FBRztJQUNuQixVQUFVRCxRQUFRRSxLQUFLO0lBQ3ZCLEtBQUtGLFFBQVFHLElBQUk7SUFDakIsU0FBU0gsUUFBUUcsSUFBSTtJQUNyQixTQUFTSCxRQUFRSSxJQUFJO0lBQ3JCLFFBQVFKLFFBQVFLLEdBQUc7SUFDbkIsU0FBU0wsUUFBUUssR0FBRztJQUNwQixVQUFVTCxRQUFRTSxLQUFLO0lBQ3ZCLEtBQUtOLFFBQVFNLEtBQUs7QUFDdEI7QUFFQSw2Q0FBNkM7QUFDN0MsTUFBTUUsYUFBYTtJQUNmQyxZQUFZQyxPQUFPQyxHQUFHLENBQUM7SUFDdkJDLFNBQVNGLE9BQU9DLEdBQUcsQ0FBQztBQUN4QjtBQUVBLE1BQU1FLGNBQWMsUUFBUSwwQ0FBMEM7QUFFdEUsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxTQUFTQyxZQUFZLEVBQUNSLEtBQUssRUFBRVMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBQztJQUV6QyxJQUFJLE9BQU9YLFVBQVUsWUFBWTtRQUM3QixPQUFPUSxZQUFZO1lBQUNSLE9BQU9ZLFlBQVlaLE9BQU9VO1lB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LElBQUlDLE9BQU8sQ0FBQ3dHLFlBQVksQ0FBQ25DO1FBQ25DLE9BQU9qRSxNQUFNbUcsSUFBSXBCLFNBQVNvQjtJQUM5QjtJQUNBaEcsTUFBSzZGLElBQUksRUFBRWhHLEdBQUc7UUFDVixNQUFNbUcsSUFBSXhHLElBQUlHLEtBQUssQ0FBQzBGLE1BQU0sQ0FBQ1E7UUFDM0IsT0FBT2hHLE1BQU1tRyxJQUFJcEIsU0FBU0MsU0FBU21CO0lBQ3ZDO0lBQ0F4RSxRQUFPa0UsR0FBRztRQUNOLElBQUksT0FBT0EsUUFBUSxZQUFZUSxPQUFPQyxRQUFRLENBQUNULE1BQU07WUFDakQsT0FBT0EsSUFBSWhFLFFBQVE7UUFDdkI7UUFDQSwwRUFBMEU7UUFDMUUsaUZBQWlGO1FBQ2pGLEVBQUU7UUFDRiwwRUFBMEU7UUFDMUUsSUFBSWdFLFFBQVFRLE9BQU9FLGlCQUFpQixFQUFFO1lBQ2xDLE9BQU94QixTQUFTO1FBQ3BCO1FBQ0EsSUFBSWMsUUFBUVEsT0FBT0csaUJBQWlCLEVBQUU7WUFDbEMsT0FBT3pCLFNBQVM7UUFDcEI7UUFDQSxPQUFPQSxTQUFTO0lBQ3BCO0lBQ0F0RCxNQUFLcEIsS0FBSyxFQUFFTCxHQUFHO1FBQ1gsT0FBT0EsTUFBTUssUUFBUTBFLFNBQVNDLFNBQVMzRTtJQUMzQztBQUNKO0FBRUFvRyxPQUFPQyxPQUFPLEdBQUc7SUFDYnpCO0lBQ0FDO0lBQ0FqRTtJQUNBMEYsSUFBSXRGO0FBQ1IsR0FFQTs7O0NBR0MsSUFFRDs7O0NBR0MsSUFFRDs7O0NBR0MsSUFFRDs7O0NBR0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9mb3JtYXR0aW5nLmpzPzQwMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHthc3NlcnR9ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIHBnVXRpbHM6IHJlcXVpcmUoJ3BnL2xpYi91dGlscycpLFxyXG4gICAgcGF0dGVybnM6IHJlcXVpcmUoJy4vcGF0dGVybnMnKSxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJylcclxufTtcclxuXHJcbi8vIEZvcm1hdCBNb2RpZmljYXRpb24gRmxhZ3M7XHJcbmNvbnN0IGZtRmxhZ3MgPSB7XHJcbiAgICByYXc6IDEsIC8vIFJhdy1UZXh0IHZhcmlhYmxlXHJcbiAgICBhbGlhczogMiwgLy8gU1FMIEFsaWFzXHJcbiAgICBuYW1lOiA0LCAvLyBTUUwgTmFtZS9JZGVudGlmaWVyXHJcbiAgICBqc29uOiA4LCAvLyBKU09OIG1vZGlmaWVyXHJcbiAgICBjc3Y6IDE2LCAvLyBDU1YgbW9kaWZpZXJcclxuICAgIHZhbHVlOiAzMiAvLyBlc2NhcGVkLCBidXQgd2l0aG91dCAnJ1xyXG59O1xyXG5cclxuLy8gRm9ybWF0IE1vZGlmaWNhdGlvbiBNYXA7XHJcbmNvbnN0IGZtTWFwID0ge1xyXG4gICAgJ14nOiBmbUZsYWdzLnJhdyxcclxuICAgICc6cmF3JzogZm1GbGFncy5yYXcsXHJcbiAgICAnOmFsaWFzJzogZm1GbGFncy5hbGlhcyxcclxuICAgICd+JzogZm1GbGFncy5uYW1lLFxyXG4gICAgJzpuYW1lJzogZm1GbGFncy5uYW1lLFxyXG4gICAgJzpqc29uJzogZm1GbGFncy5qc29uLFxyXG4gICAgJzpjc3YnOiBmbUZsYWdzLmNzdixcclxuICAgICc6bGlzdCc6IGZtRmxhZ3MuY3N2LFxyXG4gICAgJzp2YWx1ZSc6IGZtRmxhZ3MudmFsdWUsXHJcbiAgICAnIyc6IGZtRmxhZ3MudmFsdWVcclxufTtcclxuXHJcbi8vIEdsb2JhbCBzeW1ib2xzIGZvciBDdXN0b20gVHlwZSBGb3JtYXR0aW5nOlxyXG5jb25zdCBjdGZTeW1ib2xzID0ge1xyXG4gICAgdG9Qb3N0Z3JlczogU3ltYm9sLmZvcignY3RmLnRvUG9zdGdyZXMnKSxcclxuICAgIHJhd1R5cGU6IFN5bWJvbC5mb3IoJ2N0Zi5yYXdUeXBlJylcclxufTtcclxuXHJcbmNvbnN0IG1heFZhcmlhYmxlID0gMTAwMDAwOyAvLyBtYXhpbXVtIHN1cHBvcnRlZCB2YXJpYWJsZSBpcyAnJDEwMDAwMCdcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQ29udmVydHMgYSBzaW5nbGUgdmFsdWUgaW50byBpdHMgUG9zdGdyZXMgZm9ybWF0LlxyXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh7dmFsdWUsIGZtLCBjYywgb3B0aW9uc30pIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHt2YWx1ZTogcmVzb2x2ZUZ1bmModmFsdWUsIGNjKSwgZm0sIGNjfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3RmID0gZ2V0Q1RGKHZhbHVlKTsgLy8gQ3VzdG9tIFR5cGUgRm9ybWF0dGluZ1xyXG4gICAgaWYgKGN0Zikge1xyXG4gICAgICAgIGZtIHw9IGN0Zi5yYXdUeXBlID8gZm1GbGFncy5yYXcgOiAwO1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSh7dmFsdWU6IHJlc29sdmVGdW5jKGN0Zi50b1Bvc3RncmVzLCB2YWx1ZSksIGZtLCBjY30pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzUmF3ID0gISEoZm0gJiBmbUZsYWdzLnJhdyk7XHJcbiAgICBmbSAmPSB+Zm1GbGFncy5yYXc7XHJcblxyXG4gICAgc3dpdGNoIChmbSkge1xyXG4gICAgICAgIGNhc2UgZm1GbGFncy5hbGlhczpcclxuICAgICAgICAgICAgcmV0dXJuICRhcy5hbGlhcyh2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSBmbUZsYWdzLm5hbWU6XHJcbiAgICAgICAgICAgIHJldHVybiAkYXMubmFtZSh2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSBmbUZsYWdzLmpzb246XHJcbiAgICAgICAgICAgIHJldHVybiAkYXMuanNvbih2YWx1ZSwgaXNSYXcpO1xyXG4gICAgICAgIGNhc2UgZm1GbGFncy5jc3Y6XHJcbiAgICAgICAgICAgIHJldHVybiAkdG8uY3N2KHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICBjYXNlIGZtRmxhZ3MudmFsdWU6XHJcbiAgICAgICAgICAgIHJldHVybiAkYXMudmFsdWUodmFsdWUpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3dJZlJhdyhpc1Jhdyk7XHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIHJldHVybiAkdG8udGV4dCh2YWx1ZSwgaXNSYXcpO1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICByZXR1cm4gJHRvLmJvb2wodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgY2FzZSAnYmlnaW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICR0by5udW1iZXIodmFsdWUpO1xyXG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFR5cGUgU3ltYm9sIGhhcyBubyBtZWFuaW5nIGZvciBQb3N0Z3JlU1FMOiAke3ZhbHVlLnRvU3RyaW5nKCl9YCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICR0by5kYXRlKHZhbHVlLCBpc1Jhdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJHRvLmFycmF5KHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICR0by5idWZmZXIodmFsdWUsIGlzUmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJHRvLmpzb24odmFsdWUsIGlzUmF3KTtcclxuICAgIH1cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBDb252ZXJ0cyBhcnJheSBvZiB2YWx1ZXMgaW50byBQb3N0Z3JlU1FMIEFycmF5IENvbnN0cnVjdG9yOiBhcnJheVsuLi5dLCBhcyBwZXIgUG9zdGdyZVNRTCBkb2N1bWVudGF0aW9uOlxyXG4vLyBodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS42L3N0YXRpYy9hcnJheXMuaHRtbFxyXG4vL1xyXG4vLyBBcnJheXMgb2YgYW55IGRlcHRoL2RpbWVuc2lvbiBhcmUgc3VwcG9ydGVkLlxyXG4vL1xyXG4vLyBUb3AtbGV2ZWwgZW1wdHkgYXJyYXlzIGFyZSBmb3JtYXR0ZWQgYXMgbGl0ZXJhbCAne30nIHRvIGF2b2lkIHRoZSBuZWNlc3NpdHkgb2YgZXhwbGljaXQgdHlwZSBjYXN0aW5nLFxyXG4vLyBhcyB0aGUgc2VydmVyIGNhbm5vdCBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSB0eXBlIG9mIGVtcHR5IG5vbi1saXRlcmFsIGFycmF5LlxyXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbG9vcCA9IGEgPT4gJ1snICsgYS5tYXAodmFsdWUgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBsb29wKHZhbHVlKSA6IGZvcm1hdFZhbHVlKHtcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICB9KSkuam9pbigpICsgJ10nO1xyXG4gICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhcFNRTCA/ICdBUlJBWScgOiAnYXJyYXknO1xyXG4gICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA/IChwcmVmaXggKyBsb29wKGFycmF5KSkgOiAnXFwne31cXCcnO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEZvcm1hdHMgYXJyYXkvb2JqZWN0L3ZhbHVlIGFzIGEgbGlzdCBvZiBjb21tYS1zZXBhcmF0ZWQgdmFsdWVzLlxyXG5mdW5jdGlvbiBmb3JtYXRDU1YodmFsdWVzLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAodmFsdWUgPT4gZm9ybWF0VmFsdWUoe3ZhbHVlLCBvcHRpb25zfSkpLmpvaW4oKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJiB2YWx1ZXMgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWVzKS5tYXAodiA9PiBmb3JtYXRWYWx1ZSh7dmFsdWU6IHZhbHVlc1t2XSwgb3B0aW9uc30pKS5qb2luKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzID09PSB1bmRlZmluZWQgPyAnJyA6IGZvcm1hdFZhbHVlKHt2YWx1ZTogdmFsdWVzLCBvcHRpb25zfSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUXVlcnkgZm9ybWF0dGluZyBoZWxwZXJzO1xyXG5jb25zdCBmb3JtYXRBcyA9IHtcclxuXHJcbiAgICBvYmplY3Qoe3F1ZXJ5LCBvYmosIHJhdywgb3B0aW9uc30pIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnJlcGxhY2UobnBtLnBhdHRlcm5zLm5hbWVkUGFyYW1ldGVycywgbmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHYgPSBmb3JtYXRBcy5zdHJpcE5hbWUobmFtZS5yZXBsYWNlKC9eXFwkW3soPFsvXXxbXFxzfSk+XFxdL10vZywgJycpLCByYXcpLFxyXG4gICAgICAgICAgICAgICAgYyA9IG5wbS51dGlscy5nZXRJZkhhcyhvYmosIHYubmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghYy52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByb3BlcnR5IG5hbWUgJyR7di5uYW1lfScuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMuaGFzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoe3ZhbHVlOiBjLnZhbHVlLCBmbTogdi5mbSwgY2M6IGMudGFyZ2V0LCBvcHRpb25zfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gJ3RoaXMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoe3ZhbHVlOiBvYmosIGZtOiB2LmZtLCBvcHRpb25zfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdkZWYnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBvcHRpb25zLmRlZiwgdmFsdWUgPSB0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJyA/IGQuY2FsbChvYmosIHYubmFtZSwgb2JqKSA6IGQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoe3ZhbHVlLCBmbTogdi5mbSwgY2M6IG9iaiwgb3B0aW9uc30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IG11c3QgZXhpc3QgYXMgdGhlIG9iamVjdCdzIG93biBvciBpbmhlcml0ZWQ7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7di5uYW1lfScgZG9lc24ndCBleGlzdC5gKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgYXJyYXkoe3F1ZXJ5LCBhcnJheSwgcmF3LCBvcHRpb25zfSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICByZXR1cm4gcXVlcnkucmVwbGFjZShucG0ucGF0dGVybnMubXVsdGlwbGVWYWx1ZXMsIG5hbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gZm9ybWF0QXMuc3RyaXBOYW1lKG5hbWUuc3Vic3RyKDEpLCByYXcpO1xyXG4gICAgICAgICAgICBjb25zdCBpZHggPSB2Lm5hbWUgLSAxO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID49IG1heFZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFyaWFibGUgJCR7di5uYW1lfSBleGNlZWRzIHN1cHBvcnRlZCBtYXhpbXVtIG9mICQke21heFZhcmlhYmxlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpZHggPCBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSh7dmFsdWU6IGFycmF5W2lkeF0sIGZtOiB2LmZtLCBvcHRpb25zfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdkZWYnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBvcHRpb25zLmRlZiwgdmFsdWUgPSB0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJyA/IGQuY2FsbChhcnJheSwgaWR4LCBhcnJheSkgOiBkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHt2YWx1ZSwgZm06IHYuZm0sIG9wdGlvbnN9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJ0aWFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFyaWFibGUgJCR7di5uYW1lfSBvdXQgb2YgcmFuZ2UuIFBhcmFtZXRlcnMgYXJyYXkgbGVuZ3RoOiAke2FycmF5Lmxlbmd0aH1gKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgdmFsdWUoe3F1ZXJ5LCB2YWx1ZSwgcmF3LCBvcHRpb25zfSkge1xyXG4gICAgICAgIHJldHVybiBxdWVyeS5yZXBsYWNlKG5wbS5wYXR0ZXJucy5zaW5nbGVWYWx1ZSwgbmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHYgPSBmb3JtYXRBcy5zdHJpcE5hbWUobmFtZSwgcmF3KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHt2YWx1ZSwgZm06IHYuZm0sIG9wdGlvbnN9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RyaXBOYW1lKG5hbWUsIHJhdykge1xyXG4gICAgICAgIGNvbnN0IG1vZCA9IG5hbWUubWF0Y2gobnBtLnBhdHRlcm5zLmhhc1ZhbGlkTW9kaWZpZXIpO1xyXG4gICAgICAgIGlmIChtb2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUuc3Vic3RyKDAsIG1vZC5pbmRleCksXHJcbiAgICAgICAgICAgICAgICBmbTogZm1NYXBbbW9kWzBdXSB8IChyYXcgPyBmbUZsYWdzLnJhdyA6IDApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIGZtOiByYXcgPyBmbUZsYWdzLnJhdyA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gU2ltcGxlciBjaGVjayBmb3IgbnVsbC91bmRlZmluZWQ7XHJcbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBDaGVja3MgaWYgdGhlIHZhbHVlIHN1cHBvcnRzIEN1c3RvbSBUeXBlIEZvcm1hdHRpbmcsXHJcbi8vIHRvIHJldHVybiB7dG9Qb3N0Z3JlcywgcmF3VHlwZX0sIGlmIGl0IGRvZXMsIG9yIG51bGwgb3RoZXJ3aXNlLlxyXG5mdW5jdGlvbiBnZXRDVEYodmFsdWUpIHtcclxuICAgIGlmICghaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgIGxldCB0b1Bvc3RncmVzID0gdmFsdWVbY3RmU3ltYm9scy50b1Bvc3RncmVzXSwgcmF3VHlwZSA9ICEhdmFsdWVbY3RmU3ltYm9scy5yYXdUeXBlXTtcclxuICAgICAgICBpZiAodHlwZW9mIHRvUG9zdGdyZXMgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdG9Qb3N0Z3JlcyA9IHZhbHVlLnRvUG9zdGdyZXM7XHJcbiAgICAgICAgICAgIHJhd1R5cGUgPSAhIXZhbHVlLnJhd1R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdG9Qb3N0Z3JlcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAodG9Qb3N0Z3Jlcy5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnRnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NURiBkb2VzIG5vdCBzdXBwb3J0IGFzeW5jaHJvbm91cyB0b1Bvc3RncmVzIGZ1bmN0aW9ucy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge3RvUG9zdGdyZXMsIHJhd1R5cGV9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBXcmFwcyBhIHRleHQgc3RyaW5nIGluIHNpbmdsZSBxdW90ZXM7XHJcbmZ1bmN0aW9uIHdyYXBUZXh0KHRleHQpIHtcclxuICAgIHJldHVybiBgJyR7dGV4dH0nYDtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFJlcGxhY2VzIGVhY2ggc2luZ2xlLXF1b3RlIHN5bWJvbCAnIHdpdGggdHdvLFxyXG4vLyBmb3IgY29tcGxpYW5jZSB3aXRoIFBvc3RncmVTUUwgc3RyaW5ncy5cclxuZnVuY3Rpb24gc2FmZVRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvJy9nLCAnXFwnXFwnJyk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBUaHJvd3MgYW4gZXhjZXB0aW9uLCBpZiBmbGFnICdyYXcnIGlzIHNldC5cclxuZnVuY3Rpb24gdGhyb3dJZlJhdyhyYXcpIHtcclxuICAgIGlmIChyYXcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZXMgbnVsbC91bmRlZmluZWQgY2Fubm90IGJlIHVzZWQgYXMgcmF3IHRleHQuJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFJlY3Vyc2l2ZWx5IHJlc29sdmVzIHBhcmFtZXRlci1mdW5jdGlvbiwgd2l0aCBhbiBvcHRpb25hbCBDYWxsaW5nIENvbnRleHQuXHJcbmZ1bmN0aW9uIHJlc29sdmVGdW5jKHZhbHVlLCBjYykge1xyXG4gICAgd2hpbGUgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnRnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdG9yIG5hbWUgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgaGF2ZSBkaWZmZXJlbnQgbmFtZXM6XHJcbiAgICAgICAgICAgIC8vIC0gJ0dlbmVyYXRvckZ1bmN0aW9uJyBmb3IgRVM2IGdlbmVyYXRvcnNcclxuICAgICAgICAgICAgLy8gLSAnQXN5bmNGdW5jdGlvbicgZm9yIEVTNyBhc3luYyBmdW5jdGlvbnNcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgd2l0aCBxdWVyeSBmb3JtYXR0aW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY2MsIGNjKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSXQgaW1wbGVtZW50cyB0d28gdHlwZXMgb2YgZm9ybWF0dGluZywgZGVwZW5kaW5nIG9uIHRoZSAndmFsdWVzJyBwYXNzZWQ6XHJcbi8vXHJcbi8vIDEuIGZvcm1hdCAnJDEsICQyLCBldGMnLCB3aGVuICd2YWx1ZXMnIGlzIG9mIHR5cGUgc3RyaW5nLCBib29sZWFuLCBudW1iZXIsIGRhdGUsXHJcbi8vICAgIGZ1bmN0aW9uIG9yIG51bGwgKG9yIGFuIGFycmF5IG9mIHRoZSBzYW1lIHR5cGVzLCBwbHVzIHVuZGVmaW5lZCB2YWx1ZXMpO1xyXG4vLyAyLiBmb3JtYXQgJCpwcm9wTmFtZSosIHdoZW4gJ3ZhbHVlcycgaXMgYW4gb2JqZWN0IChub3QgbnVsbCBhbmQgbm90IERhdGUpLFxyXG4vLyAgICBhbmQgd2hlcmUgKiBpcyBhbnkgb2YgdGhlIHN1cHBvcnRlZCBvcGVuLWNsb3NlIHBhaXJzOiB7fSwgKCksIFtdLCA8PiwgLy9cclxuLy9cclxuZnVuY3Rpb24gZm9ybWF0UXVlcnkocXVlcnksIHZhbHVlcywgcmF3LCBvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdxdWVyeVxcJyBtdXN0IGJlIGEgdGV4dCBzdHJpbmcuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdGYgPSBnZXRDVEYodmFsdWVzKTtcclxuICAgIGlmIChjdGYpIHtcclxuICAgICAgICAvLyBDdXN0b20gVHlwZSBGb3JtYXR0aW5nXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFF1ZXJ5KHF1ZXJ5LCByZXNvbHZlRnVuYyhjdGYudG9Qb3N0Z3JlcywgdmFsdWVzKSwgcmF3IHx8IGN0Zi5yYXdUeXBlLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJiB2YWx1ZXMgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgIC8vICQxLCAkMiwuLi4gZm9ybWF0dGluZyB0byBiZSBhcHBsaWVkO1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0QXMuYXJyYXkoe3F1ZXJ5LCBhcnJheTogdmFsdWVzLCByYXcsIG9wdGlvbnN9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIC8vICQqcHJvcE5hbWUqIGZvcm1hdHRpbmcgdG8gYmUgYXBwbGllZDtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEFzLm9iamVjdCh7cXVlcnksIG9iajogdmFsdWVzLCByYXcsIG9wdGlvbnN9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAkMSBmb3JtYXR0aW5nIHRvIGJlIGFwcGxpZWQsIGlmIHZhbHVlcyAhPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdmFsdWVzID09PSB1bmRlZmluZWQgPyBxdWVyeSA6IGZvcm1hdEFzLnZhbHVlKHtxdWVyeSwgdmFsdWU6IHZhbHVlcywgcmF3LCBvcHRpb25zfSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBGb3JtYXRzIGEgZnVuY3Rpb24gb3Igc3RvcmVkIHByb2NlZHVyZSBjYWxsIHF1ZXJ5O1xyXG5mdW5jdGlvbiBmb3JtYXRFbnRpdHkoZW50aXR5LCB2YWx1ZXMsIHtjYXBTUUwsIHR5cGV9KSB7XHJcbiAgICBsZXQgcHJlZml4ID0gdHlwZSA9PT0gJ2Z1bmMnID8gJ3NlbGVjdCAqIGZyb20nIDogJ2NhbGwnO1xyXG4gICAgaWYgKGNhcFNRTCkge1xyXG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGAke3ByZWZpeH0gJHskYXMuYWxpYXMoZW50aXR5KX0oJHtmb3JtYXRDU1YodmFsdWVzLCB7Y2FwU1FMfSl9KWA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFNxbE5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIGBcIiR7bmFtZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgZm9ybWF0dGluZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogTmFtZXNwYWNlIGZvciBhbGwgcXVlcnktZm9ybWF0dGluZyBmdW5jdGlvbnMsIGF2YWlsYWJsZSBmcm9tIGBwZ3AuYXNgIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Zvcm1hdHRpbmcuY3RmfSBjdGZcclxuICogTmFtZXNwYWNlIGZvciBzeW1ib2xzIHVzZWQgYnkgJFtDdXN0b20gVHlwZSBGb3JtYXR0aW5nXS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gYWxpYXNcclxuICoge0BsaW5rIGZvcm1hdHRpbmcuYWxpYXMgYWxpYXN9IC0gZm9ybWF0cyBhbiBTUUwgYWxpYXMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG5hbWVcclxuICoge0BsaW5rIGZvcm1hdHRpbmcubmFtZSBuYW1lfSAtIGZvcm1hdHMgYW4gU1FMIE5hbWUvSWRlbnRpZmllci5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdGV4dFxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy50ZXh0IHRleHR9IC0gZm9ybWF0cyBhIHRleHQgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBudW1iZXJcclxuICoge0BsaW5rIGZvcm1hdHRpbmcubnVtYmVyIG51bWJlcn0gLSBmb3JtYXRzIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBidWZmZXJcclxuICoge0BsaW5rIGZvcm1hdHRpbmcuYnVmZmVyIGJ1ZmZlcn0gLSBmb3JtYXRzIGEgYEJ1ZmZlcmAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB2YWx1ZVxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy52YWx1ZSB2YWx1ZX0gLSBmb3JtYXRzIHRleHQgYXMgYW4gb3BlbiB2YWx1ZS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0ganNvblxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy5qc29uIGpzb259IC0gZm9ybWF0cyBhbnkgdmFsdWUgYXMgSlNPTi5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gYXJyYXlcclxuICoge0BsaW5rIGZvcm1hdHRpbmcuYXJyYXkgYXJyYXl9IC0gZm9ybWF0cyBhbiBhcnJheSBvZiBhbnkgZGVwdGguXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNzdlxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy5jc3YgY3N2fSAtIGZvcm1hdHMgYW4gYXJyYXkgYXMgYSBsaXN0IG9mIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGZ1bmNcclxuICoge0BsaW5rIGZvcm1hdHRpbmcuZnVuYyBmdW5jfSAtIGZvcm1hdHMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gYSBmdW5jdGlvbi5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZm9ybWF0XHJcbiAqIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBmb3JtYXR9IC0gZm9ybWF0cyBhIHF1ZXJ5LCBhY2NvcmRpbmcgdG8gcGFyYW1ldGVycy5cclxuICpcclxuICovXHJcbmNvbnN0ICRhcyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2UgZm9ybWF0dGluZy5jdGZcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogTmFtZXNwYWNlIGZvciBFUzYgc3ltYm9scyB1c2VkIGJ5ICRbQ3VzdG9tIFR5cGUgRm9ybWF0dGluZ10sIGF2YWlsYWJsZSBmcm9tIGBwZ3AuYXMuY3RmYCBiZWZvcmUgYW5kIGFmdGVyIGluaXRpYWxpemluZyB0aGUgbGlicmFyeS5cclxuICAgICAqXHJcbiAgICAgKiBJdCB3YXMgYWRkZWQgdG8gYXZvaWQgZXhwbGljaXQvZW51bWVyYWJsZSBleHRlbnNpb24gb2YgdHlwZXMgdGhhdCBuZWVkIHRvIGJlIHVzZWQgYXMgZm9ybWF0dGluZyBwYXJhbWV0ZXJzLCB0byBrZWVwIHRoZWlyIHR5cGUgc2lnbmF0dXJlIGludGFjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge2V4dGVybmFsOlN5bWJvbH0gdG9Qb3N0Z3Jlc1xyXG4gICAgICogUHJvcGVydHkgbmFtZSBmb3IgdGhlICRbQ3VzdG9tIFR5cGUgRm9ybWF0dGluZ10gY2FsbGJhY2sgZnVuY3Rpb24gYHRvUG9zdGdyZXNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7ZXh0ZXJuYWw6U3ltYm9sfSByYXdUeXBlXHJcbiAgICAgKiBQcm9wZXJ0eSBuYW1lIGZvciB0aGUgJFtDdXN0b20gVHlwZSBGb3JtYXR0aW5nXSBmbGFnIGByYXdUeXBlYC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY29uc3QgY3RmID0gcGdwLmFzLmN0ZjsgLy8gQ3VzdG9tIFR5cGUgRm9ybWF0dGluZyBzeW1ib2xzXHJcbiAgICAgKlxyXG4gICAgICogY2xhc3MgTXlUeXBlIHtcclxuICAgICAqICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAqICAgICAgICAgdGhpc1tjdGYucmF3VHlwZV0gPSB0cnVlOyAvLyBzZXQgaXQgb25seSB3aGVuIHRvUG9zdGdyZXMgcmV0dXJucyBhIHByZS1mb3JtYXR0ZWQgcmVzdWx0XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICBbY3RmLnRvUG9zdGdyZXNdKHNlbGYpIHtcclxuICAgICAqICAgICAgICAgLy8gc2VsZiA9IHRoaXNcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIC8vIHJldHVybiB0aGUgY3VzdG9tL2FjdHVhbCB2YWx1ZSBoZXJlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGEgPSBuZXcgTXlUeXBlKCk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgcyA9IHBncC5hcy5mb3JtYXQoJyQxJywgYSk7IC8vIHdpbGwgYmUgY3VzdG9tLWZvcm1hdHRlZFxyXG4gICAgICovXHJcbiAgICBjdGY6IGN0ZlN5bWJvbHMsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdHRpbmcudGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBDb252ZXJ0cyBhIHZhbHVlIGludG8gUG9zdGdyZVNRTCB0ZXh0IHByZXNlbnRhdGlvbiwgZXNjYXBlZCBhcyByZXF1aXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBFc2NhcGluZyB0aGUgcmVzdWx0IG1lYW5zOlxyXG4gICAgICogIDEuIEV2ZXJ5IHNpbmdsZS1xdW90ZSAoYXBvc3Ryb3BoZSkgaXMgcmVwbGFjZWQgd2l0aCB0d29cclxuICAgICAqICAyLiBUaGUgcmVzdWx0aW5nIHRleHQgaXMgd3JhcHBlZCBpbiBhcG9zdHJvcGhlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7dmFsdWV8ZnVuY3Rpb259IHZhbHVlXHJcbiAgICAgKiBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgYHZhbHVlYCByZXNvbHZlcyBhcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIHdoaWxlIGByYXdgPWB0cnVlYCxcclxuICAgICAqIGl0IHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYFZhbHVlcyBudWxsL3VuZGVmaW5lZCBjYW5ub3QgYmUgdXNlZCBhcyByYXcgdGV4dC5gXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmF3PWZhbHNlXVxyXG4gICAgICogSW5kaWNhdGVzIHdoZW4gbm90IHRvIGVzY2FwZSB0aGUgcmVzdWx0aW5nIHRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAtIGBudWxsYCBzdHJpbmcsIGlmIHRoZSBgdmFsdWVgIHJlc29sdmVzIGFzIGBudWxsYCBvciBgdW5kZWZpbmVkYFxyXG4gICAgICogLSBlc2NhcGVkIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAsIGlmIHRoZSBgdmFsdWVgIGlzbid0IGEgc3RyaW5nXHJcbiAgICAgKiAtIGVzY2FwZWQgc3RyaW5nIHZlcnNpb24sIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSByZXN1bHQgaXMgbm90IGVzY2FwZWQsIGlmIGByYXdgIHdhcyBwYXNzZWQgaW4gYXMgYHRydWVgLlxyXG4gICAgICovXHJcbiAgICB0ZXh0KHZhbHVlLCByYXcpIHtcclxuICAgICAgICB2YWx1ZSA9IHJlc29sdmVGdW5jKHZhbHVlKTtcclxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvd0lmUmF3KHJhdyk7XHJcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICR0by50ZXh0KHZhbHVlLCByYXcpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZm9ybWF0dGluZy5uYW1lXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFByb3Blcmx5IGVzY2FwZXMgYW4gc3FsIG5hbWUgb3IgaWRlbnRpZmllciwgZml4aW5nIGRvdWJsZS1xdW90ZSBzeW1ib2xzIGFuZCB3cmFwcGluZyB0aGUgcmVzdWx0IGluIGRvdWJsZSBxdW90ZXMuXHJcbiAgICAgKlxyXG4gICAgICogSW1wbGVtZW50cyBhIHNhZmUgd2F5IHRvIGZvcm1hdCAkW1NRTCBOYW1lc10gdGhhdCBuZXV0cmFsaXplcyBTUUwgSW5qZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gZm9ybWF0dGluZyBhIHF1ZXJ5LCBhIHZhcmlhYmxlIG1ha2VzIHVzZSBvZiB0aGlzIG1ldGhvZCB2aWEgbW9kaWZpZXIgYDpuYW1lYCBvciBgfmAuIFNlZSBtZXRob2Qge0BsaW5rIGZvcm1hdHRpbmcuZm9ybWF0IGZvcm1hdH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258YXJyYXl8b2JqZWN0fSBuYW1lXHJcbiAgICAgKiBTUUwgbmFtZSBvciBpZGVudGlmaWVyLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbmFtZSBtdXN0IGJlIGF0IGxlYXN0IDEgY2hhcmFjdGVyIGxvbmcuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYG5hbWVgIGRvZXNuJ3QgcmVzb2x2ZSBpbnRvIGEgbm9uLWVtcHR5IHN0cmluZywgaXQgdGhyb3dzIHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBJbnZhbGlkIHNxbCBuYW1lOiAuLi5gXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGBuYW1lYCBjb250YWlucyBvbmx5IGEgc2luZ2xlIGAqYCAodHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkKSwgdGhlbiBgbmFtZWAgaXMgcmV0dXJuZWQgZXhhY3RseSBhcyBpcyAodW5lc2NhcGVkKS5cclxuICAgICAqXHJcbiAgICAgKiAtIElmIGBuYW1lYCBpcyBhbiBBcnJheSwgaXQgaXMgZm9ybWF0dGVkIGFzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgJFtTUUwgTmFtZXNdXHJcbiAgICAgKiAtIElmIGBuYW1lYCBpcyBhIG5vbi1BcnJheSBvYmplY3QsIGl0cyBrZXlzIGFyZSBmb3JtYXR0ZWQgYXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiAkW1NRTCBOYW1lc11cclxuICAgICAqXHJcbiAgICAgKiBQYXNzaW5nIGluIGFuIGVtcHR5IGFycmF5L29iamVjdCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gPSBgQ2Fubm90IHJldHJpZXZlIHNxbCBuYW1lcyBmcm9tIGFuIGVtcHR5IGFycmF5L29iamVjdC5gXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIFRoZSBTUUwgTmFtZS9JZGVudGlmaWVyLCBwcm9wZXJseSBlc2NhcGVkIGZvciBjb21wbGlhbmNlIHdpdGggdGhlIFBvc3RncmVTUUwgc3RhbmRhcmQgZm9yICRbU1FMIE5hbWVzXSBhbmQgaWRlbnRpZmllcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZVxyXG4gICAgICoge0BsaW5rIGZvcm1hdHRpbmcuYWxpYXMgYWxpYXN9LFxyXG4gICAgICoge0BsaW5rIGZvcm1hdHRpbmcuZm9ybWF0IGZvcm1hdH1cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIC8vIGF1dG9tYXRpY2FsbHkgbGlzdCBvYmplY3QgcHJvcGVydGllcyBhcyBzcWwgbmFtZXM6XHJcbiAgICAgKiBmb3JtYXQoJ0lOU0VSVCBJTlRPIHRhYmxlKCR7dGhpc359KSBWQUxVRVMoJHtvbmV9LCAke3R3b30pJywge1xyXG4gICAgICogICAgIG9uZTogMSxcclxuICAgICAqICAgICB0d286IDJcclxuICAgICAqIH0pO1xyXG4gICAgICogLy89PiBJTlNFUlQgSU5UTyB0YWJsZShcIm9uZVwiLFwidHdvXCIpIFZBTFVFUygxLCAyKVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgbmFtZShuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IHJlc29sdmVGdW5jKG5hbWUpO1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAvXlxccypcXCooXFxzKikkLy50ZXN0KG5hbWUpID8gbmFtZSA6IGZvcm1hdFNxbE5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lIDogT2JqZWN0LmtleXMobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmV0cmlldmUgc3FsIG5hbWVzIGZyb20gYW4gZW1wdHkgYXJyYXkvb2JqZWN0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubWFwKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNxbCBuYW1lOiAke25wbS51dGlscy50b0pzb24odmFsdWUpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0U3FsTmFtZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzcWwgbmFtZTogJHtucG0udXRpbHMudG9Kc29uKG5hbWUpfWApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZm9ybWF0dGluZy5hbGlhc1xyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaW1wbGVyIChub24tdmVyYm9zZSkgdmVyc2lvbiBvZiBtZXRob2Qge0BsaW5rIGZvcm1hdHRpbmcubmFtZSBuYW1lfSwgdG8gaGFuZGxlIG9ubHkgYSByZWd1bGFyIHN0cmluZy1pZGVudGlmaWVyXHJcbiAgICAgKiB0aGF0J3MgbW9zdGx5IHVzZWQgYXMgYW4gU1FMIGFsaWFzLCBpLmUuIGl0IGRvZXNuJ3Qgc3VwcG9ydCBgKmAgb3IgYW4gYXJyYXkvb2JqZWN0IG9mIG5hbWVzLCB3aGljaCBpbiB0aGUgY29udGV4dCBvZlxyXG4gICAgICogYW4gU1FMIGFsaWFzIHdvdWxkIGJlIGluY29ycmVjdC4gSG93ZXZlciwgaXQgc3VwcG9ydHMgYC5gIGFzIG5hbWUtc2VwYXJhdG9yLCBmb3Igc2ltcGxlciBlc2NhcGluZyBvZiBjb21wb3NpdGUgbmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHN1cnJvdW5kaW5nIGRvdWJsZSBxdW90ZXMgYXJlIG5vdCBhZGRlZCB3aGVuIHRoZSBhbGlhcyB1c2VzIGEgc2ltcGxlIHN5bnRheDpcclxuICAgICAqICAtIGl0IGlzIGEgc2FtZS1jYXNlIHNpbmdsZSB3b3JkLCB3aXRob3V0IHNwYWNlc1xyXG4gICAgICogIC0gaXQgY2FuIGNvbnRhaW4gdW5kZXJzY29yZXMsIGFuZCBjYW4gZXZlbiBzdGFydCB3aXRoIHRoZW1cclxuICAgICAqICAtIGl0IGNhbiBjb250YWluIGRpZ2l0cyBhbmQgYCRgLCBidXQgY2Fubm90IHN0YXJ0IHdpdGggdGhvc2VcclxuICAgICAqXHJcbiAgICAgKiBUaGUgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBzcGxpdCB0aGUgc3RyaW5nIHdpdGggYC5gLCB0byBzdXBwb3J0IGNvbXBvc2l0ZSBTUUwgbmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBmb3JtYXR0aW5nIGEgcXVlcnksIGEgdmFyaWFibGUgbWFrZXMgdXNlIG9mIHRoaXMgbWV0aG9kIHZpYSBtb2RpZmllciBgOmFsaWFzYC4gU2VlIG1ldGhvZCB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgZm9ybWF0fS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gbmFtZVxyXG4gICAgICogU1FMIGFsaWFzIG5hbWUsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBuYW1lIG11c3QgYmUgYXQgbGVhc3QgMSBjaGFyYWN0ZXIgbG9uZy4gQW5kIGl0IGNhbiBjb250YWluIGAuYCwgdG8gc3BsaXQgaW50byBtdWx0aXBsZSBTUUwgbmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYG5hbWVgIGRvZXNuJ3QgcmVzb2x2ZSBpbnRvIGEgbm9uLWVtcHR5IHN0cmluZywgaXQgdGhyb3dzIHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBJbnZhbGlkIHNxbCBhbGlhczogLi4uYFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKiBUaGUgU1FMIGFsaWFzLCBwcm9wZXJseSBlc2NhcGVkIGZvciBjb21wbGlhbmNlIHdpdGggdGhlIFBvc3RncmVTUUwgc3RhbmRhcmQgZm9yICRbU1FMIE5hbWVzXSBhbmQgaWRlbnRpZmllcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZVxyXG4gICAgICoge0BsaW5rIGZvcm1hdHRpbmcubmFtZSBuYW1lfSxcclxuICAgICAqIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBmb3JtYXR9XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBhbGlhcyhuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IHJlc29sdmVGdW5jKG5hbWUpO1xyXG4gICAgICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZS5zcGxpdCgnLicpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGYgPT4gZilcclxuICAgICAgICAgICAgICAgIC5tYXAoYSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IGEubWF0Y2goL14oW2Etel9dW2EtejAtOV8kXSp8W0EtWl9dW0EtWjAtOV8kXSopJC8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMF0gPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgXCIke2EucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImA7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc3FsIGFsaWFzOiAke25wbS51dGlscy50b0pzb24obmFtZSl9YCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmb3JtYXR0aW5nLnZhbHVlXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJlcHJlc2VudHMgYW4gb3BlbiB2YWx1ZSwgb25lIHRvIGJlIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gaXRzIHR5cGUsIHByb3Blcmx5IGVzY2FwZWQsIGJ1dCB3aXRob3V0IHN1cnJvdW5kaW5nIHF1b3RlcyBmb3IgdGV4dCB0eXBlcy5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGZvcm1hdHRpbmcgYSBxdWVyeSwgYSB2YXJpYWJsZSBtYWtlcyB1c2Ugb2YgdGhpcyBtZXRob2QgdmlhIG1vZGlmaWVyIGA6dmFsdWVgIG9yIGAjYC4gU2VlIG1ldGhvZCB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgZm9ybWF0fS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfGZ1bmN0aW9ufSB2YWx1ZVxyXG4gICAgICogVmFsdWUgdG8gYmUgY29udmVydGVkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHZhbHVlYCByZXNvbHZlcyBhcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGl0IHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYE9wZW4gdmFsdWVzIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5gXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEZvcm1hdHRlZCBhbmQgcHJvcGVybHkgZXNjYXBlZCBzdHJpbmcsIGJ1dCB3aXRob3V0IHN1cnJvdW5kaW5nIHF1b3RlcyBmb3IgdGV4dCB0eXBlcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBmb3JtYXR9XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gcmVzb2x2ZUZ1bmModmFsdWUpO1xyXG4gICAgICAgIGlmIChpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09wZW4gdmFsdWVzIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNhZmVUZXh0KGZvcm1hdFZhbHVlKHt2YWx1ZSwgZm06IGZtRmxhZ3MucmF3fSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZm9ybWF0dGluZy5idWZmZXJcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IG9mIHR5cGUgYEJ1ZmZlcmAgaW50byBhIGhleCBzdHJpbmcgY29tcGF0aWJsZSB3aXRoIFBvc3RncmVTUUwgdHlwZSBgYnl0ZWFgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfGZ1bmN0aW9ufSBvYmpcclxuICAgICAqIE9iamVjdCB0byBiZSBjb252ZXJ0ZWQsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyYXc9ZmFsc2VdXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiBub3QgdG8gd3JhcCB0aGUgcmVzdWx0aW5nIHN0cmluZyBpbiBxdW90ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGdlbmVyYXRlZCBoZXggc3RyaW5nIGRvZXNuJ3QgbmVlZCB0byBiZSBlc2NhcGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGJ1ZmZlcihvYmosIHJhdykge1xyXG4gICAgICAgIG9iaiA9IHJlc29sdmVGdW5jKG9iaik7XHJcbiAgICAgICAgaWYgKGlzTnVsbChvYmopKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZSYXcocmF3KTtcclxuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gJHRvLmJ1ZmZlcihvYmosIHJhdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7d3JhcFRleHQob2JqKX0gaXMgbm90IGEgQnVmZmVyIG9iamVjdC5gKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdHRpbmcuYm9vbFxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBDb252ZXJ0cyBhIHRydXRoeSB2YWx1ZSBpbnRvIFBvc3RncmVTUUwgYm9vbGVhbiBwcmVzZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufGZ1bmN0aW9ufSB2YWx1ZVxyXG4gICAgICogVmFsdWUgdG8gYmUgY29udmVydGVkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgYm9vbCh2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gcmVzb2x2ZUZ1bmModmFsdWUpO1xyXG4gICAgICAgIGlmIChpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAkdG8uYm9vbCh2YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmb3JtYXR0aW5nLmRhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAtdHlwZSB2YWx1ZSBpbnRvIFBvc3RncmVTUUwgZGF0ZS90aW1lIHByZXNlbnRhdGlvbixcclxuICAgICAqIHdyYXBwZWQgaW4gcXVvdGVzICh1bmxlc3MgZmxhZyBgcmF3YCBpcyBzZXQpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RGF0ZXxmdW5jdGlvbn0gZFxyXG4gICAgICogRGF0ZSBvYmplY3QgdG8gYmUgY29udmVydGVkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmF3PWZhbHNlXVxyXG4gICAgICogSW5kaWNhdGVzIHdoZW4gbm90IHRvIGVzY2FwZSB0aGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZGF0ZShkLCByYXcpIHtcclxuICAgICAgICBkID0gcmVzb2x2ZUZ1bmMoZCk7XHJcbiAgICAgICAgaWYgKGlzTnVsbChkKSkge1xyXG4gICAgICAgICAgICB0aHJvd0lmUmF3KHJhdyk7XHJcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJHRvLmRhdGUoZCwgcmF3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt3cmFwVGV4dChkKX0gaXMgbm90IGEgRGF0ZSBvYmplY3QuYCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmb3JtYXR0aW5nLm51bWJlclxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBDb252ZXJ0cyBhIG51bWVyaWMgdmFsdWUgaW50byBpdHMgUG9zdGdyZVNRTCBudW1iZXIgcHJlc2VudGF0aW9uLCB3aXRoIHN1cHBvcnRcclxuICAgICAqIGZvciBzcGVjaWFsIHZhbHVlcyBvZiBgTmFOYCwgYCtJbmZpbml0eWAgYW5kIGAtSW5maW5pdHlgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJpZ2ludHxmdW5jdGlvbn0gbnVtXHJcbiAgICAgKiBOdW1iZXIgdG8gYmUgY29udmVydGVkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbnVtYmVyKG51bSkge1xyXG4gICAgICAgIG51bSA9IHJlc29sdmVGdW5jKG51bSk7XHJcbiAgICAgICAgaWYgKGlzTnVsbChudW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgbnVtO1xyXG4gICAgICAgIGlmICh0ICE9PSAnbnVtYmVyJyAmJiB0ICE9PSAnYmlnaW50Jykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3dyYXBUZXh0KG51bSl9IGlzIG5vdCBhIG51bWJlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICR0by5udW1iZXIobnVtKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdHRpbmcuYXJyYXlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQ29udmVydHMgYW4gYXJyYXkgb2YgdmFsdWVzIGludG8gaXRzIFBvc3RncmVTUUwgcHJlc2VudGF0aW9uIGFzIGFuIEFycmF5LVR5cGUgY29uc3RydWN0b3Igc3RyaW5nOiBgYXJyYXlbXWAuXHJcbiAgICAgKlxyXG4gICAgICogVG9wLWxldmVsIGVtcHR5IGFycmF5cyBhcmUgZm9ybWF0dGVkIGFzIGxpdGVyYWwgYHt9YCwgdG8gYXZvaWQgdGhlIG5lY2Vzc2l0eSBvZiBleHBsaWNpdCB0eXBlIGNhc3RpbmcsXHJcbiAgICAgKiBhcyB0aGUgc2VydmVyIGNhbm5vdCBhdXRvbWF0aWNhbGx5IGluZmVyIHR5cGUgb2YgZW1wdHkgbm9uLWxpdGVyYWwgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxmdW5jdGlvbn0gYXJyXHJcbiAgICAgKiBBcnJheSB0byBiZSBjb252ZXJ0ZWQsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3t9fSBbb3B0aW9uc11cclxuICAgICAqIEFycmF5LUZvcm1hdHRpbmcgT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhcFNRTD1mYWxzZV1cclxuICAgICAqIFdoZW4gYHRydWVgLCBvdXRwdXRzIGBBUlJBWWAgaW5zdGVhZCBvZiBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGFycmF5KGFyciwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBhc3NlcnQob3B0aW9ucywgWydjYXBTUUwnXSk7XHJcbiAgICAgICAgYXJyID0gcmVzb2x2ZUZ1bmMoYXJyKTtcclxuICAgICAgICBpZiAoaXNOdWxsKGFycikpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJHRvLmFycmF5KGFyciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7d3JhcFRleHQoYXJyKX0gaXMgbm90IGFuIEFycmF5IG9iamVjdC5gKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdHRpbmcuY3N2XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIENvbnZlcnRzIGEgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBpbnRvIGEgQ1NWIChjb21tYS1zZXBhcmF0ZWQgdmFsdWVzKSBzdHJpbmcsIHdpdGggYWxsIHZhbHVlcyBmb3JtYXR0ZWRcclxuICAgICAqIGFjY29yZGluZyB0byB0aGVpciBKYXZhU2NyaXB0IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBmb3JtYXR0aW5nIGEgcXVlcnksIGEgdmFyaWFibGUgbWFrZXMgdXNlIG9mIHRoaXMgbWV0aG9kIHZpYSBtb2RpZmllciBgOmNzdmAgb3IgaXRzIGFsaWFzIGA6bGlzdGAuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBgdmFsdWVzYCBpcyBhbiBvYmplY3QgdGhhdCdzIG5vdCBgbnVsbGAgb3IgYEFycmF5YCwgaXRzIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZm9yIHRoZSBhY3R1YWwgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHZhbHVlfGZ1bmN0aW9ufSB2YWx1ZXNcclxuICAgICAqIFZhbHVlKHMpIHRvIGJlIGNvbnZlcnRlZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBmb3JtYXR9XHJcbiAgICAgKi9cclxuICAgIGNzdih2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gJHRvLmNzdih2YWx1ZXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZm9ybWF0dGluZy5qc29uXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIENvbnZlcnRzIGFueSB2YWx1ZSBpbnRvIEpTT04gKGluY2x1ZGVzIGBCaWdJbnRgIHN1cHBvcnQpLCBhbmQgcmV0dXJucyBpdCBhcyBhIHZhbGlkIHN0cmluZyxcclxuICAgICAqIHdpdGggc2luZ2xlLXF1b3RlIHN5bWJvbHMgZml4ZWQsIHVubGVzcyBmbGFnIGByYXdgIGlzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGZvcm1hdHRpbmcgYSBxdWVyeSwgYSB2YXJpYWJsZSBtYWtlcyB1c2Ugb2YgdGhpcyBtZXRob2QgdmlhIG1vZGlmaWVyIGA6anNvbmAuIFNlZSBtZXRob2Qge0BsaW5rIGZvcm1hdHRpbmcuZm9ybWF0IGZvcm1hdH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICAgKiBPYmplY3QvdmFsdWUgdG8gYmUgY29udmVydGVkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyYXc9ZmFsc2VdXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiBub3QgdG8gZXNjYXBlIHRoZSByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBmb3JtYXR9XHJcbiAgICAgKi9cclxuICAgIGpzb24oZGF0YSwgcmF3KSB7XHJcbiAgICAgICAgZGF0YSA9IHJlc29sdmVGdW5jKGRhdGEpO1xyXG4gICAgICAgIGlmIChpc051bGwoZGF0YSkpIHtcclxuICAgICAgICAgICAgdGhyb3dJZlJhdyhyYXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJHRvLmpzb24oZGF0YSwgcmF3KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdHRpbmcuZnVuY1xyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBDYWxscyB0aGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGVuIGZvcm1hdHMgdGhlIHJlc3VsdCBhY2NvcmRpbmcgdG8gaXRzIHR5cGUgKyBgcmF3YCBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCwgd2l0aCBzdXBwb3J0IGZvciBuZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jhdz1mYWxzZV1cclxuICAgICAqIEluZGljYXRlcyB3aGVuIG5vdCB0byBlc2NhcGUgdGhlIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjY11cclxuICAgICAqIENhbGxpbmcgQ29udGV4dDogYHRoaXNgICsgdGhlIG9ubHkgdmFsdWUgdG8gYmUgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uIG9uIGFsbCBuZXN0ZWQgbGV2ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmMoZnVuYywgcmF3LCBjYykge1xyXG4gICAgICAgIGlmIChpc051bGwoZnVuYykpIHtcclxuICAgICAgICAgICAgdGhyb3dJZlJhdyhyYXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt3cmFwVGV4dChmdW5jKX0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZtID0gcmF3ID8gZm1GbGFncy5yYXcgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZSh7dmFsdWU6IHJlc29sdmVGdW5jKGZ1bmMsIGNjKSwgZm0sIGNjfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmb3JtYXR0aW5nLmZvcm1hdFxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBSZXBsYWNlcyB2YXJpYWJsZXMgaW4gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSB0eXBlIG9mIGB2YWx1ZXNgOlxyXG4gICAgICpcclxuICAgICAqIC0gUmVwbGFjZXMgYCQxYCBvY2N1cnJlbmNlcyB3aGVuIGB2YWx1ZXNgIGlzIG9mIHR5cGUgYHN0cmluZ2AsIGBib29sZWFuYCwgYG51bWJlcmAsIGBiaWdpbnRgLCBgRGF0ZWAsIGBCdWZmZXJgIG9yIHdoZW4gaXQgaXMgYG51bGxgLlxyXG4gICAgICpcclxuICAgICAqIC0gUmVwbGFjZXMgdmFyaWFibGVzIGAkMWAsIGAkMmAsIC4uLmAkMTAwMDAwYCB3aGVuIGB2YWx1ZXNgIGlzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMuIEl0IHRocm93cyBhIHtAbGluayBleHRlcm5hbDpSYW5nZUVycm9yIFJhbmdlRXJyb3J9XHJcbiAgICAgKiB3aGVuIHRoZSB2YWx1ZXMgb3IgdmFyaWFibGVzIGFyZSBvdXQgb2YgcmFuZ2UuXHJcbiAgICAgKlxyXG4gICAgICogLSBSZXBsYWNlcyBgJCpwcm9wTmFtZSpgLCB3aGVyZSBgKmAgaXMgYW55IG9mIGB7fWAsIGAoKWAsIGBbXWAsIGA8PmAsIGAvL2AsIHdoZW4gYHZhbHVlc2AgaXMgYW4gb2JqZWN0IHRoYXQncyBub3QgYVxyXG4gICAgICogYERhdGVgLCBgQnVmZmVyYCwge0BsaW5rIFF1ZXJ5RmlsZX0gb3IgYG51bGxgLiBTcGVjaWFsIHByb3BlcnR5IG5hbWUgYHRoaXNgIHJlZmVycyB0byB0aGUgZm9ybWF0dGluZyBvYmplY3QgaXRzZWxmLFxyXG4gICAgICogICB0byBiZSBpbmplY3RlZCBhcyBhIEpTT04gc3RyaW5nLiBXaGVuIHJlZmVyZW5jaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBmb3JtYXR0aW5nIG9iamVjdCwgaXQgdGhyb3dzXHJcbiAgICAgKiAgIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gPSBgUHJvcGVydHkgJ1Byb3BOYW1lJyBkb2Vzbid0IGV4aXN0YCwgdW5sZXNzIG9wdGlvbiBgcGFydGlhbGAgaXMgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiAtIFN1cHBvcnRzICRbTmVzdGVkIE5hbWVkIFBhcmFtZXRlcnNdIG9mIGFueSBkZXB0aC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBlYWNoIHZhcmlhYmxlIGlzIGF1dG9tYXRpY2FsbHkgZm9ybWF0dGVkIGFjY29yZGluZyB0byBpdHMgdHlwZSwgdW5sZXNzIGl0IGlzIGEgc3BlY2lhbCB2YXJpYWJsZTpcclxuICAgICAqXHJcbiAgICAgKiAtIFJhdy10ZXh0IHZhcmlhYmxlcyBlbmQgd2l0aCBgOnJhd2Agb3Igc3ltYm9sIGBeYCwgYW5kIHByZXZlbnQgZXNjYXBpbmcgdGhlIHRleHQuIFN1Y2ggdmFyaWFibGVzIGFyZSBub3RcclxuICAgICAqICAgYWxsb3dlZCB0byBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIG9yIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgVmFsdWVzIG51bGwvdW5kZWZpbmVkIGNhbm5vdCBiZSB1c2VkIGFzIHJhdyB0ZXh0LmBcclxuICAgICAqICAgLSBgJDE6cmF3YCwgYCQyOnJhd2AsLi4uLCBhbmQgYCQqcHJvcE5hbWU6cmF3KmAgKHNlZSBgKmAgYWJvdmUpXHJcbiAgICAgKiAgIC0gYCQxXmAsIGAkMl5gLC4uLiwgYW5kIGAkKnByb3BOYW1lXipgIChzZWUgYCpgIGFib3ZlKVxyXG4gICAgICpcclxuICAgICAqIC0gT3Blbi12YWx1ZSB2YXJpYWJsZXMgZW5kIHdpdGggYDp2YWx1ZWAgb3Igc3ltYm9sIGAjYCwgdG8gYmUgZXNjYXBlZCwgYnV0IG5vdCB3cmFwcGVkIGluIHF1b3Rlcy4gU3VjaCB2YXJpYWJsZXMgYXJlXHJcbiAgICAgKiAgIG5vdCBhbGxvd2VkIHRvIGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgb3IgdGhlIG1ldGhvZCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBPcGVuIHZhbHVlcyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuYFxyXG4gICAgICogICAtIGAkMTp2YWx1ZWAsIGAkMjp2YWx1ZWAsLi4uLCBhbmQgYCQqcHJvcE5hbWU6dmFsdWUqYCAoc2VlIGAqYCBhYm92ZSlcclxuICAgICAqICAgLSBgJDEjYCwgYCQyI2AsLi4uLCBhbmQgYCQqcHJvcE5hbWUjKmAgKHNlZSBgKmAgYWJvdmUpXHJcbiAgICAgKlxyXG4gICAgICogLSBTUUwgbmFtZSB2YXJpYWJsZXMgZW5kIHdpdGggYDpuYW1lYCBvciBzeW1ib2wgYH5gICh0aWxkZSksIGFuZCBwcm92aWRlIHByb3BlciBlc2NhcGluZyBmb3IgU1FMIG5hbWVzL2lkZW50aWZpZXJzOlxyXG4gICAgICogICAtIGAkMTpuYW1lYCwgYCQyOm5hbWVgLC4uLiwgYW5kIGAkKnByb3BOYW1lOm5hbWUqYCAoc2VlIGAqYCBhYm92ZSlcclxuICAgICAqICAgLSBgJDF+YCwgYCQyfmAsLi4uLCBhbmQgYCQqcHJvcE5hbWV+KmAgKHNlZSBgKmAgYWJvdmUpXHJcbiAgICAgKlxyXG4gICAgICogLSBNb2RpZmllciBgOmFsaWFzYCAtIG5vbi12ZXJib3NlICRbU1FMIE5hbWVzXSBlc2NhcGluZy5cclxuICAgICAqXHJcbiAgICAgKiAtIEpTT04gb3ZlcnJpZGUgZW5kcyB3aXRoIGA6anNvbmAgdG8gZm9ybWF0IHRoZSB2YWx1ZSBvZiBhbnkgdHlwZSBhcyBhIEpTT04gc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogLSBDU1Ygb3ZlcnJpZGUgZW5kcyB3aXRoIGA6Y3N2YCBvciBgOmxpc3RgIHRvIGZvcm1hdCBhbiBhcnJheSBhcyBhIHByb3Blcmx5IGVzY2FwZWQgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFF1ZXJ5RmlsZXxvYmplY3R9IHF1ZXJ5XHJcbiAgICAgKiBBIHF1ZXJ5IHN0cmluZywgYSB7QGxpbmsgUXVlcnlGaWxlfSBvciBhbnkgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyAkW0N1c3RvbSBUeXBlIEZvcm1hdHRpbmddLCB0byBiZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIGB2YWx1ZXNgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHZhbHVlfSBbdmFsdWVzXVxyXG4gICAgICogRm9ybWF0dGluZyBwYXJhbWV0ZXIocykgLyB2YXJpYWJsZSB2YWx1ZShzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3t9fSBbb3B0aW9uc11cclxuICAgICAqIEZvcm1hdHRpbmcgT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhcFNRTD1mYWxzZV1cclxuICAgICAqIEZvcm1hdHMgcmVzZXJ2ZWQgU1FMIHdvcmRzIGNhcGl0YWxpemVkLiBQcmVzZW50bHksIHRoaXMgb25seSBjb25jZXJucyBhcnJheXMsIHRvIG91dHB1dCBgQVJSQVlgIHdoZW4gcmVxdWlyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJ0aWFsPWZhbHNlXVxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgd2UgaW50ZW5kIHRvIGRvIG9ubHkgYSBwYXJ0aWFsIHJlcGxhY2VtZW50LCBpLmUuIHRocm93IG5vIGVycm9yIHdoZW4gZW5jb3VudGVyaW5nIGEgdmFyaWFibGUgb3JcclxuICAgICAqIHByb3BlcnR5IG5hbWUgdGhhdCdzIG1pc3Npbmcgd2l0aGluIHRoZSBmb3JtYXR0aW5nIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipOT1RFOioqIFRoaXMgb3B0aW9uIGhhcyBubyBtZWFuaW5nIHdoZW4gb3B0aW9uIGBkZWZgIGlzIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kZWZdXHJcbiAgICAgKiBTZXRzIGRlZmF1bHQgdmFsdWUgZm9yIGV2ZXJ5IHZhcmlhYmxlIHRoYXQncyBtaXNzaW5nLCBjb25zZXF1ZW50bHkgcHJldmVudGluZyBlcnJvcnMgd2hlbiBlbmNvdW50ZXJpbmcgYSB2YXJpYWJsZVxyXG4gICAgICogb3IgcHJvcGVydHkgbmFtZSB0aGF0J3MgbWlzc2luZyB3aXRoaW4gdGhlIGZvcm1hdHRpbmcgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBJdCBjYW4gYWxzbyBiZSBzZXQgdG8gYSBmdW5jdGlvbiwgdG8gYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnMgdGhhdCBkZXBlbmQgb24gdGhlIHR5cGUgb2YgZm9ybWF0dGluZyBiZWluZyB1c2VkLFxyXG4gICAgICogYW5kIHRvIHJldHVybiB0aGUgYWN0dWFsIGRlZmF1bHQgdmFsdWU6XHJcbiAgICAgKlxyXG4gICAgICogLSBGb3IgJFtOYW1lZCBQYXJhbWV0ZXJzXSBmb3JtYXR0aW5nOlxyXG4gICAgICogICAtIGBuYW1lYCAtIG5hbWUgb2YgdGhlIHByb3BlcnR5IG1pc3NpbmcgaW4gdGhlIGZvcm1hdHRpbmcgb2JqZWN0XHJcbiAgICAgKiAgIC0gYG9iamAgLSB0aGUgZm9ybWF0dGluZyBvYmplY3QsIGFuZCBpcyB0aGUgc2FtZSBhcyBgdGhpc2AgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIC0gRm9yICRbSW5kZXggVmFyaWFibGVzXSBmb3JtYXR0aW5nOlxyXG4gICAgICogICAtIGBpbmRleGAgLSBlbGVtZW50J3MgaW5kZXggKHN0YXJ0cyB3aXRoIDEpIHRoYXQncyBvdXRzaWRlIG9mIHRoZSBpbnB1dCBhcnJheVxyXG4gICAgICogICAtIGBhcnJgIC0gdGhlIGZvcm1hdHRpbmcvaW5wdXQgYXJyYXksIGFuZCBpcyB0aGUgc2FtZSBhcyBgdGhpc2AgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqICAgWW91IGNhbiB0ZWxsIHdoaWNoIHR5cGUgb2YgY2FsbCBpdCBpcyBieSBjaGVja2luZyB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKiBGb3JtYXR0ZWQgcXVlcnkgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGVycm9yLCBpZiBhbnkgb2NjdXJzIGR1cmluZyBmb3JtYXR0aW5nLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQocXVlcnksIHZhbHVlcywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBhc3NlcnQob3B0aW9ucywgWydjYXBTUUwnLCAncGFydGlhbCcsICdkZWYnXSk7XHJcbiAgICAgICAgY29uc3QgY3RmID0gZ2V0Q1RGKHF1ZXJ5KTtcclxuICAgICAgICBpZiAoY3RmKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gY3RmLnRvUG9zdGdyZXMuY2FsbChxdWVyeSwgcXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0UXVlcnkocXVlcnksIHZhbHVlcywgZmFsc2UsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyogUHJlLXBhcnNlZCB0eXBlIGZvcm1hdHRpbmcgKi9cclxuY29uc3QgJHRvID0ge1xyXG4gICAgYXJyYXkoYXJyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdEFycmF5KGFyciwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgY3N2KHZhbHVlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRDU1YocmVzb2x2ZUZ1bmModmFsdWVzKSwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgYm9vbCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcbiAgICB9LFxyXG4gICAgYnVmZmVyKG9iaiwgcmF3KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGBcXFxceCR7b2JqLnRvU3RyaW5nKCdoZXgnKX1gO1xyXG4gICAgICAgIHJldHVybiByYXcgPyBzIDogd3JhcFRleHQocyk7XHJcbiAgICB9LFxyXG4gICAgZGF0ZShkLCByYXcpIHtcclxuICAgICAgICBjb25zdCBzID0gbnBtLnBnVXRpbHMucHJlcGFyZVZhbHVlKGQpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyBzIDogd3JhcFRleHQocyk7XHJcbiAgICB9LFxyXG4gICAganNvbihkYXRhLCByYXcpIHtcclxuICAgICAgICBjb25zdCBzID0gbnBtLnV0aWxzLnRvSnNvbihkYXRhKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gcyA6IHdyYXBUZXh0KHNhZmVUZXh0KHMpKTtcclxuICAgIH0sXHJcbiAgICBudW1iZXIobnVtKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0Zpbml0ZShudW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW0udG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVydGluZyBOYU4vK0luZmluaXR5Ly1JbmZpbml0eSBhY2NvcmRpbmcgdG8gUG9zdGdyZXMgZG9jdW1lbnRhdGlvbjpcclxuICAgICAgICAvLyBodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS42L3N0YXRpYy9kYXRhdHlwZS1udW1lcmljLmh0bWwjREFUQVRZUEUtRkxPQVRcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE5PVEU6IHN0cmluZ3MgZm9yICdOYU4nLycrSW5maW5pdHknLyctSW5maW5pdHknIGFyZSBub3QgY2FzZS1zZW5zaXRpdmUuXHJcbiAgICAgICAgaWYgKG51bSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwVGV4dCgnK0luZmluaXR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW0gPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcFRleHQoJy1JbmZpbml0eScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcFRleHQoJ05hTicpO1xyXG4gICAgfSxcclxuICAgIHRleHQodmFsdWUsIHJhdykge1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IHdyYXBUZXh0KHNhZmVUZXh0KHZhbHVlKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGZvcm1hdFF1ZXJ5LFxyXG4gICAgZm9ybWF0RW50aXR5LFxyXG4gICAgcmVzb2x2ZUZ1bmMsXHJcbiAgICBhczogJGFzXHJcbn07XHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIEVycm9yXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3JcclxuICovXHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIFR5cGVFcnJvclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgUmFuZ2VFcnJvclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JhbmdlRXJyb3JcclxuICovXHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIFN5bWJvbFxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbFxyXG4gKi9cclxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJucG0iLCJwZ1V0aWxzIiwicGF0dGVybnMiLCJ1dGlscyIsImZtRmxhZ3MiLCJyYXciLCJhbGlhcyIsIm5hbWUiLCJqc29uIiwiY3N2IiwidmFsdWUiLCJmbU1hcCIsImN0ZlN5bWJvbHMiLCJ0b1Bvc3RncmVzIiwiU3ltYm9sIiwiZm9yIiwicmF3VHlwZSIsIm1heFZhcmlhYmxlIiwiZm9ybWF0VmFsdWUiLCJmbSIsImNjIiwib3B0aW9ucyIsInJlc29sdmVGdW5jIiwiY3RmIiwiZ2V0Q1RGIiwiaXNSYXciLCIkYXMiLCIkdG8iLCJpc051bGwiLCJ0aHJvd0lmUmF3IiwidGV4dCIsImJvb2wiLCJudW1iZXIiLCJUeXBlRXJyb3IiLCJ0b1N0cmluZyIsIkRhdGUiLCJkYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXkiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImJ1ZmZlciIsImZvcm1hdEFycmF5IiwibG9vcCIsImEiLCJtYXAiLCJqb2luIiwicHJlZml4IiwiY2FwU1FMIiwibGVuZ3RoIiwiZm9ybWF0Q1NWIiwidmFsdWVzIiwiT2JqZWN0Iiwia2V5cyIsInYiLCJ1bmRlZmluZWQiLCJmb3JtYXRBcyIsIm9iamVjdCIsInF1ZXJ5Iiwib2JqIiwicmVwbGFjZSIsIm5hbWVkUGFyYW1ldGVycyIsInN0cmlwTmFtZSIsImMiLCJnZXRJZkhhcyIsInZhbGlkIiwiRXJyb3IiLCJoYXMiLCJ0YXJnZXQiLCJkIiwiZGVmIiwiY2FsbCIsInBhcnRpYWwiLCJtdWx0aXBsZVZhbHVlcyIsInN1YnN0ciIsImlkeCIsIlJhbmdlRXJyb3IiLCJzaW5nbGVWYWx1ZSIsIm1vZCIsIm1hdGNoIiwiaGFzVmFsaWRNb2RpZmllciIsImluZGV4IiwiY29uc3RydWN0b3IiLCJ3cmFwVGV4dCIsInNhZmVUZXh0IiwiZm9ybWF0UXVlcnkiLCJmb3JtYXRFbnRpdHkiLCJlbnRpdHkiLCJ0eXBlIiwidG9VcHBlckNhc2UiLCJmb3JtYXRTcWxOYW1lIiwidGVzdCIsInRvSnNvbiIsInNwbGl0IiwiZmlsdGVyIiwiZiIsIm0iLCJudW0iLCJ0IiwiYXJyIiwiZGF0YSIsImZ1bmMiLCJmb3JtYXQiLCJzIiwicHJlcGFyZVZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwibW9kdWxlIiwiZXhwb3J0cyIsImFzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/formatting.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js":
/*!***********************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/column-set.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { InnerState } = __webpack_require__(/*! ../inner-state */ \"(rsc)/./node_modules/pg-promise/lib/inner-state.js\");\nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst { TableName } = __webpack_require__(/*! ./table-name */ \"(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js\");\nconst { Column } = __webpack_require__(/*! ./column */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column.js\");\nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    formatting: __webpack_require__(/*! ../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\")\n};\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * In order to avail from performance optimization provided by this class, it should be created\r\n * only once, statically, and then reused.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet#assign assign},\r\n * {@link helpers.ColumnSet#assignColumns assignColumns},\r\n * {@link helpers.ColumnSet#extend extend},\r\n * {@link helpers.ColumnSet#merge merge},\r\n * {@link helpers.ColumnSet#prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init(col) {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip(col) {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // const table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */ class ColumnSet extends InnerState {\n    constructor(columns, opt){\n        super();\n        if (!columns || typeof columns !== \"object\") {\n            throw new TypeError(\"Invalid parameter 'columns' specified.\");\n        }\n        opt = assert(opt, [\n            \"table\",\n            \"inherit\"\n        ]);\n        if (!npm.utils.isNull(opt.table)) {\n            this.table = opt.table instanceof TableName ? opt.table : new TableName(opt.table);\n        }\n        /**\r\n         * @name helpers.ColumnSet#table\r\n         * @type {helpers.TableName}\r\n         * @readonly\r\n         * @description\r\n         * Destination table. It can be specified for two purposes:\r\n         *\r\n         * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n         * - **secondary:** to be automatically written into the console (for logging purposes).\r\n         */ /**\r\n         * @name helpers.ColumnSet#columns\r\n         * @type helpers.Column[]\r\n         * @readonly\r\n         * @description\r\n         * Array of {@link helpers.Column Column} objects.\r\n         */ if (Array.isArray(columns)) {\n            const colNames = {};\n            this.columns = columns.map((c)=>{\n                const col = c instanceof Column ? c : new Column(c);\n                if (col.name in colNames) {\n                    throw new Error(`Duplicate column name \"${col.name}\".`);\n                }\n                colNames[col.name] = true;\n                return col;\n            });\n        } else {\n            if (columns instanceof Column) {\n                this.columns = [\n                    columns\n                ];\n            } else {\n                this.columns = [];\n                for(const name in columns){\n                    if (opt.inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\n                        this.columns.push(new Column(name));\n                    }\n                }\n            }\n        }\n        Object.freeze(this.columns);\n        Object.freeze(this);\n        this.extendState({\n            names: undefined,\n            variables: undefined,\n            updates: undefined,\n            isSimple: true\n        });\n        for(let i = 0; i < this.columns.length; i++){\n            const c = this.columns[i];\n            // ColumnSet is simple when the source objects require no preparation,\n            // and should be used directly:\n            if (c.prop || c.init || \"def\" in c) {\n                this._inner.isSimple = false;\n                break;\n            }\n        }\n    }\n    /**\r\n     * @name helpers.ColumnSet#names\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - comma-separated list of all column names, properly escaped.\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.names);\r\n     * //=> \"id\",\"cells\",\"doc\"\r\n     */ get names() {\n        const _i = this._inner;\n        if (!_i.names) {\n            _i.names = this.columns.map((c)=>c.escapedName).join();\n        }\n        return _i.names;\n    }\n    /**\r\n     * @name helpers.ColumnSet#variables\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Returns a string - formatting template for all column values.\r\n     *\r\n     * @see {@link helpers.ColumnSet#assign assign}\r\n     *\r\n     * @example\r\n     * const cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.variables);\r\n     * //=> ${id^},${cells}::int[],${doc:json}\r\n     */ get variables() {\n        const _i = this._inner;\n        if (!_i.variables) {\n            _i.variables = this.columns.map((c)=>c.variable + c.castText).join();\n        }\n        return _i.variables;\n    }\n}\n/**\r\n * @method helpers.ColumnSet#assign\r\n * @description\r\n * Returns a formatting template of SET assignments, either generic or for a single object.\r\n *\r\n * The method is optimized to cache the output string when there are no columns that can be skipped dynamically.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input.\r\n *\r\n * @param {object} [options]\r\n * Assignment/formatting options.\r\n *\r\n * @param {object} [options.source]\r\n * Source - a single object that contains values for columns.\r\n *\r\n * The object is only necessary to correctly apply the logic of skipping columns dynamically, based on the source data\r\n * and the rules defined in the {@link helpers.ColumnSet ColumnSet}. If, however, you do not care about that, then you do not need to specify any object.\r\n *\r\n * Note that even if you do not specify the object, the columns marked as conditional (`cnd: true`) will always be skipped.\r\n *\r\n * @param {string} [options.prefix]\r\n * In cases where needed, an alias prefix to be added before each column.\r\n *\r\n * @returns {string}\r\n * Comma-separated list of variable-to-column assignments.\r\n *\r\n * @see {@link helpers.ColumnSet#variables variables}\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet([\r\n *     '?first', // = {name: 'first', cnd: true}\r\n *     'second:json',\r\n *     {name: 'third', mod: ':raw', cast: 'text'}\r\n * ]);\r\n *\r\n * cs.assign();\r\n * //=> \"second\"=${second:json},\"third\"=${third:raw}::text\r\n *\r\n * cs.assign({prefix: 'a b c'});\r\n * //=> \"a b c\".\"second\"=${second:json},\"a b c\".\"third\"=${third:raw}::text\r\n */ ColumnSet.prototype.assign = function(options) {\n    const _i = this._inner;\n    const hasPrefix = options && options.prefix && typeof options.prefix === \"string\";\n    if (_i.updates && !hasPrefix) {\n        return _i.updates;\n    }\n    let dynamic = hasPrefix;\n    const hasSource = options && options.source && typeof options.source === \"object\";\n    let list = this.columns.filter((c)=>{\n        if (c.cnd) {\n            return false;\n        }\n        if (c.skip) {\n            dynamic = true;\n            if (hasSource) {\n                const a = colDesc(c, options.source);\n                if (c.skip.call(options.source, a)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n    const prefix = hasPrefix ? npm.formatting.as.alias(options.prefix) + \".\" : \"\";\n    list = list.map((c)=>prefix + c.escapedName + \"=\" + c.variable + c.castText).join();\n    if (!dynamic) {\n        _i.updates = list;\n    }\n    return list;\n};\n/**\r\n * @method helpers.ColumnSet#assignColumns\r\n * @description\r\n * Generates assignments for all columns in the set, with support for aliases and column-skipping logic.\r\n * Aliases are set by using method {@link formatting.alias as.alias}.\r\n *\r\n * @param {{}} [options]\r\n * Optional Parameters.\r\n *\r\n * @param {string} [options.from]\r\n * Alias for the source columns.\r\n *\r\n * @param {string} [options.to]\r\n * Alias for the destination columns.\r\n *\r\n * @param {string | Array<string> | function} [options.skip]\r\n * Name(s) of the column(s) to be skipped (case-sensitive). It can be either a single string or an array of strings.\r\n *\r\n * It can also be a function - iterator, to be called for every column, passing in {@link helpers.Column Column} as\r\n * `this` context, and plus as a single parameter. The function would return a truthy value for every column that needs to be skipped.\r\n *\r\n * @returns {string}\r\n * A string of comma-separated column assignments.\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'EXCLUDED', skip: 'id'})\r\n * //=> \"city\"=EXCLUDED.\"city\",\"street\"=EXCLUDED.\"street\"\r\n *\r\n * @example\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'city', 'street']);\r\n *\r\n * cs.assignColumns({from: 'source', to: 'target', skip: c => c.cnd})\r\n * //=> target.\"city\"=source.\"city\",target.\"street\"=source.\"street\"\r\n *\r\n */ ColumnSet.prototype.assignColumns = function(options) {\n    options = assert(options, [\n        \"from\",\n        \"to\",\n        \"skip\"\n    ]);\n    const skip = typeof options.skip === \"string\" && [\n        options.skip\n    ] || (Array.isArray(options.skip) || typeof options.skip === \"function\") && options.skip;\n    const from = typeof options.from === \"string\" && options.from && npm.formatting.as.alias(options.from) + \".\" || \"\";\n    const to = typeof options.to === \"string\" && options.to && npm.formatting.as.alias(options.to) + \".\" || \"\";\n    const iterator = typeof skip === \"function\" ? (c)=>!skip.call(c, c) : (c)=>skip.indexOf(c.name) === -1;\n    const cols = skip ? this.columns.filter(iterator) : this.columns;\n    return cols.map((c)=>to + c.escapedName + \"=\" + from + c.escapedName).join();\n};\n/**\r\n * @method helpers.ColumnSet#extend\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#merge merge}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csExtended = cs.extend(['three']);\r\n * console.log(csExtended);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n */ ColumnSet.prototype.extend = function(columns) {\n    let cs = columns;\n    if (!(cs instanceof ColumnSet)) {\n        cs = new ColumnSet(columns);\n    }\n    // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\n    return new ColumnSet(this.columns.concat(cs.columns), {\n        table: this.table\n    });\n};\n/**\r\n * @method helpers.ColumnSet#merge\r\n * @description\r\n * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n *\r\n * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n *\r\n * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n * - it cannot be a simple object (properties enumeration is not supported here)\r\n *\r\n * @see\r\n * {@link helpers.Column Column},\r\n * {@link helpers.ColumnSet#extend extend}\r\n *\r\n * @returns {helpers.ColumnSet}\r\n * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n * console.log(cs);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n * const csMerged = cs.merge(['two', 'three^']);\r\n * console.log(csMerged);\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"my-table\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"one\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"two\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"three\"\r\n * //            mod: \"^\"\r\n * //        }\r\n * //    ]\r\n * // }\r\n *\r\n */ ColumnSet.prototype.merge = function(columns) {\n    let cs = columns;\n    if (!(cs instanceof ColumnSet)) {\n        cs = new ColumnSet(columns);\n    }\n    const colNames = {}, cols = [];\n    this.columns.forEach((c, idx)=>{\n        cols.push(c);\n        colNames[c.name] = idx;\n    });\n    cs.columns.forEach((c)=>{\n        if (c.name in colNames) {\n            cols[colNames[c.name]] = c;\n        } else {\n            cols.push(c);\n        }\n    });\n    return new ColumnSet(cols, {\n        table: this.table\n    });\n};\n/**\r\n * @method helpers.ColumnSet#prepare\r\n * @description\r\n * Prepares a source object to be formatted, by cloning it and applying the rules as set by the\r\n * columns configuration.\r\n *\r\n * This method is primarily for internal use, that's why it does not validate the input parameters.\r\n *\r\n * @param {object} source\r\n * The source object to be prepared, if required.\r\n *\r\n * It must be a non-`null` object, which the method does not validate, as it is\r\n * intended primarily for internal use by the library.\r\n *\r\n * @returns {object}\r\n * When the object needs to be prepared, the method returns a clone of the source object,\r\n * with all properties and values set according to the columns configuration.\r\n *\r\n * When the object does not need to be prepared, the original object is returned.\r\n */ ColumnSet.prototype.prepare = function(source) {\n    if (this._inner.isSimple) {\n        return source; // a simple ColumnSet requires no object preparation;\n    }\n    const target = {};\n    this.columns.forEach((c)=>{\n        const a = colDesc(c, source);\n        if (c.init) {\n            target[a.name] = c.init.call(source, a);\n        } else {\n            if (a.exists || \"def\" in c) {\n                target[a.name] = a.value;\n            }\n        }\n    });\n    return target;\n};\nfunction colDesc(column, source) {\n    const a = {\n        source,\n        name: column.prop || column.name\n    };\n    a.exists = a.name in source;\n    if (a.exists) {\n        a.value = source[a.name];\n    } else {\n        a.value = \"def\" in column ? column.def : undefined;\n    }\n    return a;\n}\n/**\r\n * @method helpers.ColumnSet#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ ColumnSet.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        \"ColumnSet {\"\n    ];\n    if (this.table) {\n        lines.push(gap1 + \"table: \" + this.table);\n    }\n    if (this.columns.length) {\n        lines.push(gap1 + \"columns: [\");\n        this.columns.forEach((c)=>{\n            lines.push(c.toString(2));\n        });\n        lines.push(gap1 + \"]\");\n    } else {\n        lines.push(gap1 + \"columns: []\");\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(ColumnSet, function() {\n    return this.toString();\n});\nmodule.exports = {\n    ColumnSet\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9jb2x1bW4tc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLFVBQVUsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUNDLE1BQU0sRUFBQyxHQUFHRCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUNFLFNBQVMsRUFBQyxHQUFHRixtQkFBT0EsQ0FBQztBQUM1QixNQUFNLEVBQUNHLE1BQU0sRUFBQyxHQUFHSCxtQkFBT0EsQ0FBQztBQUV6QixNQUFNSSxNQUFNO0lBQ1JDLElBQUlMLG1CQUFPQSxDQUFDO0lBQ1pNLE9BQU9OLG1CQUFPQSxDQUFDO0lBQ2ZPLFlBQVlQLG1CQUFPQSxDQUFDO0FBQ3hCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdKQyxHQUNELE1BQU1RLGtCQUFrQlQ7SUFFcEJVLFlBQVlDLE9BQU8sRUFBRUMsR0FBRyxDQUFFO1FBQ3RCLEtBQUs7UUFFTCxJQUFJLENBQUNELFdBQVcsT0FBT0EsWUFBWSxVQUFVO1lBQ3pDLE1BQU0sSUFBSUUsVUFBVTtRQUN4QjtRQUVBRCxNQUFNVixPQUFPVSxLQUFLO1lBQUM7WUFBUztTQUFVO1FBRXRDLElBQUksQ0FBQ1AsSUFBSUUsS0FBSyxDQUFDTyxNQUFNLENBQUNGLElBQUlHLEtBQUssR0FBRztZQUM5QixJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFLQSxLQUFLLFlBQVlaLFlBQWFTLElBQUlHLEtBQUssR0FBRyxJQUFJWixVQUFVUyxJQUFJRyxLQUFLO1FBQ3ZGO1FBRUE7Ozs7Ozs7OztTQVNDLEdBR0Q7Ozs7OztTQU1DLEdBQ0QsSUFB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QUksSUFBSSxDQUFDSixPQUFPLENBQUMyQixNQUFNLEVBQUU7UUFDckJnRCxNQUFNekQsSUFBSSxDQUFDd0QsT0FBTztRQUNsQixJQUFJLENBQUMxRSxPQUFPLENBQUM2RCxPQUFPLENBQUNwRCxDQUFBQTtZQUNqQmtFLE1BQU16RCxJQUFJLENBQUNULEVBQUU0RCxRQUFRLENBQUM7UUFDMUI7UUFDQU0sTUFBTXpELElBQUksQ0FBQ3dELE9BQU87SUFDdEIsT0FBTztRQUNIQyxNQUFNekQsSUFBSSxDQUFDd0QsT0FBTztJQUN0QjtJQUNBQyxNQUFNekQsSUFBSSxDQUFDc0QsT0FBTztJQUNsQixPQUFPRyxNQUFNMUMsSUFBSSxDQUFDdkMsSUFBSUMsRUFBRSxDQUFDaUYsR0FBRztBQUNoQztBQUVBbEYsSUFBSUUsS0FBSyxDQUFDaUYsYUFBYSxDQUFDL0UsV0FBVztJQUMvQixPQUFPLElBQUksQ0FBQ3VFLFFBQVE7QUFDeEI7QUFFQVMsT0FBT0MsT0FBTyxHQUFHO0lBQUNqRjtBQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9jb2x1bW4tc2V0LmpzPzhhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtJbm5lclN0YXRlfSA9IHJlcXVpcmUoJy4uL2lubmVyLXN0YXRlJyk7XHJcbmNvbnN0IHthc3NlcnR9ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XHJcbmNvbnN0IHtUYWJsZU5hbWV9ID0gcmVxdWlyZSgnLi90YWJsZS1uYW1lJyk7XHJcbmNvbnN0IHtDb2x1bW59ID0gcmVxdWlyZSgnLi9jb2x1bW4nKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIG9zOiByZXF1aXJlKCdvcycpLFxyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4uL3V0aWxzJyksXHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuLi9mb3JtYXR0aW5nJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgaGVscGVycy5Db2x1bW5TZXRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFBlcmZvcm1hbmNlLW9wdGltaXplZCwgcmVhZC1vbmx5IHN0cnVjdHVyZSB3aXRoIHF1ZXJ5LWZvcm1hdHRpbmcgY29sdW1ucy5cclxuICpcclxuICogSW4gb3JkZXIgdG8gYXZhaWwgZnJvbSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gcHJvdmlkZWQgYnkgdGhpcyBjbGFzcywgaXQgc2hvdWxkIGJlIGNyZWF0ZWRcclxuICogb25seSBvbmNlLCBzdGF0aWNhbGx5LCBhbmQgdGhlbiByZXVzZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fGhlbHBlcnMuQ29sdW1ufGFycmF5fSBjb2x1bW5zXHJcbiAqIENvbHVtbnMgaW5mb3JtYXRpb24gb2JqZWN0LCBkZXBlbmRpbmcgb24gdGhlIHR5cGU6XHJcbiAqXHJcbiAqIC0gV2hlbiBpdCBpcyBhIHNpbXBsZSBvYmplY3QsIGl0cyBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIHRvIHJlcHJlc2VudCBib3RoIGNvbHVtbiBuYW1lcyBhbmQgcHJvcGVydHkgbmFtZXNcclxuICogICB3aXRoaW4gdGhlIHNvdXJjZSBvYmplY3RzLiBTZWUgYWxzbyBvcHRpb24gYGluaGVyaXRgIHRoYXQncyBhcHBsaWNhYmxlIGluIHRoaXMgY2FzZS5cclxuICpcclxuICogLSBXaGVuIGl0IGlzIGEgc2luZ2xlIHtAbGluayBoZWxwZXJzLkNvbHVtbiBDb2x1bW59IG9iamVjdCwgcHJvcGVydHkge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0I2NvbHVtbnMgY29sdW1uc30gaXMgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gKiAgIGp1c3QgYSBzaW5nbGUgY29sdW1uLiBJdCBpcyBub3QgYSB1bmlxdWUgc2l0dWF0aW9uIHdoZW4gb25seSBhIHNpbmdsZSBjb2x1bW4gaXMgcmVxdWlyZWQgZm9yIGFuIHVwZGF0ZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIC0gV2hlbiBpdCBpcyBhbiBhcnJheSwgZWFjaCBlbGVtZW50IGlzIGFzc3VtZWQgdG8gcmVwcmVzZW50IGRldGFpbHMgZm9yIGEgY29sdW1uLiBJZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IG9mIHR5cGUge0BsaW5rIGhlbHBlcnMuQ29sdW1uIENvbHVtbn0sXHJcbiAqICAgaXQgaXMgdXNlZCBkaXJlY3RseTsgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGlzIHBhc3NlZCBpbnRvIHtAbGluayBoZWxwZXJzLkNvbHVtbiBDb2x1bW59IGNvbnN0cnVjdG9yIGZvciBpbml0aWFsaXphdGlvbi5cclxuICogICBPbiBhbnkgZHVwbGljYXRlIGNvbHVtbiBuYW1lIChjYXNlLXNlbnNpdGl2ZSkgaXQgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID0gYER1cGxpY2F0ZSBjb2x1bW4gbmFtZSBcIm5hbWVcIi5gXHJcbiAqXHJcbiAqIC0gV2hlbiBpdCBpcyBub25lIG9mIHRoZSBhYm92ZSwgaXQgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgSW52YWxpZCBwYXJhbWV0ZXIgJ2NvbHVtbnMnIHNwZWNpZmllZC5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICpcclxuICogQHBhcmFtIHtoZWxwZXJzLlRhYmxlTmFtZXxzdHJpbmd8e3RhYmxlLHNjaGVtYX19IFtvcHRpb25zLnRhYmxlXVxyXG4gKiBUYWJsZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBXaGVuIGl0IGlzIGEgbm9uLW51bGwgdmFsdWUsIGFuZCBub3QgYSB7QGxpbmsgaGVscGVycy5UYWJsZU5hbWUgVGFibGVOYW1lfSBvYmplY3QsIGEgbmV3IHtAbGluayBoZWxwZXJzLlRhYmxlTmFtZSBUYWJsZU5hbWV9IGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBJdCBjYW4gYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCBmb3IgbWV0aG9kcyB7QGxpbmsgaGVscGVycy5pbnNlcnQgaW5zZXJ0fSBhbmQge0BsaW5rIGhlbHBlcnMudXBkYXRlIHVwZGF0ZX0gd2hlbiB0aGVpciBwYXJhbWV0ZXJcclxuICogYHRhYmxlYCBpcyBvbWl0dGVkLCBhbmQgZm9yIGxvZ2dpbmcgcHVycG9zZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5oZXJpdCA9IGZhbHNlXVxyXG4gKiBVc2UgaW5oZXJpdGVkIHByb3BlcnRpZXMgaW4gYWRkaXRpb24gdG8gdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmb3IgY29sdW1uIG5hbWVzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7aGVscGVycy5Db2x1bW5TZXR9XHJcbiAqXHJcbiAqIEBzZWVcclxuICpcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0I2NvbHVtbnMgY29sdW1uc30sXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCNuYW1lcyBuYW1lc30sXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCN0YWJsZSB0YWJsZX0sXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCN2YXJpYWJsZXMgdmFyaWFibGVzfSB8XHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCNhc3NpZ24gYXNzaWdufSxcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0I2Fzc2lnbkNvbHVtbnMgYXNzaWduQ29sdW1uc30sXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCNleHRlbmQgZXh0ZW5kfSxcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0I21lcmdlIG1lcmdlfSxcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0I3ByZXBhcmUgcHJlcGFyZX1cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQSBjb21wbGV4IGluc2VydC91cGRhdGUgb2JqZWN0IHNjZW5hcmlvIGZvciB0YWJsZSAncHVyY2hhc2VzJyBpbiBzY2hlbWEgJ2Zpc2NhbCcuXHJcbiAqIC8vIEZvciBhIGdvb2QgcGVyZm9ybWFuY2UsIHlvdSBzaG91bGQgZGVjbGFyZSBzdWNoIG9iamVjdHMgb25jZSBhbmQgdGhlbiByZXVzZSB0aGVtLlxyXG4gKiAvL1xyXG4gKiAvLyBDb2x1bW4gUmVxdWlyZW1lbnRzOlxyXG4gKiAvL1xyXG4gKiAvLyAxLiBQcm9wZXJ0eSAnaWQnIGlzIG9ubHkgdG8gYmUgdXNlZCBmb3IgYSBXSEVSRSBjb25kaXRpb24gaW4gdXBkYXRlc1xyXG4gKiAvLyAyLiBQcm9wZXJ0eSAnbGlzdCcgbmVlZHMgdG8gYmUgZm9ybWF0dGVkIGFzIGEgY3N2XHJcbiAqIC8vIDMuIFByb3BlcnR5ICdjb2RlJyBpcyB0byBiZSB1c2VkIGFzIHJhdyB0ZXh0LCBhbmQgdG8gYmUgZGVmYXVsdGVkIHRvIDAgd2hlbiB0aGVcclxuICogLy8gICAgcHJvcGVydHkgaXMgbWlzc2luZyBpbiB0aGUgc291cmNlIG9iamVjdFxyXG4gKiAvLyA0LiBQcm9wZXJ0eSAnbG9nJyBpcyBhIEpTT04gb2JqZWN0IHdpdGggJ2xvZy1lbnRyeScgZm9yIHRoZSBjb2x1bW4gbmFtZVxyXG4gKiAvLyA1LiBQcm9wZXJ0eSAnZGF0YScgcmVxdWlyZXMgU1FMIHR5cGUgY2FzdGluZyAnOjppbnRbXSdcclxuICogLy8gNi4gUHJvcGVydHkgJ2Ftb3VudCcgbmVlZHMgdG8gYmUgc2V0IHRvIDEwMCwgaWYgaXQgaXMgMFxyXG4gKiAvLyA3LiBQcm9wZXJ0eSAndG90YWwnIG11c3QgYmUgc2tpcHBlZCBkdXJpbmcgdXBkYXRlcywgaWYgJ2Ftb3VudCcgd2FzIDAsIHBsdXMgaXRzXHJcbiAqIC8vICAgIGNvbHVtbiBuYW1lIGlzICd0b3RhbC12YWwnXHJcbiAqXHJcbiAqIGNvbnN0IGNzID0gbmV3IHBncC5oZWxwZXJzLkNvbHVtblNldChbXHJcbiAqICAgICAnP2lkJywgLy8gQ29sdW1uQ29uZmlnIGVxdWl2YWxlbnQ6IHtuYW1lOiAnaWQnLCBjbmQ6IHRydWV9XHJcbiAqICAgICAnbGlzdDpjc3YnLCAvLyBDb2x1bW5Db25maWcgZXF1aXZhbGVudDoge25hbWU6ICdsaXN0JywgbW9kOiAnOmNzdid9XHJcbiAqICAgICB7XHJcbiAqICAgICAgICAgbmFtZTogJ2NvZGUnLFxyXG4gKiAgICAgICAgIG1vZDogJ14nLCAvLyBmb3JtYXQgYXMgcmF3IHRleHRcclxuICogICAgICAgICBkZWY6IDAgLy8gZGVmYXVsdCB0byAwIHdoZW4gdGhlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3RcclxuICogICAgIH0sXHJcbiAqICAgICB7XHJcbiAqICAgICAgICAgbmFtZTogJ2xvZy1lbnRyeScsXHJcbiAqICAgICAgICAgcHJvcDogJ2xvZycsXHJcbiAqICAgICAgICAgbW9kOiAnOmpzb24nIC8vIGZvcm1hdCBhcyBKU09OXHJcbiAqICAgICB9LFxyXG4gKiAgICAge1xyXG4gKiAgICAgICAgIG5hbWU6ICdkYXRhJyxcclxuICogICAgICAgICBjYXN0OiAnaW50W10nIC8vIHVzZSBTUUwgdHlwZSBjYXN0aW5nICc6OmludFtdJ1xyXG4gKiAgICAgfSxcclxuICogICAgIHtcclxuICogICAgICAgICBuYW1lOiAnYW1vdW50JyxcclxuICogICAgICAgICBpbml0KGNvbCkge1xyXG4gKiAgICAgICAgICAgICAvLyBzZXQgdG8gMTAwLCBpZiB0aGUgdmFsdWUgaXMgMDpcclxuICogICAgICAgICAgICAgcmV0dXJuIGNvbC52YWx1ZSA9PT0gMCA/IDEwMCA6IGNvbC52YWx1ZTtcclxuICogICAgICAgICB9XHJcbiAqICAgICB9LFxyXG4gKiAgICAge1xyXG4gKiAgICAgICAgIG5hbWU6ICd0b3RhbC12YWwnLFxyXG4gKiAgICAgICAgIHByb3A6ICd0b3RhbCcsXHJcbiAqICAgICAgICAgc2tpcChjb2wpIHtcclxuICogICAgICAgICAgICAgLy8gc2tpcCBmcm9tIHVwZGF0ZXMsIGlmICdhbW91bnQnIGlzIDA6XHJcbiAqICAgICAgICAgICAgIHJldHVybiBjb2wuc291cmNlLmFtb3VudCA9PT0gMDtcclxuICogICAgICAgICB9XHJcbiAqICAgICB9XHJcbiAqIF0sIHt0YWJsZToge3RhYmxlOiAncHVyY2hhc2VzJywgc2NoZW1hOiAnZmlzY2FsJ319KTtcclxuICpcclxuICogLy8gQWx0ZXJuYXRpdmVseSwgeW91IGNvdWxkIHRha2UgdGhlIHRhYmxlIGRlY2xhcmF0aW9uIG91dDpcclxuICogLy8gY29uc3QgdGFibGUgPSBuZXcgcGdwLmhlbHBlcnMuVGFibGVOYW1lKCdwdXJjaGFzZXMnLCAnZmlzY2FsJyk7XHJcbiAqXHJcbiAqIGNvbnNvbGUubG9nKGNzKTsgLy8gY29uc29sZSBvdXRwdXQgZm9yIHRoZSBvYmplY3Q6XHJcbiAqIC8vPT5cclxuICogLy8gQ29sdW1uU2V0IHtcclxuICogLy8gICAgdGFibGU6IFwiZmlzY2FsXCIuXCJwdXJjaGFzZXNcIlxyXG4gKiAvLyAgICBjb2x1bW5zOiBbXHJcbiAqIC8vICAgICAgICBDb2x1bW4ge1xyXG4gKiAvLyAgICAgICAgICAgIG5hbWU6IFwiaWRcIlxyXG4gKiAvLyAgICAgICAgICAgIGNuZDogdHJ1ZVxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICAgICAgQ29sdW1uIHtcclxuICogLy8gICAgICAgICAgICBuYW1lOiBcImxpc3RcIlxyXG4gKiAvLyAgICAgICAgICAgIG1vZDogXCI6Y3N2XCJcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJjb2RlXCJcclxuICogLy8gICAgICAgICAgICBtb2Q6IFwiXlwiXHJcbiAqIC8vICAgICAgICAgICAgZGVmOiAwXHJcbiAqIC8vICAgICAgICB9XHJcbiAqIC8vICAgICAgICBDb2x1bW4ge1xyXG4gKiAvLyAgICAgICAgICAgIG5hbWU6IFwibG9nLWVudHJ5XCJcclxuICogLy8gICAgICAgICAgICBwcm9wOiBcImxvZ1wiXHJcbiAqIC8vICAgICAgICAgICAgbW9kOiBcIjpqc29uXCJcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJkYXRhXCJcclxuICogLy8gICAgICAgICAgICBjYXN0OiBcImludFtdXCJcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJhbW91bnRcIlxyXG4gKiAvLyAgICAgICAgICAgIGluaXQ6IFtGdW5jdGlvbl1cclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJ0b3RhbC12YWxcIlxyXG4gKiAvLyAgICAgICAgICAgIHByb3A6IFwidG90YWxcIlxyXG4gKiAvLyAgICAgICAgICAgIHNraXA6IFtGdW5jdGlvbl1cclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgXVxyXG4gKiAvLyB9XHJcbiAqL1xyXG5jbGFzcyBDb2x1bW5TZXQgZXh0ZW5kcyBJbm5lclN0YXRlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb2x1bW5zLCBvcHQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBpZiAoIWNvbHVtbnMgfHwgdHlwZW9mIGNvbHVtbnMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIFxcJ2NvbHVtbnNcXCcgc3BlY2lmaWVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0ID0gYXNzZXJ0KG9wdCwgWyd0YWJsZScsICdpbmhlcml0J10pO1xyXG5cclxuICAgICAgICBpZiAoIW5wbS51dGlscy5pc051bGwob3B0LnRhYmxlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gKG9wdC50YWJsZSBpbnN0YW5jZW9mIFRhYmxlTmFtZSkgPyBvcHQudGFibGUgOiBuZXcgVGFibGVOYW1lKG9wdC50YWJsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmFtZSBoZWxwZXJzLkNvbHVtblNldCN0YWJsZVxyXG4gICAgICAgICAqIEB0eXBlIHtoZWxwZXJzLlRhYmxlTmFtZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBEZXN0aW5hdGlvbiB0YWJsZS4gSXQgY2FuIGJlIHNwZWNpZmllZCBmb3IgdHdvIHB1cnBvc2VzOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSAqKnByaW1hcnk6KiogdG8gYmUgdXNlZCBhcyB0aGUgZGVmYXVsdCB0YWJsZSB3aGVuIGl0IGlzIG9taXR0ZWQgZHVyaW5nIGEgY2FsbCBpbnRvIG1ldGhvZHMge0BsaW5rIGhlbHBlcnMuaW5zZXJ0IGluc2VydH0gYW5kIHtAbGluayBoZWxwZXJzLnVwZGF0ZSB1cGRhdGV9XHJcbiAgICAgICAgICogLSAqKnNlY29uZGFyeToqKiB0byBiZSBhdXRvbWF0aWNhbGx5IHdyaXR0ZW4gaW50byB0aGUgY29uc29sZSAoZm9yIGxvZ2dpbmcgcHVycG9zZXMpLlxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5hbWUgaGVscGVycy5Db2x1bW5TZXQjY29sdW1uc1xyXG4gICAgICAgICAqIEB0eXBlIGhlbHBlcnMuQ29sdW1uW11cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBBcnJheSBvZiB7QGxpbmsgaGVscGVycy5Db2x1bW4gQ29sdW1ufSBvYmplY3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbE5hbWVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnMubWFwKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gKGMgaW5zdGFuY2VvZiBDb2x1bW4pID8gYyA6IG5ldyBDb2x1bW4oYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sLm5hbWUgaW4gY29sTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBjb2x1bW4gbmFtZSBcIiR7Y29sLm5hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2xOYW1lc1tjb2wubmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNvbHVtbnMgaW5zdGFuY2VvZiBDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IFtjb2x1bW5zXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0LmluaGVyaXQgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbHVtbnMsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKG5ldyBDb2x1bW4obmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLmNvbHVtbnMpO1xyXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZXh0ZW5kU3RhdGUoe1xyXG4gICAgICAgICAgICBuYW1lczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdXBkYXRlczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBpc1NpbXBsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5jb2x1bW5zW2ldO1xyXG4gICAgICAgICAgICAvLyBDb2x1bW5TZXQgaXMgc2ltcGxlIHdoZW4gdGhlIHNvdXJjZSBvYmplY3RzIHJlcXVpcmUgbm8gcHJlcGFyYXRpb24sXHJcbiAgICAgICAgICAgIC8vIGFuZCBzaG91bGQgYmUgdXNlZCBkaXJlY3RseTpcclxuICAgICAgICAgICAgaWYgKGMucHJvcCB8fCBjLmluaXQgfHwgJ2RlZicgaW4gYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXIuaXNTaW1wbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgaGVscGVycy5Db2x1bW5TZXQjbmFtZXNcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgLSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhbGwgY29sdW1uIG5hbWVzLCBwcm9wZXJseSBlc2NhcGVkLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjb25zdCBjcyA9IG5ldyBDb2x1bW5TZXQoWydpZF4nLCB7bmFtZTogJ2NlbGxzJywgY2FzdDogJ2ludFtdJ30sICdkb2M6anNvbiddKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGNzLm5hbWVzKTtcclxuICAgICAqIC8vPT4gXCJpZFwiLFwiY2VsbHNcIixcImRvY1wiXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lcygpIHtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyO1xyXG4gICAgICAgIGlmICghX2kubmFtZXMpIHtcclxuICAgICAgICAgICAgX2kubmFtZXMgPSB0aGlzLmNvbHVtbnMubWFwKGMgPT4gYy5lc2NhcGVkTmFtZSkuam9pbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2kubmFtZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBoZWxwZXJzLkNvbHVtblNldCN2YXJpYWJsZXNcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgLSBmb3JtYXR0aW5nIHRlbXBsYXRlIGZvciBhbGwgY29sdW1uIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCNhc3NpZ24gYXNzaWdufVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjb25zdCBjcyA9IG5ldyBDb2x1bW5TZXQoWydpZF4nLCB7bmFtZTogJ2NlbGxzJywgY2FzdDogJ2ludFtdJ30sICdkb2M6anNvbiddKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGNzLnZhcmlhYmxlcyk7XHJcbiAgICAgKiAvLz0+ICR7aWRefSwke2NlbGxzfTo6aW50W10sJHtkb2M6anNvbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHZhcmlhYmxlcygpIHtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyO1xyXG4gICAgICAgIGlmICghX2kudmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgIF9pLnZhcmlhYmxlcyA9IHRoaXMuY29sdW1ucy5tYXAoYyA9PiBjLnZhcmlhYmxlICsgYy5jYXN0VGV4dCkuam9pbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2kudmFyaWFibGVzO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGVscGVycy5Db2x1bW5TZXQjYXNzaWduXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBSZXR1cm5zIGEgZm9ybWF0dGluZyB0ZW1wbGF0ZSBvZiBTRVQgYXNzaWdubWVudHMsIGVpdGhlciBnZW5lcmljIG9yIGZvciBhIHNpbmdsZSBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBtZXRob2QgaXMgb3B0aW1pemVkIHRvIGNhY2hlIHRoZSBvdXRwdXQgc3RyaW5nIHdoZW4gdGhlcmUgYXJlIG5vIGNvbHVtbnMgdGhhdCBjYW4gYmUgc2tpcHBlZCBkeW5hbWljYWxseS5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UsIHRoYXQncyB3aHkgaXQgZG9lcyBub3QgdmFsaWRhdGUgdGhlIGlucHV0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIEFzc2lnbm1lbnQvZm9ybWF0dGluZyBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc291cmNlXVxyXG4gKiBTb3VyY2UgLSBhIHNpbmdsZSBvYmplY3QgdGhhdCBjb250YWlucyB2YWx1ZXMgZm9yIGNvbHVtbnMuXHJcbiAqXHJcbiAqIFRoZSBvYmplY3QgaXMgb25seSBuZWNlc3NhcnkgdG8gY29ycmVjdGx5IGFwcGx5IHRoZSBsb2dpYyBvZiBza2lwcGluZyBjb2x1bW5zIGR5bmFtaWNhbGx5LCBiYXNlZCBvbiB0aGUgc291cmNlIGRhdGFcclxuICogYW5kIHRoZSBydWxlcyBkZWZpbmVkIGluIHRoZSB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fS4gSWYsIGhvd2V2ZXIsIHlvdSBkbyBub3QgY2FyZSBhYm91dCB0aGF0LCB0aGVuIHlvdSBkbyBub3QgbmVlZCB0byBzcGVjaWZ5IGFueSBvYmplY3QuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBldmVuIGlmIHlvdSBkbyBub3Qgc3BlY2lmeSB0aGUgb2JqZWN0LCB0aGUgY29sdW1ucyBtYXJrZWQgYXMgY29uZGl0aW9uYWwgKGBjbmQ6IHRydWVgKSB3aWxsIGFsd2F5cyBiZSBza2lwcGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJlZml4XVxyXG4gKiBJbiBjYXNlcyB3aGVyZSBuZWVkZWQsIGFuIGFsaWFzIHByZWZpeCB0byBiZSBhZGRlZCBiZWZvcmUgZWFjaCBjb2x1bW4uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZhcmlhYmxlLXRvLWNvbHVtbiBhc3NpZ25tZW50cy5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQjdmFyaWFibGVzIHZhcmlhYmxlc31cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgY3MgPSBuZXcgcGdwLmhlbHBlcnMuQ29sdW1uU2V0KFtcclxuICogICAgICc/Zmlyc3QnLCAvLyA9IHtuYW1lOiAnZmlyc3QnLCBjbmQ6IHRydWV9XHJcbiAqICAgICAnc2Vjb25kOmpzb24nLFxyXG4gKiAgICAge25hbWU6ICd0aGlyZCcsIG1vZDogJzpyYXcnLCBjYXN0OiAndGV4dCd9XHJcbiAqIF0pO1xyXG4gKlxyXG4gKiBjcy5hc3NpZ24oKTtcclxuICogLy89PiBcInNlY29uZFwiPSR7c2Vjb25kOmpzb259LFwidGhpcmRcIj0ke3RoaXJkOnJhd306OnRleHRcclxuICpcclxuICogY3MuYXNzaWduKHtwcmVmaXg6ICdhIGIgYyd9KTtcclxuICogLy89PiBcImEgYiBjXCIuXCJzZWNvbmRcIj0ke3NlY29uZDpqc29ufSxcImEgYiBjXCIuXCJ0aGlyZFwiPSR7dGhpcmQ6cmF3fTo6dGV4dFxyXG4gKi9cclxuQ29sdW1uU2V0LnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgY29uc3QgX2kgPSB0aGlzLl9pbm5lcjtcclxuICAgIGNvbnN0IGhhc1ByZWZpeCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmaXggJiYgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnc3RyaW5nJztcclxuICAgIGlmIChfaS51cGRhdGVzICYmICFoYXNQcmVmaXgpIHtcclxuICAgICAgICByZXR1cm4gX2kudXBkYXRlcztcclxuICAgIH1cclxuICAgIGxldCBkeW5hbWljID0gaGFzUHJlZml4O1xyXG4gICAgY29uc3QgaGFzU291cmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZSAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2UgPT09ICdvYmplY3QnO1xyXG4gICAgbGV0IGxpc3QgPSB0aGlzLmNvbHVtbnMuZmlsdGVyKGMgPT4ge1xyXG4gICAgICAgIGlmIChjLmNuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjLnNraXApIHtcclxuICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChoYXNTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjb2xEZXNjKGMsIG9wdGlvbnMuc291cmNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjLnNraXAuY2FsbChvcHRpb25zLnNvdXJjZSwgYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmVmaXggPyBucG0uZm9ybWF0dGluZy5hcy5hbGlhcyhvcHRpb25zLnByZWZpeCkgKyAnLicgOiAnJztcclxuICAgIGxpc3QgPSBsaXN0Lm1hcChjID0+IHByZWZpeCArIGMuZXNjYXBlZE5hbWUgKyAnPScgKyBjLnZhcmlhYmxlICsgYy5jYXN0VGV4dCkuam9pbigpO1xyXG5cclxuICAgIGlmICghZHluYW1pYykge1xyXG4gICAgICAgIF9pLnVwZGF0ZXMgPSBsaXN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBoZWxwZXJzLkNvbHVtblNldCNhc3NpZ25Db2x1bW5zXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBHZW5lcmF0ZXMgYXNzaWdubWVudHMgZm9yIGFsbCBjb2x1bW5zIGluIHRoZSBzZXQsIHdpdGggc3VwcG9ydCBmb3IgYWxpYXNlcyBhbmQgY29sdW1uLXNraXBwaW5nIGxvZ2ljLlxyXG4gKiBBbGlhc2VzIGFyZSBzZXQgYnkgdXNpbmcgbWV0aG9kIHtAbGluayBmb3JtYXR0aW5nLmFsaWFzIGFzLmFsaWFzfS5cclxuICpcclxuICogQHBhcmFtIHt7fX0gW29wdGlvbnNdXHJcbiAqIE9wdGlvbmFsIFBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcm9tXVxyXG4gKiBBbGlhcyBmb3IgdGhlIHNvdXJjZSBjb2x1bW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9dXHJcbiAqIEFsaWFzIGZvciB0aGUgZGVzdGluYXRpb24gY29sdW1ucy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgZnVuY3Rpb259IFtvcHRpb25zLnNraXBdXHJcbiAqIE5hbWUocykgb2YgdGhlIGNvbHVtbihzKSB0byBiZSBza2lwcGVkIChjYXNlLXNlbnNpdGl2ZSkuIEl0IGNhbiBiZSBlaXRoZXIgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqXHJcbiAqIEl0IGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24gLSBpdGVyYXRvciwgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBjb2x1bW4sIHBhc3NpbmcgaW4ge0BsaW5rIGhlbHBlcnMuQ29sdW1uIENvbHVtbn0gYXNcclxuICogYHRoaXNgIGNvbnRleHQsIGFuZCBwbHVzIGFzIGEgc2luZ2xlIHBhcmFtZXRlci4gVGhlIGZ1bmN0aW9uIHdvdWxkIHJldHVybiBhIHRydXRoeSB2YWx1ZSBmb3IgZXZlcnkgY29sdW1uIHRoYXQgbmVlZHMgdG8gYmUgc2tpcHBlZC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQSBzdHJpbmcgb2YgY29tbWEtc2VwYXJhdGVkIGNvbHVtbiBhc3NpZ25tZW50cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgY3MgPSBuZXcgcGdwLmhlbHBlcnMuQ29sdW1uU2V0KFsnaWQnLCAnY2l0eScsICdzdHJlZXQnXSk7XHJcbiAqXHJcbiAqIGNzLmFzc2lnbkNvbHVtbnMoe2Zyb206ICdFWENMVURFRCcsIHNraXA6ICdpZCd9KVxyXG4gKiAvLz0+IFwiY2l0eVwiPUVYQ0xVREVELlwiY2l0eVwiLFwic3RyZWV0XCI9RVhDTFVERUQuXCJzdHJlZXRcIlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBjb25zdCBjcyA9IG5ldyBwZ3AuaGVscGVycy5Db2x1bW5TZXQoWyc/aWQnLCAnY2l0eScsICdzdHJlZXQnXSk7XHJcbiAqXHJcbiAqIGNzLmFzc2lnbkNvbHVtbnMoe2Zyb206ICdzb3VyY2UnLCB0bzogJ3RhcmdldCcsIHNraXA6IGMgPT4gYy5jbmR9KVxyXG4gKiAvLz0+IHRhcmdldC5cImNpdHlcIj1zb3VyY2UuXCJjaXR5XCIsdGFyZ2V0Llwic3RyZWV0XCI9c291cmNlLlwic3RyZWV0XCJcclxuICpcclxuICovXHJcbkNvbHVtblNldC5wcm90b3R5cGUuYXNzaWduQ29sdW1ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gYXNzZXJ0KG9wdGlvbnMsIFsnZnJvbScsICd0bycsICdza2lwJ10pO1xyXG4gICAgY29uc3Qgc2tpcCA9ICh0eXBlb2Ygb3B0aW9ucy5za2lwID09PSAnc3RyaW5nJyAmJiBbb3B0aW9ucy5za2lwXSkgfHwgKChBcnJheS5pc0FycmF5KG9wdGlvbnMuc2tpcCkgfHwgdHlwZW9mIG9wdGlvbnMuc2tpcCA9PT0gJ2Z1bmN0aW9uJykgJiYgb3B0aW9ucy5za2lwKTtcclxuICAgIGNvbnN0IGZyb20gPSAodHlwZW9mIG9wdGlvbnMuZnJvbSA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5mcm9tICYmIChucG0uZm9ybWF0dGluZy5hcy5hbGlhcyhvcHRpb25zLmZyb20pICsgJy4nKSkgfHwgJyc7XHJcbiAgICBjb25zdCB0byA9ICh0eXBlb2Ygb3B0aW9ucy50byA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy50byAmJiAobnBtLmZvcm1hdHRpbmcuYXMuYWxpYXMob3B0aW9ucy50bykgKyAnLicpKSB8fCAnJztcclxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdHlwZW9mIHNraXAgPT09ICdmdW5jdGlvbicgPyBjID0+ICFza2lwLmNhbGwoYywgYykgOiBjID0+IHNraXAuaW5kZXhPZihjLm5hbWUpID09PSAtMTtcclxuICAgIGNvbnN0IGNvbHMgPSBza2lwID8gdGhpcy5jb2x1bW5zLmZpbHRlcihpdGVyYXRvcikgOiB0aGlzLmNvbHVtbnM7XHJcbiAgICByZXR1cm4gY29scy5tYXAoYyA9PiB0byArIGMuZXNjYXBlZE5hbWUgKyAnPScgKyBmcm9tICsgYy5lc2NhcGVkTmFtZSkuam9pbigpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGVscGVycy5Db2x1bW5TZXQjZXh0ZW5kXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9LCBieSBqb2luaW5nIHRoZSB0d28gc2V0cyBvZiBjb2x1bW5zLlxyXG4gKlxyXG4gKiBJZiB0aGUgdHdvIHNldHMgY29udGFpbiBhIGNvbHVtbiB3aXRoIHRoZSBzYW1lIGBuYW1lYCAoY2FzZS1zZW5zaXRpdmUpLCBhbiBlcnJvciBpcyB0aHJvd24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7aGVscGVycy5Db2x1bW58aGVscGVycy5Db2x1bW5TZXR8YXJyYXl9IGNvbHVtbnNcclxuICogQ29sdW1ucyB0byBiZSBhcHBlbmRlZCwgb2YgdGhlIHNhbWUgdHlwZSBhcyBwYXJhbWV0ZXIgYGNvbHVtbnNgIGR1cmluZyB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBjb25zdHJ1Y3Rpb24sIGV4Y2VwdDpcclxuICogLSBpdCBjYW4gYWxzbyBiZSBvZiB0eXBlIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9XHJcbiAqIC0gaXQgY2Fubm90IGJlIGEgc2ltcGxlIG9iamVjdCAocHJvcGVydGllcyBlbnVtZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGhlcmUpXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtoZWxwZXJzLkNvbHVtblNldH1cclxuICogTmV3IHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9IG9iamVjdCB3aXRoIHRoZSBleHRlbmRlZC9jb25jYXRlbmF0ZWQgbGlzdCBvZiBjb2x1bW5zLlxyXG4gKlxyXG4gKiBAc2VlXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtbiBDb2x1bW59LFxyXG4gKiB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQjbWVyZ2UgbWVyZ2V9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKSgpO1xyXG4gKlxyXG4gKiBjb25zdCBjcyA9IG5ldyBwZ3AuaGVscGVycy5Db2x1bW5TZXQoWydvbmUnLCAndHdvJ10sIHt0YWJsZTogJ215LXRhYmxlJ30pO1xyXG4gKiBjb25zb2xlLmxvZyhjcyk7XHJcbiAqIC8vPT5cclxuICogLy8gQ29sdW1uU2V0IHtcclxuICogLy8gICAgdGFibGU6IFwibXktdGFibGVcIlxyXG4gKiAvLyAgICBjb2x1bW5zOiBbXHJcbiAqIC8vICAgICAgICBDb2x1bW4ge1xyXG4gKiAvLyAgICAgICAgICAgIG5hbWU6IFwib25lXCJcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJ0d29cIlxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICBdXHJcbiAqIC8vIH1cclxuICogY29uc3QgY3NFeHRlbmRlZCA9IGNzLmV4dGVuZChbJ3RocmVlJ10pO1xyXG4gKiBjb25zb2xlLmxvZyhjc0V4dGVuZGVkKTtcclxuICogLy89PlxyXG4gKiAvLyBDb2x1bW5TZXQge1xyXG4gKiAvLyAgICB0YWJsZTogXCJteS10YWJsZVwiXHJcbiAqIC8vICAgIGNvbHVtbnM6IFtcclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJvbmVcIlxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICAgICAgQ29sdW1uIHtcclxuICogLy8gICAgICAgICAgICBuYW1lOiBcInR3b1wiXHJcbiAqIC8vICAgICAgICB9XHJcbiAqIC8vICAgICAgICBDb2x1bW4ge1xyXG4gKiAvLyAgICAgICAgICAgIG5hbWU6IFwidGhyZWVcIlxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICBdXHJcbiAqIC8vIH1cclxuICovXHJcbkNvbHVtblNldC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcclxuICAgIGxldCBjcyA9IGNvbHVtbnM7XHJcbiAgICBpZiAoIShjcyBpbnN0YW5jZW9mIENvbHVtblNldCkpIHtcclxuICAgICAgICBjcyA9IG5ldyBDb2x1bW5TZXQoY29sdW1ucyk7XHJcbiAgICB9XHJcbiAgICAvLyBBbnkgZHVwbGljYXRlIGNvbHVtbiB3aWxsIHRocm93IEVycm9yID0gJ0R1cGxpY2F0ZSBjb2x1bW4gbmFtZSBcIm5hbWVcIi4nLFxyXG4gICAgcmV0dXJuIG5ldyBDb2x1bW5TZXQodGhpcy5jb2x1bW5zLmNvbmNhdChjcy5jb2x1bW5zKSwge3RhYmxlOiB0aGlzLnRhYmxlfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBoZWxwZXJzLkNvbHVtblNldCNtZXJnZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSwgYnkgam9pbmluZyB0aGUgdHdvIHNldHMgb2YgY29sdW1ucy5cclxuICpcclxuICogSXRlbXMgaW4gYGNvbHVtbnNgIHdpdGggdGhlIHNhbWUgYG5hbWVgIChjYXNlLXNlbnNpdGl2ZSkgb3ZlcnJpZGUgdGhlIG9yaWdpbmFsIGNvbHVtbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7aGVscGVycy5Db2x1bW58aGVscGVycy5Db2x1bW5TZXR8YXJyYXl9IGNvbHVtbnNcclxuICogQ29sdW1ucyB0byBiZSBhcHBlbmRlZCwgb2YgdGhlIHNhbWUgdHlwZSBhcyBwYXJhbWV0ZXIgYGNvbHVtbnNgIGR1cmluZyB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBjb25zdHJ1Y3Rpb24sIGV4Y2VwdDpcclxuICogLSBpdCBjYW4gYWxzbyBiZSBvZiB0eXBlIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9XHJcbiAqIC0gaXQgY2Fubm90IGJlIGEgc2ltcGxlIG9iamVjdCAocHJvcGVydGllcyBlbnVtZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGhlcmUpXHJcbiAqXHJcbiAqIEBzZWVcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uIENvbHVtbn0sXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCNleHRlbmQgZXh0ZW5kfVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7aGVscGVycy5Db2x1bW5TZXR9XHJcbiAqIE5ldyB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBvYmplY3Qgd2l0aCB0aGUgbWVyZ2VkIGxpc3Qgb2YgY29sdW1ucy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgcGdwID0gcmVxdWlyZSgncGctcHJvbWlzZScpKCk7XHJcbiAqXHJcbiAqIGNvbnN0IGNzID0gbmV3IHBncC5oZWxwZXJzLkNvbHVtblNldChbJz9vbmUnLCAndHdvOmpzb24nXSwge3RhYmxlOiAnbXktdGFibGUnfSk7XHJcbiAqIGNvbnNvbGUubG9nKGNzKTtcclxuICogLy89PlxyXG4gKiAvLyBDb2x1bW5TZXQge1xyXG4gKiAvLyAgICB0YWJsZTogXCJteS10YWJsZVwiXHJcbiAqIC8vICAgIGNvbHVtbnM6IFtcclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJvbmVcIlxyXG4gKiAvLyAgICAgICAgICAgIGNuZDogdHJ1ZVxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICAgICAgQ29sdW1uIHtcclxuICogLy8gICAgICAgICAgICBuYW1lOiBcInR3b1wiXHJcbiAqIC8vICAgICAgICAgICAgbW9kOiBcIjpqc29uXCJcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgXVxyXG4gKiAvLyB9XHJcbiAqIGNvbnN0IGNzTWVyZ2VkID0gY3MubWVyZ2UoWyd0d28nLCAndGhyZWVeJ10pO1xyXG4gKiBjb25zb2xlLmxvZyhjc01lcmdlZCk7XHJcbiAqIC8vPT5cclxuICogLy8gQ29sdW1uU2V0IHtcclxuICogLy8gICAgdGFibGU6IFwibXktdGFibGVcIlxyXG4gKiAvLyAgICBjb2x1bW5zOiBbXHJcbiAqIC8vICAgICAgICBDb2x1bW4ge1xyXG4gKiAvLyAgICAgICAgICAgIG5hbWU6IFwib25lXCJcclxuICogLy8gICAgICAgICAgICBjbmQ6IHRydWVcclxuICogLy8gICAgICAgIH1cclxuICogLy8gICAgICAgIENvbHVtbiB7XHJcbiAqIC8vICAgICAgICAgICAgbmFtZTogXCJ0d29cIlxyXG4gKiAvLyAgICAgICAgfVxyXG4gKiAvLyAgICAgICAgQ29sdW1uIHtcclxuICogLy8gICAgICAgICAgICBuYW1lOiBcInRocmVlXCJcclxuICogLy8gICAgICAgICAgICBtb2Q6IFwiXlwiXHJcbiAqIC8vICAgICAgICB9XHJcbiAqIC8vICAgIF1cclxuICogLy8gfVxyXG4gKlxyXG4gKi9cclxuQ29sdW1uU2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChjb2x1bW5zKSB7XHJcbiAgICBsZXQgY3MgPSBjb2x1bW5zO1xyXG4gICAgaWYgKCEoY3MgaW5zdGFuY2VvZiBDb2x1bW5TZXQpKSB7XHJcbiAgICAgICAgY3MgPSBuZXcgQ29sdW1uU2V0KGNvbHVtbnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29sTmFtZXMgPSB7fSwgY29scyA9IFtdO1xyXG4gICAgdGhpcy5jb2x1bW5zLmZvckVhY2goKGMsIGlkeCkgPT4ge1xyXG4gICAgICAgIGNvbHMucHVzaChjKTtcclxuICAgICAgICBjb2xOYW1lc1tjLm5hbWVdID0gaWR4O1xyXG4gICAgfSk7XHJcbiAgICBjcy5jb2x1bW5zLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgaWYgKGMubmFtZSBpbiBjb2xOYW1lcykge1xyXG4gICAgICAgICAgICBjb2xzW2NvbE5hbWVzW2MubmFtZV1dID0gYztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xzLnB1c2goYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IENvbHVtblNldChjb2xzLCB7dGFibGU6IHRoaXMudGFibGV9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhlbHBlcnMuQ29sdW1uU2V0I3ByZXBhcmVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFByZXBhcmVzIGEgc291cmNlIG9iamVjdCB0byBiZSBmb3JtYXR0ZWQsIGJ5IGNsb25pbmcgaXQgYW5kIGFwcGx5aW5nIHRoZSBydWxlcyBhcyBzZXQgYnkgdGhlXHJcbiAqIGNvbHVtbnMgY29uZmlndXJhdGlvbi5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UsIHRoYXQncyB3aHkgaXQgZG9lcyBub3QgdmFsaWRhdGUgdGhlIGlucHV0IHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcclxuICogVGhlIHNvdXJjZSBvYmplY3QgdG8gYmUgcHJlcGFyZWQsIGlmIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBJdCBtdXN0IGJlIGEgbm9uLWBudWxsYCBvYmplY3QsIHdoaWNoIHRoZSBtZXRob2QgZG9lcyBub3QgdmFsaWRhdGUsIGFzIGl0IGlzXHJcbiAqIGludGVuZGVkIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBXaGVuIHRoZSBvYmplY3QgbmVlZHMgdG8gYmUgcHJlcGFyZWQsIHRoZSBtZXRob2QgcmV0dXJucyBhIGNsb25lIG9mIHRoZSBzb3VyY2Ugb2JqZWN0LFxyXG4gKiB3aXRoIGFsbCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgc2V0IGFjY29yZGluZyB0byB0aGUgY29sdW1ucyBjb25maWd1cmF0aW9uLlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBvYmplY3QgZG9lcyBub3QgbmVlZCB0byBiZSBwcmVwYXJlZCwgdGhlIG9yaWdpbmFsIG9iamVjdCBpcyByZXR1cm5lZC5cclxuICovXHJcbkNvbHVtblNldC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIGlmICh0aGlzLl9pbm5lci5pc1NpbXBsZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGEgc2ltcGxlIENvbHVtblNldCByZXF1aXJlcyBubyBvYmplY3QgcHJlcGFyYXRpb247XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgIGNvbnN0IGEgPSBjb2xEZXNjKGMsIHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGMuaW5pdCkge1xyXG4gICAgICAgICAgICB0YXJnZXRbYS5uYW1lXSA9IGMuaW5pdC5jYWxsKHNvdXJjZSwgYSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGEuZXhpc3RzIHx8ICdkZWYnIGluIGMpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFthLm5hbWVdID0gYS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbERlc2MoY29sdW1uLCBzb3VyY2UpIHtcclxuICAgIGNvbnN0IGEgPSB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIG5hbWU6IGNvbHVtbi5wcm9wIHx8IGNvbHVtbi5uYW1lXHJcbiAgICB9O1xyXG4gICAgYS5leGlzdHMgPSBhLm5hbWUgaW4gc291cmNlO1xyXG4gICAgaWYgKGEuZXhpc3RzKSB7XHJcbiAgICAgICAgYS52YWx1ZSA9IHNvdXJjZVthLm5hbWVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhLnZhbHVlID0gJ2RlZicgaW4gY29sdW1uID8gY29sdW1uLmRlZiA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBoZWxwZXJzLkNvbHVtblNldCN0b1N0cmluZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHdlbGwtZm9ybWF0dGVkIG11bHRpLWxpbmUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbkNvbHVtblNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcDAgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCksXHJcbiAgICAgICAgZ2FwMSA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSksXHJcbiAgICAgICAgbGluZXMgPSBbXHJcbiAgICAgICAgICAgICdDb2x1bW5TZXQgeydcclxuICAgICAgICBdO1xyXG4gICAgaWYgKHRoaXMudGFibGUpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAndGFibGU6ICcgKyB0aGlzLnRhYmxlKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAxICsgJ2NvbHVtbnM6IFsnKTtcclxuICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgbGluZXMucHVzaChjLnRvU3RyaW5nKDIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAnXScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAnY29sdW1uczogW10nKTtcclxuICAgIH1cclxuICAgIGxpbmVzLnB1c2goZ2FwMCArICd9Jyk7XHJcbiAgICByZXR1cm4gbGluZXMuam9pbihucG0ub3MuRU9MKTtcclxufTtcclxuXHJcbm5wbS51dGlscy5hZGRJbnNwZWN0aW9uKENvbHVtblNldCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtDb2x1bW5TZXR9O1xyXG4iXSwibmFtZXMiOlsiSW5uZXJTdGF0ZSIsInJlcXVpcmUiLCJhc3NlcnQiLCJUYWJsZU5hbWUiLCJDb2x1bW4iLCJucG0iLCJvcyIsInV0aWxzIiwiZm9ybWF0dGluZyIsIkNvbHVtblNldCIsImNvbnN0cnVjdG9yIiwiY29sdW1ucyIsIm9wdCIsIlR5cGVFcnJvciIsImlzTnVsbCIsInRhYmxlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29sTmFtZXMiLCJtYXAiLCJjIiwiY29sIiwibmFtZSIsIkVycm9yIiwiaW5oZXJpdCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInB1c2giLCJmcmVlemUiLCJleHRlbmRTdGF0ZSIsIm5hbWVzIiwidW5kZWZpbmVkIiwidmFyaWFibGVzIiwidXBkYXRlcyIsImlzU2ltcGxlIiwiaSIsImxlbmd0aCIsInByb3AiLCJpbml0IiwiX2lubmVyIiwiX2kiLCJlc2NhcGVkTmFtZSIsImpvaW4iLCJ2YXJpYWJsZSIsImNhc3RUZXh0IiwiYXNzaWduIiwib3B0aW9ucyIsImhhc1ByZWZpeCIsInByZWZpeCIsImR5bmFtaWMiLCJoYXNTb3VyY2UiLCJzb3VyY2UiLCJsaXN0IiwiZmlsdGVyIiwiY25kIiwic2tpcCIsImEiLCJjb2xEZXNjIiwiYXMiLCJhbGlhcyIsImFzc2lnbkNvbHVtbnMiLCJmcm9tIiwidG8iLCJpdGVyYXRvciIsImluZGV4T2YiLCJjb2xzIiwiZXh0ZW5kIiwiY3MiLCJjb25jYXQiLCJtZXJnZSIsImZvckVhY2giLCJpZHgiLCJwcmVwYXJlIiwidGFyZ2V0IiwiZXhpc3RzIiwidmFsdWUiLCJjb2x1bW4iLCJkZWYiLCJ0b1N0cmluZyIsImxldmVsIiwicGFyc2VJbnQiLCJnYXAwIiwibWVzc2FnZUdhcCIsImdhcDEiLCJsaW5lcyIsIkVPTCIsImFkZEluc3BlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/column.js":
/*!*******************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/column.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { InnerState } = __webpack_require__(/*! ../inner-state */ \"(rsc)/./node_modules/pg-promise/lib/inner-state.js\");\nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    os: __webpack_require__(/*! os */ \"os\"),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    formatting: __webpack_require__(/*! ../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    patterns: __webpack_require__(/*! ../patterns */ \"(rsc)/./node_modules/pg-promise/lib/patterns.js\")\n};\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * Read-only structure with details for a single column. Used primarily by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses details into a template, to be used for query generation.\r\n *\r\n * @param {string|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see\r\n * {@link helpers.ColumnConfig ColumnConfig},\r\n * {@link helpers.Column#castText castText},\r\n * {@link helpers.Column#escapedName escapedName},\r\n * {@link helpers.Column#variable variable}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * const col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * const col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * const col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */ class Column extends InnerState {\n    constructor(col){\n        super();\n        if (typeof col === \"string\") {\n            const info = parseColumn(col);\n            this.name = info.name;\n            if (\"mod\" in info) {\n                this.mod = info.mod;\n            }\n            if (\"cnd\" in info) {\n                this.cnd = info.cnd;\n            }\n        } else {\n            col = assert(col, [\n                \"name\",\n                \"prop\",\n                \"mod\",\n                \"cast\",\n                \"cnd\",\n                \"def\",\n                \"init\",\n                \"skip\"\n            ]);\n            if (\"name\" in col) {\n                if (!npm.utils.isText(col.name)) {\n                    throw new TypeError(`Invalid 'name' value: ${npm.utils.toJson(col.name)}. A non-empty string was expected.`);\n                }\n                if (npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\n                    throw new TypeError(`Invalid 'name' syntax: ${npm.utils.toJson(col.name)}.`);\n                }\n                this.name = col.name; // column name + property name (if 'prop' isn't specified)\n                if (!npm.utils.isNull(col.prop)) {\n                    if (!npm.utils.isText(col.prop)) {\n                        throw new TypeError(`Invalid 'prop' value: ${npm.utils.toJson(col.prop)}. A non-empty string was expected.`);\n                    }\n                    if (!isValidVariable(col.prop)) {\n                        throw new TypeError(`Invalid 'prop' syntax: ${npm.utils.toJson(col.prop)}.`);\n                    }\n                    if (col.prop !== col.name) {\n                        // optional property name, if different from the column's name;\n                        this.prop = col.prop;\n                    }\n                }\n                if (!npm.utils.isNull(col.mod)) {\n                    if (typeof col.mod !== \"string\" || !isValidMod(col.mod)) {\n                        throw new TypeError(`Invalid 'mod' value: ${npm.utils.toJson(col.mod)}.`);\n                    }\n                    this.mod = col.mod; // optional format modifier;\n                }\n                if (!npm.utils.isNull(col.cast)) {\n                    this.cast = parseCast(col.cast); // optional SQL type casting\n                }\n                if (\"cnd\" in col) {\n                    this.cnd = !!col.cnd;\n                }\n                if (\"def\" in col) {\n                    this.def = col.def; // optional default\n                }\n                if (typeof col.init === \"function\") {\n                    this.init = col.init; // optional value override (overrides 'def' also)\n                }\n                if (typeof col.skip === \"function\") {\n                    this.skip = col.skip;\n                }\n            } else {\n                throw new TypeError(\"Invalid column details.\");\n            }\n        }\n        const variable = \"${\" + (this.prop || this.name) + (this.mod || \"\") + \"}\";\n        const castText = this.cast ? \"::\" + this.cast : \"\";\n        const escapedName = npm.formatting.as.name(this.name);\n        this.extendState({\n            variable,\n            castText,\n            escapedName\n        });\n        Object.freeze(this);\n    }\n    /**\r\n     * @name helpers.Column#variable\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax formatting variable, ready for direct use in query templates.\r\n     *\r\n     * @example\r\n     *\r\n     * const cs = new pgp.helpers.ColumnSet([\r\n     *     'id',\r\n     *     'coordinate:json',\r\n     *     {\r\n     *         name: 'places',\r\n     *         mod: ':csv',\r\n     *         cast: 'int[]'\r\n     *     }\r\n     * ]);\r\n     *\r\n     * // cs.columns[0].variable = ${id}\r\n     * // cs.columns[1].variable = ${coordinate:json}\r\n     * // cs.columns[2].variable = ${places:csv}::int[]\r\n     */ get variable() {\n        return this._inner.variable;\n    }\n    /**\r\n     * @name helpers.Column#castText\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Full-syntax sql type casting, if there is any, or else an empty string.\r\n     */ get castText() {\n        return this._inner.castText;\n    }\n    /**\r\n     * @name helpers.Column#escapedName\r\n     * @type string\r\n     * @readonly\r\n     * @description\r\n     * Escaped name of the column, ready to be injected into queries directly.\r\n     *\r\n     */ get escapedName() {\n        return this._inner.escapedName;\n    }\n}\nfunction parseCast(name) {\n    if (typeof name === \"string\") {\n        const s = name.replace(/^[:\\s]*|\\s*$/g, \"\");\n        if (s) {\n            return s;\n        }\n    }\n    throw new TypeError(`Invalid 'cast' value: ${npm.utils.toJson(name)}.`);\n}\nfunction parseColumn(name) {\n    const m = name.match(npm.patterns.validColumn);\n    if (m && m[0] === name) {\n        const res = {};\n        if (name[0] === \"?\") {\n            res.cnd = true;\n            name = name.substr(1);\n        }\n        const mod = name.match(npm.patterns.hasValidModifier);\n        if (mod) {\n            res.name = name.substr(0, mod.index);\n            res.mod = mod[0];\n        } else {\n            res.name = name;\n        }\n        return res;\n    }\n    throw new TypeError(`Invalid column syntax: ${npm.utils.toJson(name)}.`);\n}\nfunction isValidMod(mod) {\n    return npm.patterns.validModifiers.indexOf(mod) !== -1;\n}\nfunction isValidVariable(name) {\n    const m = name.match(npm.patterns.validVariable);\n    return !!m && m[0] === name;\n}\n/**\r\n * @method helpers.Column#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ Column.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap0 = npm.utils.messageGap(level), gap1 = npm.utils.messageGap(level + 1), lines = [\n        gap0 + \"Column {\",\n        gap1 + \"name: \" + npm.utils.toJson(this.name)\n    ];\n    if (\"prop\" in this) {\n        lines.push(gap1 + \"prop: \" + npm.utils.toJson(this.prop));\n    }\n    if (\"mod\" in this) {\n        lines.push(gap1 + \"mod: \" + npm.utils.toJson(this.mod));\n    }\n    if (\"cast\" in this) {\n        lines.push(gap1 + \"cast: \" + npm.utils.toJson(this.cast));\n    }\n    if (\"cnd\" in this) {\n        lines.push(gap1 + \"cnd: \" + npm.utils.toJson(this.cnd));\n    }\n    if (\"def\" in this) {\n        lines.push(gap1 + \"def: \" + npm.utils.toJson(this.def));\n    }\n    if (\"init\" in this) {\n        lines.push(gap1 + \"init: [Function]\");\n    }\n    if (\"skip\" in this) {\n        lines.push(gap1 + \"skip: [Function]\");\n    }\n    lines.push(gap0 + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(Column, function() {\n    return this.toString();\n});\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any non-empty string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:list`, `:json`, `:alias`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {*} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */ /**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {*}\r\n * The new value to be used for the corresponding column.\r\n */ /**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {*} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Resolved name of the property within the `source` object, i.e. the value of `name` when `prop` is not used\r\n * for the column, or the value of `prop` when it is specified.\r\n *\r\n * @param {*} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */ module.exports = {\n    Column\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9jb2x1bW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsVUFBVSxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBQ0MsTUFBTSxFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBRXpCLE1BQU1FLE1BQU07SUFDUkMsSUFBSUgsbUJBQU9BLENBQUM7SUFDWkksT0FBT0osbUJBQU9BLENBQUM7SUFDZkssWUFBWUwsbUJBQU9BLENBQUM7SUFDcEJNLFVBQVVOLG1CQUFPQSxDQUFDO0FBQ3RCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2R0MsR0FDRCxNQUFNTyxlQUFlUjtJQUVqQlMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSztRQUVMLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQ3pCLE1BQU1DLE9BQU9DLFlBQVlGO1lBQ3pCLElBQUksQ0FBQ0csSUFBSSxHQUFHRixLQUFLRSxJQUFJO1lBQ3JCLElBQUksU0FBU0YsTUFBTTtnQkFDZixJQUFJLENBQUNHLEdBQUcsR0FBR0gsS0FBS0csR0FBRztZQUN2QjtZQUNBLElBQUksU0FBU0gsTUFBTTtnQkFDZixJQUFJLENBQUNJLEdBQUcsR0FBR0osS0FBS0ksR0FBRztZQUN2QjtRQUNKLE9BQU87WUFDSEwsTUFBTVIsT0FBT1EsS0FBSztnQkFBQztnQkFBUTtnQkFBUTtnQkFBTztnQkFBUTtnQkFBTztnQkFBTztnQkFBUTthQUFPO1lBQy9FLElBQUksVUFBVUEsS0FBSztnQkFDZixJQUFJLENBQUNQLElBQUlFLEtBQUssQ0FBQ1csTUFBTSxDQUFDTixJQUFJRyxJQUFJLEdBQUc7b0JBQzdCLE1BQU0sSUFBSUksVUFBVSxDQUFD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cyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9jb2x1bW4uanM/MGE1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge0lubmVyU3RhdGV9ID0gcmVxdWlyZSgnLi4vaW5uZXItc3RhdGUnKTtcclxuY29uc3Qge2Fzc2VydH0gPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIG9zOiByZXF1aXJlKCdvcycpLFxyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4uL3V0aWxzJyksXHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuLi9mb3JtYXR0aW5nJyksXHJcbiAgICBwYXR0ZXJuczogcmVxdWlyZSgnLi4vcGF0dGVybnMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBjbGFzcyBoZWxwZXJzLkNvbHVtblxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogUmVhZC1vbmx5IHN0cnVjdHVyZSB3aXRoIGRldGFpbHMgZm9yIGEgc2luZ2xlIGNvbHVtbi4gVXNlZCBwcmltYXJpbHkgYnkge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0uXHJcbiAqXHJcbiAqIFRoZSBjbGFzcyBwYXJzZXMgZGV0YWlscyBpbnRvIGEgdGVtcGxhdGUsIHRvIGJlIHVzZWQgZm9yIHF1ZXJ5IGdlbmVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfGhlbHBlcnMuQ29sdW1uQ29uZmlnfSBjb2xcclxuICogQ29sdW1uIGRldGFpbHMsIGRlcGVuZGluZyBvbiB0aGUgdHlwZS5cclxuICpcclxuICogV2hlbiBpdCBpcyBhIHN0cmluZywgaXQgaXMgZXhwZWN0ZWQgdG8gY29udGFpbiBhIG5hbWUgZm9yIGJvdGggdGhlIGNvbHVtbiBhbmQgdGhlIHNvdXJjZSBwcm9wZXJ0eSwgYXNzdW1pbmcgdGhhdCB0aGUgdHdvIGFyZSB0aGUgc2FtZS5cclxuICogVGhlIG5hbWUgbXVzdCBhZGhlcmUgdG8gSmF2YVNjcmlwdCBzeW50YXggZm9yIHZhcmlhYmxlIG5hbWVzLiBUaGUgbmFtZSBjYW4gYmUgYXBwZW5kZWQgd2l0aCBhbnkgZm9ybWF0IG1vZGlmaWVyIGFzIHN1cHBvcnRlZCBieVxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgYXMuZm9ybWF0fSAoYF5gLCBgfmAsIGAjYCwgYDpjc3ZgLCBgOmxpc3RgLCBgOmpzb25gLCBgOmFsaWFzYCwgYDpuYW1lYCwgYDpyYXdgLCBgOnZhbHVlYCksIHdoaWNoIGlzIHRoZW4gcmVtb3ZlZCBmcm9tIHRoZSBuYW1lIGFuZCBwdXRcclxuICogaW50byBwcm9wZXJ0eSBgbW9kYC4gSWYgdGhlIG5hbWUgc3RhcnRzIHdpdGggYD9gLCBpdCBpcyByZW1vdmVkLCB3aGlsZSBzZXR0aW5nIGZsYWcgYGNuZGAgPSBgdHJ1ZWAuXHJcbiAqXHJcbiAqIElmIHRoZSBzdHJpbmcgZG9lc24ndCBhZGhlcmUgdG8gdGhlIGFib3ZlIHJlcXVpcmVtZW50cywgdGhlIG1ldGhvZCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBJbnZhbGlkIGNvbHVtbiBzeW50YXhgLlxyXG4gKlxyXG4gKiBXaGVuIGBjb2xgIGlzIGEgc2ltcGxlIHtAbGluayBoZWxwZXJzLkNvbHVtbkNvbmZpZyBDb2x1bW5Db25maWd9LWxpa2Ugb2JqZWN0LCBpdCBpcyB1c2VkIGFzIGFuIGlucHV0IGNvbmZpZ3VyYXRvciB0byBzZXQgYWxsIHRoZSBwcm9wZXJ0aWVzXHJcbiAqIG9mIHRoZSBjbGFzcy5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcclxuICogRGVzdGluYXRpb24gY29sdW1uIG5hbWUgKyBzb3VyY2UgcHJvcGVydHkgbmFtZSAoaWYgYHByb3BgIGlzIHNraXBwZWQpLiBUaGUgbmFtZSBtdXN0IGFkaGVyZSB0byBKYXZhU2NyaXB0IHN5bnRheCBmb3IgdmFyaWFibGVzLFxyXG4gKiB1bmxlc3MgYHByb3BgIGlzIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSBgbmFtZWAgcmVwcmVzZW50cyBvbmx5IHRoZSBjb2x1bW4gbmFtZSwgYW5kIHRoZXJlZm9yZSBjYW4gYmUgYW55IG5vbi1lbXB0eSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvcF1cclxuICogU291cmNlIHByb3BlcnR5IG5hbWUsIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBjb2x1bW4ncyBuYW1lLiBJdCBtdXN0IGFkaGVyZSB0byBKYXZhU2NyaXB0IHN5bnRheCBmb3IgdmFyaWFibGVzLlxyXG4gKlxyXG4gKiBJdCBpcyBpZ25vcmVkIHdoZW4gaXQgaXMgdGhlIHNhbWUgYXMgYG5hbWVgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21vZF1cclxuICogRm9ybWF0dGluZyBtb2RpZmllciwgYXMgc3VwcG9ydGVkIGJ5IG1ldGhvZCB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgYXMuZm9ybWF0fTogYF5gLCBgfmAsIGAjYCwgYDpjc3ZgLCBgOmxpc3RgLCBgOmpzb25gLCBgOmFsaWFzYCwgYDpuYW1lYCwgYDpyYXdgLCBgOnZhbHVlYC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjYXN0XVxyXG4gKiBTZXJ2ZXItc2lkZSB0eXBlIGNhc3RpbmcsIHdpdGhvdXQgYDo6YCBpbiBmcm9udC5cclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbY25kXVxyXG4gKiBDb25kaXRpb25hbCBjb2x1bW4gZmxhZy5cclxuICpcclxuICogVXNlZCBieSBtZXRob2RzIHtAbGluayBoZWxwZXJzLnVwZGF0ZSB1cGRhdGV9IGFuZCB7QGxpbmsgaGVscGVycy5zZXRzIHNldHN9LCBpZ25vcmVkIGJ5IG1ldGhvZHMge0BsaW5rIGhlbHBlcnMuaW5zZXJ0IGluc2VydH0gYW5kXHJcbiAqIHtAbGluayBoZWxwZXJzLnZhbHVlcyB2YWx1ZXN9LiBJdCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29sdW1uIGlzIHJlc2VydmVkIGZvciBhIGBXSEVSRWAgY29uZGl0aW9uLCBub3QgdG8gYmUgc2V0IG9yIHVwZGF0ZWQuXHJcbiAqXHJcbiAqIEl0IGNhbiBiZSBzZXQgZnJvbSBhIHN0cmluZyBpbml0aWFsaXphdGlvbiwgYnkgYWRkaW5nIGA/YCBpbiBmcm9udCBvZiB0aGUgbmFtZS5cclxuICpcclxuICogQHByb3BlcnR5IHsqfSBbZGVmXVxyXG4gKiBEZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHksIHRvIGJlIHVzZWQgb25seSB3aGVuIHRoZSBzb3VyY2Ugb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGUgcHJvcGVydHkuXHJcbiAqIEl0IGlzIGlnbm9yZWQgd2hlbiBwcm9wZXJ0eSBgaW5pdGAgaXMgc2V0LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2hlbHBlcnMuaW5pdENCfSBbaW5pdF1cclxuICogT3ZlcnJpZGUgY2FsbGJhY2sgZm9yIHRoZSB2YWx1ZS5cclxuICpcclxuICogQHByb3BlcnR5IHtoZWxwZXJzLnNraXBDQn0gW3NraXBdXHJcbiAqIEFuIG92ZXJyaWRlIGZvciBza2lwcGluZyBjb2x1bW5zIGR5bmFtaWNhbGx5LlxyXG4gKlxyXG4gKiBVc2VkIGJ5IG1ldGhvZHMge0BsaW5rIGhlbHBlcnMudXBkYXRlIHVwZGF0ZX0gKGZvciBhIHNpbmdsZSBvYmplY3QpIGFuZCB7QGxpbmsgaGVscGVycy5zZXRzIHNldHN9LCBpZ25vcmVkIGJ5IG1ldGhvZHNcclxuICoge0BsaW5rIGhlbHBlcnMuaW5zZXJ0IGluc2VydH0gYW5kIHtAbGluayBoZWxwZXJzLnZhbHVlcyB2YWx1ZXN9LlxyXG4gKlxyXG4gKiBJdCBpcyBhbHNvIGlnbm9yZWQgd2hlbiBjb25kaXRpb25hbCBmbGFnIGBjbmRgIGlzIHNldC5cclxuICpcclxuICogQHJldHVybnMge2hlbHBlcnMuQ29sdW1ufVxyXG4gKlxyXG4gKiBAc2VlXHJcbiAqIHtAbGluayBoZWxwZXJzLkNvbHVtbkNvbmZpZyBDb2x1bW5Db25maWd9LFxyXG4gKiB7QGxpbmsgaGVscGVycy5Db2x1bW4jY2FzdFRleHQgY2FzdFRleHR9LFxyXG4gKiB7QGxpbmsgaGVscGVycy5Db2x1bW4jZXNjYXBlZE5hbWUgZXNjYXBlZE5hbWV9LFxyXG4gKiB7QGxpbmsgaGVscGVycy5Db2x1bW4jdmFyaWFibGUgdmFyaWFibGV9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKSh7XHJcbiAqICAgICBjYXBTUUw6IHRydWUgLy8gaWYgeW91IHdhbnQgYWxsIGdlbmVyYXRlZCBTUUwgY2FwaXRhbGl6ZWRcclxuICogfSk7XHJcbiAqXHJcbiAqIGNvbnN0IENvbHVtbiA9IHBncC5oZWxwZXJzLkNvbHVtbjtcclxuICpcclxuICogLy8gY3JlYXRpbmcgYSBjb2x1bW4gZnJvbSBqdXN0IGEgbmFtZTpcclxuICogY29uc3QgY29sMSA9IG5ldyBDb2x1bW4oJ2NvbE5hbWUnKTtcclxuICogY29uc29sZS5sb2coY29sMSk7XHJcbiAqIC8vPT5cclxuICogLy8gQ29sdW1uIHtcclxuICogLy8gICAgbmFtZTogXCJjb2xOYW1lXCJcclxuICogLy8gfVxyXG4gKlxyXG4gKiAvLyBjcmVhdGluZyBhIGNvbHVtbiBmcm9tIGEgbmFtZSArIG1vZGlmaWVyOlxyXG4gKiBjb25zdCBjb2wyID0gbmV3IENvbHVtbignY29sTmFtZTpjc3YnKTtcclxuICogY29uc29sZS5sb2coY29sMik7XHJcbiAqIC8vPT5cclxuICogLy8gQ29sdW1uIHtcclxuICogLy8gICAgbmFtZTogXCJjb2xOYW1lXCJcclxuICogLy8gICAgbW9kOiBcIjpjc3ZcIlxyXG4gKiAvLyB9XHJcbiAqXHJcbiAqIC8vIGNyZWF0aW5nIGEgY29sdW1uIGZyb20gYSBjb25maWd1cmF0b3I6XHJcbiAqIGNvbnN0IGNvbDMgPSBuZXcgQ29sdW1uKHtcclxuICogICAgIG5hbWU6ICdjb2xOYW1lJywgLy8gcmVxdWlyZWRcclxuICogICAgIHByb3A6ICdwcm9wTmFtZScsIC8vIG9wdGlvbmFsXHJcbiAqICAgICBtb2Q6ICdeJywgLy8gb3B0aW9uYWxcclxuICogICAgIGRlZjogMTIzIC8vIG9wdGlvbmFsXHJcbiAqIH0pO1xyXG4gKiBjb25zb2xlLmxvZyhjb2wzKTtcclxuICogLy89PlxyXG4gKiAvLyBDb2x1bW4ge1xyXG4gKiAvLyAgICBuYW1lOiBcImNvbE5hbWVcIlxyXG4gKiAvLyAgICBwcm9wOiBcInByb3BOYW1lXCJcclxuICogLy8gICAgbW9kOiBcIl5cIlxyXG4gKiAvLyAgICBkZWY6IDEyM1xyXG4gKiAvLyB9XHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBDb2x1bW4gZXh0ZW5kcyBJbm5lclN0YXRlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb2wpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHBhcnNlQ29sdW1uKGNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGluZm8ubmFtZTtcclxuICAgICAgICAgICAgaWYgKCdtb2QnIGluIGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kID0gaW5mby5tb2Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCdjbmQnIGluIGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY25kID0gaW5mby5jbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2wgPSBhc3NlcnQoY29sLCBbJ25hbWUnLCAncHJvcCcsICdtb2QnLCAnY2FzdCcsICdjbmQnLCAnZGVmJywgJ2luaXQnLCAnc2tpcCddKTtcclxuICAgICAgICAgICAgaWYgKCduYW1lJyBpbiBjb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbnBtLnV0aWxzLmlzVGV4dChjb2wubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICduYW1lJyB2YWx1ZTogJHtucG0udXRpbHMudG9Kc29uKGNvbC5uYW1lKX0uIEEgbm9uLWVtcHR5IHN0cmluZyB3YXMgZXhwZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobnBtLnV0aWxzLmlzTnVsbChjb2wucHJvcCkgJiYgIWlzVmFsaWRWYXJpYWJsZShjb2wubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICduYW1lJyBzeW50YXg6ICR7bnBtLnV0aWxzLnRvSnNvbihjb2wubmFtZSl9LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gY29sLm5hbWU7IC8vIGNvbHVtbiBuYW1lICsgcHJvcGVydHkgbmFtZSAoaWYgJ3Byb3AnIGlzbid0IHNwZWNpZmllZClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5wbS51dGlscy5pc051bGwoY29sLnByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFucG0udXRpbHMuaXNUZXh0KGNvbC5wcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICdwcm9wJyB2YWx1ZTogJHtucG0udXRpbHMudG9Kc29uKGNvbC5wcm9wKX0uIEEgbm9uLWVtcHR5IHN0cmluZyB3YXMgZXhwZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFZhcmlhYmxlKGNvbC5wcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICdwcm9wJyBzeW50YXg6ICR7bnBtLnV0aWxzLnRvSnNvbihjb2wucHJvcCl9LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sLnByb3AgIT09IGNvbC5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHByb3BlcnR5IG5hbWUsIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBjb2x1bW4ncyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3AgPSBjb2wucHJvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5wbS51dGlscy5pc051bGwoY29sLm1vZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbC5tb2QgIT09ICdzdHJpbmcnIHx8ICFpc1ZhbGlkTW9kKGNvbC5tb2QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgJ21vZCcgdmFsdWU6ICR7bnBtLnV0aWxzLnRvSnNvbihjb2wubW9kKX0uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kID0gY29sLm1vZDsgLy8gb3B0aW9uYWwgZm9ybWF0IG1vZGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFucG0udXRpbHMuaXNOdWxsKGNvbC5jYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzdCA9IHBhcnNlQ2FzdChjb2wuY2FzdCk7IC8vIG9wdGlvbmFsIFNRTCB0eXBlIGNhc3RpbmdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgnY25kJyBpbiBjb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNuZCA9ICEhY29sLmNuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgnZGVmJyBpbiBjb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZiA9IGNvbC5kZWY7IC8vIG9wdGlvbmFsIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmluaXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXQgPSBjb2wuaW5pdDsgLy8gb3B0aW9uYWwgdmFsdWUgb3ZlcnJpZGUgKG92ZXJyaWRlcyAnZGVmJyBhbHNvKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2wuc2tpcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IGNvbC5za2lwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb2x1bW4gZGV0YWlscy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSAnJHsnICsgKHRoaXMucHJvcCB8fCB0aGlzLm5hbWUpICsgKHRoaXMubW9kIHx8ICcnKSArICd9JztcclxuICAgICAgICBjb25zdCBjYXN0VGV4dCA9IHRoaXMuY2FzdCA/ICgnOjonICsgdGhpcy5jYXN0KSA6ICcnO1xyXG4gICAgICAgIGNvbnN0IGVzY2FwZWROYW1lID0gbnBtLmZvcm1hdHRpbmcuYXMubmFtZSh0aGlzLm5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmV4dGVuZFN0YXRlKHt2YXJpYWJsZSwgY2FzdFRleHQsIGVzY2FwZWROYW1lfSk7XHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIGhlbHBlcnMuQ29sdW1uI3ZhcmlhYmxlXHJcbiAgICAgKiBAdHlwZSBzdHJpbmdcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBGdWxsLXN5bnRheCBmb3JtYXR0aW5nIHZhcmlhYmxlLCByZWFkeSBmb3IgZGlyZWN0IHVzZSBpbiBxdWVyeSB0ZW1wbGF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBjcyA9IG5ldyBwZ3AuaGVscGVycy5Db2x1bW5TZXQoW1xyXG4gICAgICogICAgICdpZCcsXHJcbiAgICAgKiAgICAgJ2Nvb3JkaW5hdGU6anNvbicsXHJcbiAgICAgKiAgICAge1xyXG4gICAgICogICAgICAgICBuYW1lOiAncGxhY2VzJyxcclxuICAgICAqICAgICAgICAgbW9kOiAnOmNzdicsXHJcbiAgICAgKiAgICAgICAgIGNhc3Q6ICdpbnRbXSdcclxuICAgICAqICAgICB9XHJcbiAgICAgKiBdKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcy5jb2x1bW5zWzBdLnZhcmlhYmxlID0gJHtpZH1cclxuICAgICAqIC8vIGNzLmNvbHVtbnNbMV0udmFyaWFibGUgPSAke2Nvb3JkaW5hdGU6anNvbn1cclxuICAgICAqIC8vIGNzLmNvbHVtbnNbMl0udmFyaWFibGUgPSAke3BsYWNlczpjc3Z9OjppbnRbXVxyXG4gICAgICovXHJcbiAgICBnZXQgdmFyaWFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnZhcmlhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgaGVscGVycy5Db2x1bW4jY2FzdFRleHRcclxuICAgICAqIEB0eXBlIHN0cmluZ1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEZ1bGwtc3ludGF4IHNxbCB0eXBlIGNhc3RpbmcsIGlmIHRoZXJlIGlzIGFueSwgb3IgZWxzZSBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldCBjYXN0VGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIuY2FzdFRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBoZWxwZXJzLkNvbHVtbiNlc2NhcGVkTmFtZVxyXG4gICAgICogQHR5cGUgc3RyaW5nXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogRXNjYXBlZCBuYW1lIG9mIHRoZSBjb2x1bW4sIHJlYWR5IHRvIGJlIGluamVjdGVkIGludG8gcXVlcmllcyBkaXJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGdldCBlc2NhcGVkTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIuZXNjYXBlZE5hbWU7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUNhc3QobmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHMgPSBuYW1lLnJlcGxhY2UoL15bOlxcc10qfFxccyokL2csICcnKTtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICdjYXN0JyB2YWx1ZTogJHtucG0udXRpbHMudG9Kc29uKG5hbWUpfS5gKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VDb2x1bW4obmFtZSkge1xyXG4gICAgY29uc3QgbSA9IG5hbWUubWF0Y2gobnBtLnBhdHRlcm5zLnZhbGlkQ29sdW1uKTtcclxuICAgIGlmIChtICYmIG1bMF0gPT09IG5hbWUpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBpZiAobmFtZVswXSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgIHJlcy5jbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZCA9IG5hbWUubWF0Y2gobnBtLnBhdHRlcm5zLmhhc1ZhbGlkTW9kaWZpZXIpO1xyXG4gICAgICAgIGlmIChtb2QpIHtcclxuICAgICAgICAgICAgcmVzLm5hbWUgPSBuYW1lLnN1YnN0cigwLCBtb2QuaW5kZXgpO1xyXG4gICAgICAgICAgICByZXMubW9kID0gbW9kWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29sdW1uIHN5bnRheDogJHtucG0udXRpbHMudG9Kc29uKG5hbWUpfS5gKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZE1vZChtb2QpIHtcclxuICAgIHJldHVybiBucG0ucGF0dGVybnMudmFsaWRNb2RpZmllcnMuaW5kZXhPZihtb2QpICE9PSAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZFZhcmlhYmxlKG5hbWUpIHtcclxuICAgIGNvbnN0IG0gPSBuYW1lLm1hdGNoKG5wbS5wYXR0ZXJucy52YWxpZFZhcmlhYmxlKTtcclxuICAgIHJldHVybiAhIW0gJiYgbVswXSA9PT0gbmFtZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGVscGVycy5Db2x1bW4jdG9TdHJpbmdcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB3ZWxsLWZvcm1hdHRlZCBtdWx0aS1saW5lIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIG9iamVjdC5cclxuICpcclxuICogSXQgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB3cml0aW5nIHRoZSBvYmplY3QgaW50byB0aGUgY29uc29sZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbD0wXVxyXG4gKiBOZXN0ZWQgb3V0cHV0IGxldmVsLCB0byBwcm92aWRlIHZpc3VhbCBvZmZzZXQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5Db2x1bW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICBsZXZlbCA9IGxldmVsID4gMCA/IHBhcnNlSW50KGxldmVsKSA6IDA7XHJcbiAgICBjb25zdCBnYXAwID0gbnBtLnV0aWxzLm1lc3NhZ2VHYXAobGV2ZWwpLFxyXG4gICAgICAgIGdhcDEgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCArIDEpLFxyXG4gICAgICAgIGxpbmVzID0gW1xyXG4gICAgICAgICAgICBnYXAwICsgJ0NvbHVtbiB7JyxcclxuICAgICAgICAgICAgZ2FwMSArICduYW1lOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLm5hbWUpXHJcbiAgICAgICAgXTtcclxuICAgIGlmICgncHJvcCcgaW4gdGhpcykge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwMSArICdwcm9wOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnByb3ApKTtcclxuICAgIH1cclxuICAgIGlmICgnbW9kJyBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAxICsgJ21vZDogJyArIG5wbS51dGlscy50b0pzb24odGhpcy5tb2QpKTtcclxuICAgIH1cclxuICAgIGlmICgnY2FzdCcgaW4gdGhpcykge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwMSArICdjYXN0OiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLmNhc3QpKTtcclxuICAgIH1cclxuICAgIGlmICgnY25kJyBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAxICsgJ2NuZDogJyArIG5wbS51dGlscy50b0pzb24odGhpcy5jbmQpKTtcclxuICAgIH1cclxuICAgIGlmICgnZGVmJyBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAxICsgJ2RlZjogJyArIG5wbS51dGlscy50b0pzb24odGhpcy5kZWYpKTtcclxuICAgIH1cclxuICAgIGlmICgnaW5pdCcgaW4gdGhpcykge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwMSArICdpbml0OiBbRnVuY3Rpb25dJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ3NraXAnIGluIHRoaXMpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcDEgKyAnc2tpcDogW0Z1bmN0aW9uXScpO1xyXG4gICAgfVxyXG4gICAgbGluZXMucHVzaChnYXAwICsgJ30nKTtcclxuICAgIHJldHVybiBsaW5lcy5qb2luKG5wbS5vcy5FT0wpO1xyXG59O1xyXG5cclxubnBtLnV0aWxzLmFkZEluc3BlY3Rpb24oQ29sdW1uLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiBoZWxwZXJzLkNvbHVtbkNvbmZpZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBzaW1wbGUgc3RydWN0dXJlIHdpdGggY29sdW1uIGRldGFpbHMsIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSB7QGxpbmsgaGVscGVycy5Db2x1bW4gQ29sdW1ufSBjb25zdHJ1Y3RvciBmb3IgaW5pdGlhbGl6YXRpb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXHJcbiAqIERlc3RpbmF0aW9uIGNvbHVtbiBuYW1lICsgc291cmNlIHByb3BlcnR5IG5hbWUgKGlmIGBwcm9wYCBpcyBza2lwcGVkKS4gVGhlIG5hbWUgbXVzdCBhZGhlcmUgdG8gSmF2YVNjcmlwdCBzeW50YXggZm9yIHZhcmlhYmxlcyxcclxuICogdW5sZXNzIGBwcm9wYCBpcyBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgYG5hbWVgIHJlcHJlc2VudHMgb25seSB0aGUgY29sdW1uIG5hbWUsIGFuZCB0aGVyZWZvcmUgY2FuIGJlIGFueSBub24tZW1wdHkgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Byb3BdXHJcbiAqIFNvdXJjZSBwcm9wZXJ0eSBuYW1lLCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgY29sdW1uJ3MgbmFtZS4gSXQgbXVzdCBhZGhlcmUgdG8gSmF2YVNjcmlwdCBzeW50YXggZm9yIHZhcmlhYmxlcy5cclxuICpcclxuICogSXQgaXMgaWdub3JlZCB3aGVuIGl0IGlzIHRoZSBzYW1lIGFzIGBuYW1lYC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RdXHJcbiAqIEZvcm1hdHRpbmcgbW9kaWZpZXIsIGFzIHN1cHBvcnRlZCBieSBtZXRob2Qge0BsaW5rIGZvcm1hdHRpbmcuZm9ybWF0IGFzLmZvcm1hdH06IGBeYCwgYH5gLCBgI2AsIGA6Y3N2YCwgYDpsaXN0YCwgYDpqc29uYCwgYDphbGlhc2AsIGA6bmFtZWAsIGA6cmF3YCwgYDp2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2FzdF1cclxuICogU2VydmVyLXNpZGUgdHlwZSBjYXN0aW5nLiBMZWFkaW5nIGA6OmAgaXMgYWxsb3dlZCwgYnV0IG5vdCBuZWVkZWQgKGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIHNwZWNpZmllZCkuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NuZF1cclxuICogQ29uZGl0aW9uYWwgY29sdW1uIGZsYWcuXHJcbiAqXHJcbiAqIFVzZWQgYnkgbWV0aG9kcyB7QGxpbmsgaGVscGVycy51cGRhdGUgdXBkYXRlfSBhbmQge0BsaW5rIGhlbHBlcnMuc2V0cyBzZXRzfSwgaWdub3JlZCBieSBtZXRob2RzIHtAbGluayBoZWxwZXJzLmluc2VydCBpbnNlcnR9IGFuZFxyXG4gKiB7QGxpbmsgaGVscGVycy52YWx1ZXMgdmFsdWVzfS4gSXQgaW5kaWNhdGVzIHRoYXQgdGhlIGNvbHVtbiBpcyByZXNlcnZlZCBmb3IgYSBgV0hFUkVgIGNvbmRpdGlvbiwgbm90IHRvIGJlIHNldCBvciB1cGRhdGVkLlxyXG4gKlxyXG4gKiBJdCBjYW4gYmUgc2V0IGZyb20gYSBzdHJpbmcgaW5pdGlhbGl6YXRpb24sIGJ5IGFkZGluZyBgP2AgaW4gZnJvbnQgb2YgdGhlIG5hbWUuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW2RlZl1cclxuICogRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LCB0byBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgc291cmNlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIHByb3BlcnR5LlxyXG4gKiBJdCBpcyBpZ25vcmVkIHdoZW4gcHJvcGVydHkgYGluaXRgIGlzIHNldC5cclxuICpcclxuICogQHByb3BlcnR5IHtoZWxwZXJzLmluaXRDQn0gW2luaXRdXHJcbiAqIE92ZXJyaWRlIGNhbGxiYWNrIGZvciB0aGUgdmFsdWUuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7aGVscGVycy5za2lwQ0J9IFtza2lwXVxyXG4gKiBBbiBvdmVycmlkZSBmb3Igc2tpcHBpbmcgY29sdW1ucyBkeW5hbWljYWxseS5cclxuICpcclxuICogVXNlZCBieSBtZXRob2RzIHtAbGluayBoZWxwZXJzLnVwZGF0ZSB1cGRhdGV9IChmb3IgYSBzaW5nbGUgb2JqZWN0KSBhbmQge0BsaW5rIGhlbHBlcnMuc2V0cyBzZXRzfSwgaWdub3JlZCBieSBtZXRob2RzXHJcbiAqIHtAbGluayBoZWxwZXJzLmluc2VydCBpbnNlcnR9IGFuZCB7QGxpbmsgaGVscGVycy52YWx1ZXMgdmFsdWVzfS5cclxuICpcclxuICogSXQgaXMgYWxzbyBpZ25vcmVkIHdoZW4gY29uZGl0aW9uYWwgZmxhZyBgY25kYCBpcyBzZXQuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBoZWxwZXJzLmluaXRDQlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBjYWxsYmFjayBmdW5jdGlvbiB0eXBlIHVzZWQgYnkgcGFyYW1ldGVyIGBpbml0YCB3aXRoaW4ge0BsaW5rIGhlbHBlcnMuQ29sdW1uQ29uZmlnIENvbHVtbkNvbmZpZ30uXHJcbiAqXHJcbiAqIEl0IHdvcmtzIGFzIGFuIG92ZXJyaWRlIGZvciB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZSBpbiB0aGUgYHNvdXJjZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYHRoaXNgIHNldCB0byB0aGUgYHNvdXJjZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbFxyXG4gKiBDb2x1bW4tdG8tcHJvcGVydHkgZGVzY3JpcHRvci5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGNvbC5zb3VyY2VcclxuICogVGhlIHNvdXJjZSBvYmplY3QsIGVxdWFscyB0byBgdGhpc2AgdGhhdCdzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbC5uYW1lXHJcbiAqIFJlc29sdmVkIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdpdGhpbiB0aGUgYHNvdXJjZWAgb2JqZWN0LCBpLmUuIHRoZSB2YWx1ZSBvZiBgbmFtZWAgd2hlbiBgcHJvcGAgaXMgbm90IHVzZWRcclxuICogZm9yIHRoZSBjb2x1bW4sIG9yIHRoZSB2YWx1ZSBvZiBgcHJvcGAgd2hlbiBpdCBpcyBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29sLnZhbHVlXHJcbiAqXHJcbiAqIFByb3BlcnR5IHZhbHVlLCBzZXQgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqIC0gVmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGhpbiB0aGUgYHNvdXJjZWAgb2JqZWN0IChgdmFsdWVgID0gYHNvdXJjZVtuYW1lXWApLCBpZiB0aGUgcHJvcGVydHkgZXhpc3RzXHJcbiAqIC0gSWYgdGhlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgYW5kIGBkZWZgIGlzIHNldCBpbiB0aGUgY29sdW1uLCB0aGVuIGB2YWx1ZWAgaXMgc2V0IHRvIHRoZSB2YWx1ZSBvZiBgZGVmYFxyXG4gKiAtIElmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGFuZCBgZGVmYCBpcyBub3Qgc2V0IGluIHRoZSBjb2x1bW4sIHRoZW4gYHZhbHVlYCBpcyBzZXQgdG8gYHVuZGVmaW5lZGBcclxuICpcclxuICogQHBhcmFtIHtib29sZWFufSBjb2wuZXhpc3RzXHJcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIGBzb3VyY2VgIG9iamVjdCAoYGV4aXN0cyA9IG5hbWUgaW4gc291cmNlYCkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKiBUaGUgbmV3IHZhbHVlIHRvIGJlIHVzZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbi5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIGhlbHBlcnMuc2tpcENCXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHR5cGUgdXNlZCBieSBwYXJhbWV0ZXIgYHNraXBgIHdpdGhpbiB7QGxpbmsgaGVscGVycy5Db2x1bW5Db25maWcgQ29sdW1uQ29uZmlnfS5cclxuICpcclxuICogSXQgaXMgdG8gZHluYW1pY2FsbHkgZGV0ZXJtaW5lIHdoZW4gdGhlIHByb3BlcnR5IHdpdGggc3BlY2lmaWVkIGBuYW1lYCBpbiB0aGUgYHNvdXJjZWAgb2JqZWN0IGlzIHRvIGJlIHNraXBwZWQuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBgdGhpc2Agc2V0IHRvIHRoZSBgc291cmNlYCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29sXHJcbiAqIENvbHVtbi10by1wcm9wZXJ0eSBkZXNjcmlwdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29sLnNvdXJjZVxyXG4gKiBUaGUgc291cmNlIG9iamVjdCwgZXF1YWxzIHRvIGB0aGlzYCB0aGF0J3MgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sLm5hbWVcclxuICogUmVzb2x2ZWQgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoZSBgc291cmNlYCBvYmplY3QsIGkuZS4gdGhlIHZhbHVlIG9mIGBuYW1lYCB3aGVuIGBwcm9wYCBpcyBub3QgdXNlZFxyXG4gKiBmb3IgdGhlIGNvbHVtbiwgb3IgdGhlIHZhbHVlIG9mIGBwcm9wYCB3aGVuIGl0IGlzIHNwZWNpZmllZC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb2wudmFsdWVcclxuICpcclxuICogUHJvcGVydHkgdmFsdWUsIHNldCB0byBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogLSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoZSBgc291cmNlYCBvYmplY3QgKGB2YWx1ZWAgPSBgc291cmNlW25hbWVdYCksIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHNcclxuICogLSBJZiB0aGUgcHJvcGVydHkgZG9lc24ndCBleGlzdCBhbmQgYGRlZmAgaXMgc2V0IGluIHRoZSBjb2x1bW4sIHRoZW4gYHZhbHVlYCBpcyBzZXQgdG8gdGhlIHZhbHVlIG9mIGBkZWZgXHJcbiAqIC0gSWYgdGhlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgYW5kIGBkZWZgIGlzIG5vdCBzZXQgaW4gdGhlIGNvbHVtbiwgdGhlbiBgdmFsdWVgIGlzIHNldCB0byBgdW5kZWZpbmVkYFxyXG4gKlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbC5leGlzdHNcclxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiB0aGUgYHNvdXJjZWAgb2JqZWN0IChgZXhpc3RzID0gbmFtZSBpbiBzb3VyY2VgKS5cclxuICpcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEEgdHJ1dGh5IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyB0byBiZSBza2lwcGVkLlxyXG4gKlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge0NvbHVtbn07XHJcbiJdLCJuYW1lcyI6WyJJbm5lclN0YXRlIiwicmVxdWlyZSIsImFzc2VydCIsIm5wbSIsIm9zIiwidXRpbHMiLCJmb3JtYXR0aW5nIiwicGF0dGVybnMiLCJDb2x1bW4iLCJjb25zdHJ1Y3RvciIsImNvbCIsImluZm8iLCJwYXJzZUNvbHVtbiIsIm5hbWUiLCJtb2QiLCJjbmQiLCJpc1RleHQiLCJUeXBlRXJyb3IiLCJ0b0pzb24iLCJpc051bGwiLCJwcm9wIiwiaXNWYWxpZFZhcmlhYmxlIiwiaXNWYWxpZE1vZCIsImNhc3QiLCJwYXJzZUNhc3QiLCJkZWYiLCJpbml0Iiwic2tpcCIsInZhcmlhYmxlIiwiY2FzdFRleHQiLCJlc2NhcGVkTmFtZSIsImFzIiwiZXh0ZW5kU3RhdGUiLCJPYmplY3QiLCJmcmVlemUiLCJfaW5uZXIiLCJzIiwicmVwbGFjZSIsIm0iLCJtYXRjaCIsInZhbGlkQ29sdW1uIiwicmVzIiwic3Vic3RyIiwiaGFzVmFsaWRNb2RpZmllciIsImluZGV4IiwidmFsaWRNb2RpZmllcnMiLCJpbmRleE9mIiwidmFsaWRWYXJpYWJsZSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwibGV2ZWwiLCJwYXJzZUludCIsImdhcDAiLCJtZXNzYWdlR2FwIiwiZ2FwMSIsImxpbmVzIiwicHVzaCIsImpvaW4iLCJFT0wiLCJhZGRJbnNwZWN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/column.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/index.js":
/*!******************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Column } = __webpack_require__(/*! ./column */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column.js\");\nconst { ColumnSet } = __webpack_require__(/*! ./column-set */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\");\nconst { TableName } = __webpack_require__(/*! ./table-name */ \"(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js\");\nconst method = __webpack_require__(/*! ./methods */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/index.js\");\n/**\r\n * @namespace helpers\r\n * @description\r\n * Namespace for query-formatting generators, available as {@link module:pg-promise~helpers pgp.helpers}, after initializing the library.\r\n *\r\n * It unifies the approach to generating multi-row `INSERT` / `UPDATE` queries with the single-row ones.\r\n *\r\n * See also: $[Performance Boost].\r\n *\r\n * @property {function} TableName\r\n * {@link helpers.TableName TableName} class constructor.\r\n *\r\n * @property {function} ColumnSet\r\n * {@link helpers.ColumnSet ColumnSet} class constructor.\r\n *\r\n * @property {function} Column\r\n * {@link helpers.Column Column} class constructor.\r\n *\r\n * @property {function} insert\r\n * {@link helpers.insert insert} static method.\r\n *\r\n * @property {function} update\r\n * {@link helpers.update update} static method.\r\n *\r\n * @property {function} values\r\n * {@link helpers.values values} static method.\r\n *\r\n * @property {function} sets\r\n * {@link helpers.sets sets} static method.\r\n *\r\n * @property {function} concat\r\n * {@link helpers.concat concat} static method.\r\n */ module.exports = (config)=>{\n    const capSQL = ()=>config.options && config.options.capSQL;\n    const res = {\n        insert (data, columns, table) {\n            return method.insert(data, columns, table, capSQL());\n        },\n        update (data, columns, table, options) {\n            return method.update(data, columns, table, options, capSQL());\n        },\n        concat (queries) {\n            return method.concat(queries, capSQL());\n        },\n        values (data, columns) {\n            return method.values(data, columns, capSQL());\n        },\n        sets (data, columns) {\n            return method.sets(data, columns, capSQL());\n        },\n        TableName,\n        ColumnSet,\n        Column\n    };\n    return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxNQUFNLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFDQyxTQUFTLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFDRSxTQUFTLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFFdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0NDLEdBQ0RJLE9BQU9DLE9BQU8sR0FBR0MsQ0FBQUE7SUFDYixNQUFNQyxTQUFTLElBQU1ELE9BQU9FLE9BQU8sSUFBSUYsT0FBT0UsT0FBTyxDQUFDRCxNQUFNO0lBQzVELE1BQU1FLE1BQU07UUFDUkMsUUFBT0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEtBQUs7WUFDdkIsT0FBT1YsT0FBT08sTUFBTSxDQUFDQyxNQUFNQyxTQUFTQyxPQUFPTjtRQUMvQztRQUNBTyxRQUFPSCxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFTCxPQUFPO1lBQ2hDLE9BQU9MLE9BQU9XLE1BQU0sQ0FBQ0gsTUFBTUMsU0FBU0MsT0FBT0wsU0FBU0Q7UUFDeEQ7UUFDQVEsUUFBT0MsT0FBTztZQUNWLE9BQU9iLE9BQU9ZLE1BQU0sQ0FBQ0MsU0FBU1Q7UUFDbEM7UUFDQVUsUUFBT04sSUFBSSxFQUFFQyxPQUFPO1lBQ2hCLE9BQU9ULE9BQU9jLE1BQU0sQ0FBQ04sTUFBTUMsU0FBU0w7UUFDeEM7UUFDQVcsTUFBS1AsSUFBSSxFQUFFQyxPQUFPO1lBQ2QsT0FBT1QsT0FBT2UsSUFBSSxDQUFDUCxNQUFNQyxTQUFTTDtRQUN0QztRQUNBTDtRQUNBRDtRQUNBRjtJQUNKO0lBQ0EsT0FBT1U7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2hlbHBlcnMvaW5kZXguanM/MTg5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge0NvbHVtbn0gPSByZXF1aXJlKCcuL2NvbHVtbicpO1xyXG5jb25zdCB7Q29sdW1uU2V0fSA9IHJlcXVpcmUoJy4vY29sdW1uLXNldCcpO1xyXG5jb25zdCB7VGFibGVOYW1lfSA9IHJlcXVpcmUoJy4vdGFibGUtbmFtZScpO1xyXG5jb25zdCBtZXRob2QgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIGhlbHBlcnNcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIE5hbWVzcGFjZSBmb3IgcXVlcnktZm9ybWF0dGluZyBnZW5lcmF0b3JzLCBhdmFpbGFibGUgYXMge0BsaW5rIG1vZHVsZTpwZy1wcm9taXNlfmhlbHBlcnMgcGdwLmhlbHBlcnN9LCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAqXHJcbiAqIEl0IHVuaWZpZXMgdGhlIGFwcHJvYWNoIHRvIGdlbmVyYXRpbmcgbXVsdGktcm93IGBJTlNFUlRgIC8gYFVQREFURWAgcXVlcmllcyB3aXRoIHRoZSBzaW5nbGUtcm93IG9uZXMuXHJcbiAqXHJcbiAqIFNlZSBhbHNvOiAkW1BlcmZvcm1hbmNlIEJvb3N0XS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gVGFibGVOYW1lXHJcbiAqIHtAbGluayBoZWxwZXJzLlRhYmxlTmFtZSBUYWJsZU5hbWV9IGNsYXNzIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBDb2x1bW5TZXRcclxuICoge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0gY2xhc3MgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IENvbHVtblxyXG4gKiB7QGxpbmsgaGVscGVycy5Db2x1bW4gQ29sdW1ufSBjbGFzcyBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gaW5zZXJ0XHJcbiAqIHtAbGluayBoZWxwZXJzLmluc2VydCBpbnNlcnR9IHN0YXRpYyBtZXRob2QuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHVwZGF0ZVxyXG4gKiB7QGxpbmsgaGVscGVycy51cGRhdGUgdXBkYXRlfSBzdGF0aWMgbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB2YWx1ZXNcclxuICoge0BsaW5rIGhlbHBlcnMudmFsdWVzIHZhbHVlc30gc3RhdGljIG1ldGhvZC5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc2V0c1xyXG4gKiB7QGxpbmsgaGVscGVycy5zZXRzIHNldHN9IHN0YXRpYyBtZXRob2QuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNvbmNhdFxyXG4gKiB7QGxpbmsgaGVscGVycy5jb25jYXQgY29uY2F0fSBzdGF0aWMgbWV0aG9kLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBjb25maWcgPT4ge1xyXG4gICAgY29uc3QgY2FwU1FMID0gKCkgPT4gY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMuY2FwU1FMO1xyXG4gICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgIGluc2VydChkYXRhLCBjb2x1bW5zLCB0YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmluc2VydChkYXRhLCBjb2x1bW5zLCB0YWJsZSwgY2FwU1FMKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlKGRhdGEsIGNvbHVtbnMsIHRhYmxlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QudXBkYXRlKGRhdGEsIGNvbHVtbnMsIHRhYmxlLCBvcHRpb25zLCBjYXBTUUwoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25jYXQocXVlcmllcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNvbmNhdChxdWVyaWVzLCBjYXBTUUwoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YWx1ZXMoZGF0YSwgY29sdW1ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnZhbHVlcyhkYXRhLCBjb2x1bW5zLCBjYXBTUUwoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRzKGRhdGEsIGNvbHVtbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5zZXRzKGRhdGEsIGNvbHVtbnMsIGNhcFNRTCgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFRhYmxlTmFtZSxcclxuICAgICAgICBDb2x1bW5TZXQsXHJcbiAgICAgICAgQ29sdW1uXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuIl0sIm5hbWVzIjpbIkNvbHVtbiIsInJlcXVpcmUiLCJDb2x1bW5TZXQiLCJUYWJsZU5hbWUiLCJtZXRob2QiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29uZmlnIiwiY2FwU1FMIiwib3B0aW9ucyIsInJlcyIsImluc2VydCIsImRhdGEiLCJjb2x1bW5zIiwidGFibGUiLCJ1cGRhdGUiLCJjb25jYXQiLCJxdWVyaWVzIiwidmFsdWVzIiwic2V0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/concat.js":
/*!***************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/concat.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { QueryFile } = __webpack_require__(/*! ../../query-file */ \"(rsc)/./node_modules/pg-promise/lib/query-file.js\");\nconst npm = {\n    formatting: __webpack_require__(/*! ../../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\")\n};\n/**\r\n * @method helpers.concat\r\n * @description\r\n * Formats and concatenates multiple queries into a single query string.\r\n *\r\n * Before joining the queries, the method does the following:\r\n *  - Formats each query, if `values` are provided;\r\n *  - Removes all leading and trailing spaces, tabs and semi-colons;\r\n *  - Automatically skips all empty queries.\r\n *\r\n * @param {array<string|helpers.QueryFormat|QueryFile>} queries\r\n * Array of mixed-type elements:\r\n * - a simple query string, to be used as is\r\n * - a {@link helpers.QueryFormat QueryFormat}-like object = `{query, [values], [options]}`\r\n * - a {@link QueryFile} object\r\n *\r\n * @returns {string}\r\n * Concatenated string with all queries.\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const qf1 = new pgp.QueryFile('./query1.sql', {minify: true});\r\n * const qf2 = new pgp.QueryFile('./query2.sql', {minify: true});\r\n *\r\n * const query = pgp.helpers.concat([\r\n *     {query: 'INSERT INTO Users(name, age) VALUES($1, $2)', values: ['John', 23]}, // QueryFormat-like object\r\n *     {query: qf1, values: [1, 'Name']}, // QueryFile with formatting parameters\r\n *     'SELECT count(*) FROM Users', // a simple-string query,\r\n *     qf2 // direct QueryFile object\r\n * ]);\r\n *\r\n * // query = concatenated string with all the queries\r\n */ function concat(queries, capSQL) {\n    if (!Array.isArray(queries)) {\n        throw new TypeError(\"Parameter 'queries' must be an array.\");\n    }\n    const fmOptions = {\n        capSQL\n    };\n    const all = queries.map((q, index)=>{\n        if (typeof q === \"string\") {\n            // a simple query string without parameters:\n            return clean(q);\n        }\n        if (q && typeof q === \"object\") {\n            if (q instanceof QueryFile) {\n                // QueryFile object:\n                return clean(q[npm.formatting.as.ctf.toPostgres]());\n            }\n            if (\"query\" in q) {\n                // object {query, values, options}:\n                let opt = q.options && typeof q.options === \"object\" ? q.options : {};\n                opt = opt.capSQL === undefined ? Object.assign(opt, fmOptions) : opt;\n                return clean(npm.formatting.as.format(q.query, q.values, opt));\n            }\n        }\n        throw new Error(`Invalid query element at index ${index}.`);\n    });\n    return all.filter((q)=>q).join(\";\");\n}\nfunction clean(q) {\n    // removes from the query all leading and trailing symbols ' ', '\\t' and ';'\n    return q.replace(/^[\\s;]*|[\\s;]*$/g, \"\");\n}\nmodule.exports = {\n    concat\n}; /**\r\n * @typedef helpers.QueryFormat\r\n * @description\r\n * A simple structure of parameters to be passed into method {@link formatting.format as.format} exactly as they are,\r\n * used by {@link helpers.concat}.\r\n *\r\n * @property {string|value|object} query\r\n * A query string or a value/object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n *\r\n * @property {array|object|value} [values]\r\n * Query-formatting values.\r\n *\r\n * @property {object} [options]\r\n * Query-formatting options, as supported by method {@link formatting.format as.format}.\r\n *\r\n * @see\r\n * {@link formatting.format as.format}\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL2NvbmNhdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxTQUFTLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFNUIsTUFBTUMsTUFBTTtJQUNSQyxZQUFZRixtQkFBT0EsQ0FBQztBQUN4QjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0NDLEdBQ0QsU0FBU0csT0FBT0MsT0FBTyxFQUFFQyxNQUFNO0lBQzNCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSCxVQUFVO1FBQ3pCLE1BQU0sSUFBSUksVUFBVTtJQUN4QjtJQUNBLE1BQU1DLFlBQVk7UUFBQ0o7SUFBTTtJQUN6QixNQUFNSyxNQUFNTixRQUFRTyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0M7UUFDeEIsSUFBSSxPQUFPRCxNQUFNLFVBQVU7WUFDdkIsNENBQTRDO1lBQzVDLE9BQU9FLE1BQU1GO1FBQ2pCO1FBQ0EsSUFBSUEsS0FBSyxPQUFPQSxNQUFNLFVBQVU7WUFDNUIsSUFBSUEsYUFBYWIsV0FBVztnQkFDeEIsb0JBQW9CO2dCQUNwQixPQUFPZSxNQUFNRixDQUFDLENBQUNYLElBQUlDLFVBQVUsQ0FBQ2EsRUFBRSxDQUFDQyxHQUFHLENBQUNDLFVBQVUsQ0FBQztZQUNwRDtZQUNBLElBQUksV0FBV0wsR0FBRztnQkFDZCxtQ0FBbUM7Z0JBQ25DLElBQUlNLE1BQU1OLEVBQUVPLE9BQU8sSUFBSSxPQUFPUCxFQUFFTyxPQUFPLEtBQUssV0FBV1AsRUFBRU8sT0FBTyxHQUFHLENBQUM7Z0JBQ3BFRCxNQUFNQSxJQUFJYixNQUFNLEtBQUtlLFlBQVlDLE9BQU9DLE1BQU0sQ0FBQ0osS0FBS1QsYUFBYVM7Z0JBQ2pFLE9BQU9KLE1BQU1iLElBQUlDLFVBQVUsQ0FBQ2EsRUFBRSxDQUFDUSxNQUFNLENBQUNYLEVBQUVZLEtBQUssRUFBRVosRUFBRWEsTUFBTSxFQUFFUDtZQUM3RDtRQUNKO1FBQ0EsTUFBTSxJQUFJUSxNQUFNLENBQUMsK0JBQStCLEVBQUViLE1BQU0sQ0FBQyxDQUFDO0lBQzlEO0lBRUEsT0FBT0gsSUFBSWlCLE1BQU0sQ0FBQ2YsQ0FBQUEsSUFBS0EsR0FBR2dCLElBQUksQ0FBQztBQUNuQztBQUVBLFNBQVNkLE1BQU1GLENBQUM7SUFDWiw0RUFBNEU7SUFDNUUsT0FBT0EsRUFBRWlCLE9BQU8sQ0FBQyxvQkFBb0I7QUFDekM7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQUM1QjtBQUFNLEdBRXhCOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2hlbHBlcnMvbWV0aG9kcy9jb25jYXQuanM/MjgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1F1ZXJ5RmlsZX0gPSByZXF1aXJlKCcuLi8uLi9xdWVyeS1maWxlJyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuLi8uLi9mb3JtYXR0aW5nJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhlbHBlcnMuY29uY2F0XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBGb3JtYXRzIGFuZCBjb25jYXRlbmF0ZXMgbXVsdGlwbGUgcXVlcmllcyBpbnRvIGEgc2luZ2xlIHF1ZXJ5IHN0cmluZy5cclxuICpcclxuICogQmVmb3JlIGpvaW5pbmcgdGhlIHF1ZXJpZXMsIHRoZSBtZXRob2QgZG9lcyB0aGUgZm9sbG93aW5nOlxyXG4gKiAgLSBGb3JtYXRzIGVhY2ggcXVlcnksIGlmIGB2YWx1ZXNgIGFyZSBwcm92aWRlZDtcclxuICogIC0gUmVtb3ZlcyBhbGwgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzLCB0YWJzIGFuZCBzZW1pLWNvbG9ucztcclxuICogIC0gQXV0b21hdGljYWxseSBza2lwcyBhbGwgZW1wdHkgcXVlcmllcy5cclxuICpcclxuICogQHBhcmFtIHthcnJheTxzdHJpbmd8aGVscGVycy5RdWVyeUZvcm1hdHxRdWVyeUZpbGU+fSBxdWVyaWVzXHJcbiAqIEFycmF5IG9mIG1peGVkLXR5cGUgZWxlbWVudHM6XHJcbiAqIC0gYSBzaW1wbGUgcXVlcnkgc3RyaW5nLCB0byBiZSB1c2VkIGFzIGlzXHJcbiAqIC0gYSB7QGxpbmsgaGVscGVycy5RdWVyeUZvcm1hdCBRdWVyeUZvcm1hdH0tbGlrZSBvYmplY3QgPSBge3F1ZXJ5LCBbdmFsdWVzXSwgW29wdGlvbnNdfWBcclxuICogLSBhIHtAbGluayBRdWVyeUZpbGV9IG9iamVjdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBDb25jYXRlbmF0ZWQgc3RyaW5nIHdpdGggYWxsIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKSgpO1xyXG4gKlxyXG4gKiBjb25zdCBxZjEgPSBuZXcgcGdwLlF1ZXJ5RmlsZSgnLi9xdWVyeTEuc3FsJywge21pbmlmeTogdHJ1ZX0pO1xyXG4gKiBjb25zdCBxZjIgPSBuZXcgcGdwLlF1ZXJ5RmlsZSgnLi9xdWVyeTIuc3FsJywge21pbmlmeTogdHJ1ZX0pO1xyXG4gKlxyXG4gKiBjb25zdCBxdWVyeSA9IHBncC5oZWxwZXJzLmNvbmNhdChbXHJcbiAqICAgICB7cXVlcnk6ICdJTlNFUlQgSU5UTyBVc2VycyhuYW1lLCBhZ2UpIFZBTFVFUygkMSwgJDIpJywgdmFsdWVzOiBbJ0pvaG4nLCAyM119LCAvLyBRdWVyeUZvcm1hdC1saWtlIG9iamVjdFxyXG4gKiAgICAge3F1ZXJ5OiBxZjEsIHZhbHVlczogWzEsICdOYW1lJ119LCAvLyBRdWVyeUZpbGUgd2l0aCBmb3JtYXR0aW5nIHBhcmFtZXRlcnNcclxuICogICAgICdTRUxFQ1QgY291bnQoKikgRlJPTSBVc2VycycsIC8vIGEgc2ltcGxlLXN0cmluZyBxdWVyeSxcclxuICogICAgIHFmMiAvLyBkaXJlY3QgUXVlcnlGaWxlIG9iamVjdFxyXG4gKiBdKTtcclxuICpcclxuICogLy8gcXVlcnkgPSBjb25jYXRlbmF0ZWQgc3RyaW5nIHdpdGggYWxsIHRoZSBxdWVyaWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25jYXQocXVlcmllcywgY2FwU1FMKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocXVlcmllcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgXFwncXVlcmllc1xcJyBtdXN0IGJlIGFuIGFycmF5LicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZm1PcHRpb25zID0ge2NhcFNRTH07XHJcbiAgICBjb25zdCBhbGwgPSBxdWVyaWVzLm1hcCgocSwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIGEgc2ltcGxlIHF1ZXJ5IHN0cmluZyB3aXRob3V0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICAgIHJldHVybiBjbGVhbihxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHEgJiYgdHlwZW9mIHEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChxIGluc3RhbmNlb2YgUXVlcnlGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBRdWVyeUZpbGUgb2JqZWN0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuKHFbbnBtLmZvcm1hdHRpbmcuYXMuY3RmLnRvUG9zdGdyZXNdKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgncXVlcnknIGluIHEpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCB7cXVlcnksIHZhbHVlcywgb3B0aW9uc306XHJcbiAgICAgICAgICAgICAgICBsZXQgb3B0ID0gcS5vcHRpb25zICYmIHR5cGVvZiBxLm9wdGlvbnMgPT09ICdvYmplY3QnID8gcS5vcHRpb25zIDoge307XHJcbiAgICAgICAgICAgICAgICBvcHQgPSBvcHQuY2FwU1FMID09PSB1bmRlZmluZWQgPyBPYmplY3QuYXNzaWduKG9wdCwgZm1PcHRpb25zKSA6IG9wdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbihucG0uZm9ybWF0dGluZy5hcy5mb3JtYXQocS5xdWVyeSwgcS52YWx1ZXMsIG9wdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBxdWVyeSBlbGVtZW50IGF0IGluZGV4ICR7aW5kZXh9LmApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGFsbC5maWx0ZXIocSA9PiBxKS5qb2luKCc7Jyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFuKHEpIHtcclxuICAgIC8vIHJlbW92ZXMgZnJvbSB0aGUgcXVlcnkgYWxsIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHN5bWJvbHMgJyAnLCAnXFx0JyBhbmQgJzsnXHJcbiAgICByZXR1cm4gcS5yZXBsYWNlKC9eW1xccztdKnxbXFxzO10qJC9nLCAnJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge2NvbmNhdH07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgaGVscGVycy5RdWVyeUZvcm1hdFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBzaW1wbGUgc3RydWN0dXJlIG9mIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIGludG8gbWV0aG9kIHtAbGluayBmb3JtYXR0aW5nLmZvcm1hdCBhcy5mb3JtYXR9IGV4YWN0bHkgYXMgdGhleSBhcmUsXHJcbiAqIHVzZWQgYnkge0BsaW5rIGhlbHBlcnMuY29uY2F0fS5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd8dmFsdWV8b2JqZWN0fSBxdWVyeVxyXG4gKiBBIHF1ZXJ5IHN0cmluZyBvciBhIHZhbHVlL29iamVjdCB0aGF0IGltcGxlbWVudHMgJFtDdXN0b20gVHlwZSBGb3JtYXR0aW5nXSwgdG8gYmUgZm9ybWF0dGVkIGFjY29yZGluZyB0byBgdmFsdWVzYC5cclxuICpcclxuICogQHByb3BlcnR5IHthcnJheXxvYmplY3R8dmFsdWV9IFt2YWx1ZXNdXHJcbiAqIFF1ZXJ5LWZvcm1hdHRpbmcgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gW29wdGlvbnNdXHJcbiAqIFF1ZXJ5LWZvcm1hdHRpbmcgb3B0aW9ucywgYXMgc3VwcG9ydGVkIGJ5IG1ldGhvZCB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgYXMuZm9ybWF0fS5cclxuICpcclxuICogQHNlZVxyXG4gKiB7QGxpbmsgZm9ybWF0dGluZy5mb3JtYXQgYXMuZm9ybWF0fVxyXG4gKi9cclxuIl0sIm5hbWVzIjpbIlF1ZXJ5RmlsZSIsInJlcXVpcmUiLCJucG0iLCJmb3JtYXR0aW5nIiwiY29uY2F0IiwicXVlcmllcyIsImNhcFNRTCIsIkFycmF5IiwiaXNBcnJheSIsIlR5cGVFcnJvciIsImZtT3B0aW9ucyIsImFsbCIsIm1hcCIsInEiLCJpbmRleCIsImNsZWFuIiwiYXMiLCJjdGYiLCJ0b1Bvc3RncmVzIiwib3B0Iiwib3B0aW9ucyIsInVuZGVmaW5lZCIsIk9iamVjdCIsImFzc2lnbiIsImZvcm1hdCIsInF1ZXJ5IiwidmFsdWVzIiwiRXJyb3IiLCJmaWx0ZXIiLCJqb2luIiwicmVwbGFjZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/concat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { concat } = __webpack_require__(/*! ./concat */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/concat.js\");\nconst { insert } = __webpack_require__(/*! ./insert */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/insert.js\");\nconst { update } = __webpack_require__(/*! ./update */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/update.js\");\nconst { values } = __webpack_require__(/*! ./values */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/values.js\");\nconst { sets } = __webpack_require__(/*! ./sets */ \"(rsc)/./node_modules/pg-promise/lib/helpers/methods/sets.js\");\nmodule.exports = {\n    concat,\n    insert,\n    update,\n    values,\n    sets\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUNBLE1BQU0sRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUNDLE1BQU0sRUFBQyxHQUFHRCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUNFLE1BQU0sRUFBQyxHQUFHRixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUNHLE1BQU0sRUFBQyxHQUFHSCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUNJLElBQUksRUFBQyxHQUFHSixtQkFBT0EsQ0FBQztBQUV2QkssT0FBT0MsT0FBTyxHQUFHO0lBQ2JQO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9oZWxwZXJzL21ldGhvZHMvaW5kZXguanM/YTQ3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7Y29uY2F0fSA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XHJcbmNvbnN0IHtpbnNlcnR9ID0gcmVxdWlyZSgnLi9pbnNlcnQnKTtcclxuY29uc3Qge3VwZGF0ZX0gPSByZXF1aXJlKCcuL3VwZGF0ZScpO1xyXG5jb25zdCB7dmFsdWVzfSA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XHJcbmNvbnN0IHtzZXRzfSA9IHJlcXVpcmUoJy4vc2V0cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjb25jYXQsXHJcbiAgICBpbnNlcnQsXHJcbiAgICB1cGRhdGUsXHJcbiAgICB2YWx1ZXMsXHJcbiAgICBzZXRzXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJjb25jYXQiLCJyZXF1aXJlIiwiaW5zZXJ0IiwidXBkYXRlIiwidmFsdWVzIiwic2V0cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/insert.js":
/*!***************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/insert.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { TableName } = __webpack_require__(/*! ../table-name */ \"(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js\");\nconst { ColumnSet } = __webpack_require__(/*! ../column-set */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\");\nconst npm = {\n    formatting: __webpack_require__(/*! ../../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    utils: __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @method helpers.insert\r\n * @description\r\n * Generates an `INSERT` query for either one object or an array of objects.\r\n *\r\n * @param {object|object[]} data\r\n * An insert object with properties for insert values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an INSERT from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid insert object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be inserted.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when inserting multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an INSERT without any columns.`\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Destination table.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @returns {string}\r\n * An `INSERT` query string.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {val: 123, msg: 'hello'};\r\n * const dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];\r\n *\r\n * // Column details can be taken from the data object:\r\n *\r\n * pgp.helpers.insert(dataSingle, null, 'my-table');\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello')\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `INSERT`:\r\n *\r\n * pgp.helpers.insert(dataMulti, ['val', 'msg'], 'my-table');\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello'),(456,'world!')\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.insert(dataMulti, cs);\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello'),(456,'world!')\r\n *\r\n */ function insert(data, columns, table, capSQL) {\n    if (!data || typeof data !== \"object\") {\n        throw new TypeError(\"Invalid parameter 'data' specified.\");\n    }\n    const isArray = Array.isArray(data);\n    if (isArray && !data.length) {\n        throw new TypeError(\"Cannot generate an INSERT from an empty array.\");\n    }\n    if (columns instanceof ColumnSet) {\n        if (npm.utils.isNull(table)) {\n            table = columns.table;\n        }\n    } else {\n        if (isArray && npm.utils.isNull(columns)) {\n            throw new TypeError(\"Parameter 'columns' is required when inserting multiple records.\");\n        }\n        columns = new ColumnSet(columns || data);\n    }\n    if (!columns.columns.length) {\n        throw new Error(\"Cannot generate an INSERT without any columns.\");\n    }\n    if (!table) {\n        throw new Error(\"Table name is unknown.\");\n    }\n    if (!(table instanceof TableName)) {\n        table = new TableName(table);\n    }\n    let query = capSQL ? sql.capCase : sql.lowCase;\n    const fmOptions = {\n        capSQL\n    };\n    const format = npm.formatting.as.format;\n    query = format(query, [\n        table.name,\n        columns.names\n    ], fmOptions);\n    if (isArray) {\n        return query + data.map((d, index)=>{\n            if (!d || typeof d !== \"object\") {\n                throw new Error(`Invalid insert object at index ${index}.`);\n            }\n            return \"(\" + format(columns.variables, columns.prepare(d), fmOptions) + \")\";\n        }).join();\n    }\n    return query + \"(\" + format(columns.variables, columns.prepare(data), fmOptions) + \")\";\n}\nconst sql = {\n    lowCase: \"insert into $1^($2^) values\",\n    capCase: \"INSERT INTO $1^($2^) VALUES\"\n};\nmodule.exports = {\n    insert\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL2luc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxTQUFTLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFDQyxTQUFTLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFFNUIsTUFBTUUsTUFBTTtJQUNSQyxZQUFZSCxtQkFBT0EsQ0FBQztJQUNwQkksT0FBT0osbUJBQU9BLENBQUM7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0VDLEdBQ0QsU0FBU0ssT0FBT0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUV4QyxJQUFJLENBQUNILFFBQVEsT0FBT0EsU0FBUyxVQUFVO1FBQ25DLE1BQU0sSUFBSUksVUFBVTtJQUN4QjtJQUVBLE1BQU1DLFVBQVVDLE1BQU1ELE9BQU8sQ0FBQ0w7SUFFOUIsSUFBSUssV0FBVyxDQUFDTCxLQUFLTyxNQUFNLEVBQUU7UUFDekIsTUFBTSxJQUFJSCxVQUFVO0lBQ3hCO0lBRUEsSUFBSUgsbUJBQW1CTixXQUFXO1FBQzlCLElBQUlDLElBQUlFLEtBQUssQ0FBQ1UsTUFBTSxDQUFDTixRQUFRO1lBQ3pCQSxRQUFRRCxRQUFRQyxLQUFLO1FBQ3pCO0lBQ0osT0FBTztRQUNILElBQUlHLFdBQVdULElBQUlFLEtBQUssQ0FBQ1UsTUFBTSxDQUFDUCxVQUFVO1lBQ3RDLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBSCxVQUFVLElBQUlOLFVBQVVNLFdBQVdEO0lBQ3ZDO0lBRUEsSUFBSSxDQUFDQyxRQUFRQSxPQUFPLENBQUNNLE1BQU0sRUFBRTtRQUN6QixNQUFNLElBQUlFLE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUNQLE9BQU87UUFDUixNQUFNLElBQUlPLE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUVQLENBQUFBLGlCQUFpQlQsU0FBUSxHQUFJO1FBQy9CUyxRQUFRLElBQUlULFVBQVVTO0lBQzFCO0lBRUEsSUFBSVEsUUFBUVAsU0FBU1EsSUFBSUMsT0FBTyxHQUFHRCxJQUFJRSxPQUFPO0lBQzlDLE1BQU1DLFlBQVk7UUFBQ1g7SUFBTTtJQUV6QixNQUFNWSxTQUFTbkIsSUFBSUMsVUFBVSxDQUFDbUIsRUFBRSxDQUFDRCxNQUFNO0lBQ3ZDTCxRQUFRSyxPQUFPTCxPQUFPO1FBQUNSLE1BQU1lLElBQUk7UUFBRWhCLFFBQVFpQixLQUFLO0tBQUMsRUFBRUo7SUFFbkQsSUFBSVQsU0FBUztRQUNULE9BQU9LLFFBQVFWLEtBQUttQixHQUFHLENBQUMsQ0FBQ0MsR0FBR0M7WUFDeEIsSUFBSSxDQUFDRCxLQUFLLE9BQU9BLE1BQU0sVUFBVTtnQkFDN0IsTUFBTSxJQUFJWCxNQUFNLENBQUMsK0JBQStCLEVBQUVZLE1BQU0sQ0FBQyxDQUFDO1lBQzlEO1lBQ0EsT0FBTyxNQUFNTixPQUFPZCxRQUFRcUIsU0FBUyxFQUFFckIsUUFBUXNCLE9BQU8sQ0FBQ0gsSUFBSU4sYUFBYTtRQUM1RSxHQUFHVSxJQUFJO0lBQ1g7SUFDQSxPQUFPZCxRQUFRLE1BQU1LLE9BQU9kLFFBQVFxQixTQUFTLEVBQUVyQixRQUFRc0IsT0FBTyxDQUFDdkIsT0FBT2MsYUFBYTtBQUN2RjtBQUVBLE1BQU1ILE1BQU07SUFDUkUsU0FBUztJQUNURCxTQUFTO0FBQ2I7QUFFQWEsT0FBT0MsT0FBTyxHQUFHO0lBQUMzQjtBQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL2luc2VydC5qcz8yNTAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7VGFibGVOYW1lfSA9IHJlcXVpcmUoJy4uL3RhYmxlLW5hbWUnKTtcclxuY29uc3Qge0NvbHVtblNldH0gPSByZXF1aXJlKCcuLi9jb2x1bW4tc2V0Jyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuLi8uLi9mb3JtYXR0aW5nJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGVscGVycy5pbnNlcnRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEdlbmVyYXRlcyBhbiBgSU5TRVJUYCBxdWVyeSBmb3IgZWl0aGVyIG9uZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGFcclxuICogQW4gaW5zZXJ0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGluc2VydCB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN1Y2ggb2JqZWN0cy5cclxuICpcclxuICogV2hlbiBgZGF0YWAgaXMgbm90IGEgbm9uLW51bGwgb2JqZWN0IGFuZCBub3QgYW4gYXJyYXksIGl0IHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYEludmFsaWQgcGFyYW1ldGVyICdkYXRhJyBzcGVjaWZpZWQuYFxyXG4gKlxyXG4gKiBXaGVuIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheSwgaXQgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgQ2Fubm90IGdlbmVyYXRlIGFuIElOU0VSVCBmcm9tIGFuIGVtcHR5IGFycmF5LmBcclxuICpcclxuICogV2hlbiBgZGF0YWAgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhIG5vbi1vYmplY3QgdmFsdWUsIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID1cclxuICogYEludmFsaWQgaW5zZXJ0IG9iamVjdCBhdCBpbmRleCBOLmBcclxuICpcclxuICogQHBhcmFtIHthcnJheXxoZWxwZXJzLkNvbHVtbnxoZWxwZXJzLkNvbHVtblNldH0gW2NvbHVtbnNdXHJcbiAqIFNldCBvZiBjb2x1bW5zIHRvIGJlIGluc2VydGVkLlxyXG4gKlxyXG4gKiBJdCBpcyBvcHRpb25hbCB3aGVuIGBkYXRhYCBpcyBhIHNpbmdsZSBvYmplY3QsIGFuZCByZXF1aXJlZCB3aGVuIGBkYXRhYCBpcyBhbiBhcnJheSBvZiBvYmplY3RzLiBJZiBub3Qgc3BlY2lmaWVkIGZvciBhbiBhcnJheVxyXG4gKiBvZiBvYmplY3RzLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYFBhcmFtZXRlciAnY29sdW1ucycgaXMgcmVxdWlyZWQgd2hlbiBpbnNlcnRpbmcgbXVsdGlwbGUgcmVjb3Jkcy5gXHJcbiAqXHJcbiAqIFdoZW4gYGNvbHVtbnNgIGlzIG5vdCBhIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9IG9iamVjdCwgYSB0ZW1wb3Jhcnkge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH1cclxuICogaXMgY3JlYXRlZCAtIGZyb20gdGhlIHZhbHVlIG9mIGBjb2x1bW5zYCAoaWYgaXQgd2FzIHNwZWNpZmllZCksIG9yIGZyb20gdGhlIHZhbHVlIG9mIGBkYXRhYCAoaWYgaXQgaXMgbm90IGFuIGFycmF5KS5cclxuICpcclxuICogV2hlbiB0aGUgZmluYWwge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0gaXMgZW1wdHkgKG5vIGNvbHVtbnMgaW4gaXQpLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3dcclxuICoge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSA9IGBDYW5ub3QgZ2VuZXJhdGUgYW4gSU5TRVJUIHdpdGhvdXQgYW55IGNvbHVtbnMuYFxyXG4gKlxyXG4gKiBAcGFyYW0ge2hlbHBlcnMuVGFibGVOYW1lfHN0cmluZ3x7dGFibGUsc2NoZW1hfX0gW3RhYmxlXVxyXG4gKiBEZXN0aW5hdGlvbiB0YWJsZS5cclxuICpcclxuICogSXQgaXMgbm9ybWFsbHkgYSByZXF1aXJlZCBwYXJhbWV0ZXIuIEJ1dCB3aGVuIGBjb2x1bW5zYCBpcyBwYXNzZWQgaW4gYXMgYSB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBvYmplY3RcclxuICogd2l0aCBgdGFibGVgIHNldCBpbiBpdCwgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiB0aGlzIHBhcmFtZXRlciBpc24ndCBzcGVjaWZpZWQuIFdoZW4gbmVpdGhlciBpcyBhdmFpbGFibGUsIHRoZSBtZXRob2RcclxuICogd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID0gYFRhYmxlIG5hbWUgaXMgdW5rbm93bi5gXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEFuIGBJTlNFUlRgIHF1ZXJ5IHN0cmluZy5cclxuICpcclxuICogQHNlZVxyXG4gKiAge0BsaW5rIGhlbHBlcnMuQ29sdW1uIENvbHVtbn0sXHJcbiAqICB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSxcclxuICogIHtAbGluayBoZWxwZXJzLlRhYmxlTmFtZSBUYWJsZU5hbWV9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKSh7XHJcbiAqICAgIGNhcFNRTDogdHJ1ZSAvLyBpZiB5b3Ugd2FudCBhbGwgZ2VuZXJhdGVkIFNRTCBjYXBpdGFsaXplZFxyXG4gKiB9KTtcclxuICpcclxuICogY29uc3QgZGF0YVNpbmdsZSA9IHt2YWw6IDEyMywgbXNnOiAnaGVsbG8nfTtcclxuICogY29uc3QgZGF0YU11bHRpID0gW3t2YWw6IDEyMywgbXNnOiAnaGVsbG8nfSwge3ZhbDogNDU2LCBtc2c6ICd3b3JsZCEnfV07XHJcbiAqXHJcbiAqIC8vIENvbHVtbiBkZXRhaWxzIGNhbiBiZSB0YWtlbiBmcm9tIHRoZSBkYXRhIG9iamVjdDpcclxuICpcclxuICogcGdwLmhlbHBlcnMuaW5zZXJ0KGRhdGFTaW5nbGUsIG51bGwsICdteS10YWJsZScpO1xyXG4gKiAvLz0+IElOU0VSVCBJTlRPIFwibXktdGFibGVcIihcInZhbFwiLFwibXNnXCIpIFZBTFVFUygxMjMsJ2hlbGxvJylcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQ29sdW1uIGRldGFpbHMgYXJlIHJlcXVpcmVkIGZvciBhIG11bHRpLXJvdyBgSU5TRVJUYDpcclxuICpcclxuICogcGdwLmhlbHBlcnMuaW5zZXJ0KGRhdGFNdWx0aSwgWyd2YWwnLCAnbXNnJ10sICdteS10YWJsZScpO1xyXG4gKiAvLz0+IElOU0VSVCBJTlRPIFwibXktdGFibGVcIihcInZhbFwiLFwibXNnXCIpIFZBTFVFUygxMjMsJ2hlbGxvJyksKDQ1Niwnd29ybGQhJylcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQ29sdW1uIGRldGFpbHMgZnJvbSBhIHJldXNhYmxlIENvbHVtblNldCAocmVjb21tZW5kZWQgZm9yIHBlcmZvcm1hbmNlKTpcclxuICpcclxuICogY29uc3QgY3MgPSBuZXcgcGdwLmhlbHBlcnMuQ29sdW1uU2V0KFsndmFsJywgJ21zZyddLCB7dGFibGU6ICdteS10YWJsZSd9KTtcclxuICpcclxuICogcGdwLmhlbHBlcnMuaW5zZXJ0KGRhdGFNdWx0aSwgY3MpO1xyXG4gKiAvLz0+IElOU0VSVCBJTlRPIFwibXktdGFibGVcIihcInZhbFwiLFwibXNnXCIpIFZBTFVFUygxMjMsJ2hlbGxvJyksKDQ1Niwnd29ybGQhJylcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGluc2VydChkYXRhLCBjb2x1bW5zLCB0YWJsZSwgY2FwU1FMKSB7XHJcblxyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIFxcJ2RhdGFcXCcgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xyXG5cclxuICAgIGlmIChpc0FycmF5ICYmICFkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBhbiBJTlNFUlQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29sdW1ucyBpbnN0YW5jZW9mIENvbHVtblNldCkge1xyXG4gICAgICAgIGlmIChucG0udXRpbHMuaXNOdWxsKHRhYmxlKSkge1xyXG4gICAgICAgICAgICB0YWJsZSA9IGNvbHVtbnMudGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNBcnJheSAmJiBucG0udXRpbHMuaXNOdWxsKGNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdjb2x1bW5zXFwnIGlzIHJlcXVpcmVkIHdoZW4gaW5zZXJ0aW5nIG11bHRpcGxlIHJlY29yZHMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbHVtbnMgPSBuZXcgQ29sdW1uU2V0KGNvbHVtbnMgfHwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb2x1bW5zLmNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgYW4gSU5TRVJUIHdpdGhvdXQgYW55IGNvbHVtbnMuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0YWJsZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgbmFtZSBpcyB1bmtub3duLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKHRhYmxlIGluc3RhbmNlb2YgVGFibGVOYW1lKSkge1xyXG4gICAgICAgIHRhYmxlID0gbmV3IFRhYmxlTmFtZSh0YWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHF1ZXJ5ID0gY2FwU1FMID8gc3FsLmNhcENhc2UgOiBzcWwubG93Q2FzZTtcclxuICAgIGNvbnN0IGZtT3B0aW9ucyA9IHtjYXBTUUx9O1xyXG5cclxuICAgIGNvbnN0IGZvcm1hdCA9IG5wbS5mb3JtYXR0aW5nLmFzLmZvcm1hdDtcclxuICAgIHF1ZXJ5ID0gZm9ybWF0KHF1ZXJ5LCBbdGFibGUubmFtZSwgY29sdW1ucy5uYW1lc10sIGZtT3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gcXVlcnkgKyBkYXRhLm1hcCgoZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkIHx8IHR5cGVvZiBkICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluc2VydCBvYmplY3QgYXQgaW5kZXggJHtpbmRleH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcoJyArIGZvcm1hdChjb2x1bW5zLnZhcmlhYmxlcywgY29sdW1ucy5wcmVwYXJlKGQpLCBmbU9wdGlvbnMpICsgJyknO1xyXG4gICAgICAgIH0pLmpvaW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeSArICcoJyArIGZvcm1hdChjb2x1bW5zLnZhcmlhYmxlcywgY29sdW1ucy5wcmVwYXJlKGRhdGEpLCBmbU9wdGlvbnMpICsgJyknO1xyXG59XHJcblxyXG5jb25zdCBzcWwgPSB7XHJcbiAgICBsb3dDYXNlOiAnaW5zZXJ0IGludG8gJDFeKCQyXikgdmFsdWVzJyxcclxuICAgIGNhcENhc2U6ICdJTlNFUlQgSU5UTyAkMV4oJDJeKSBWQUxVRVMnXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtpbnNlcnR9O1xyXG4iXSwibmFtZXMiOlsiVGFibGVOYW1lIiwicmVxdWlyZSIsIkNvbHVtblNldCIsIm5wbSIsImZvcm1hdHRpbmciLCJ1dGlscyIsImluc2VydCIsImRhdGEiLCJjb2x1bW5zIiwidGFibGUiLCJjYXBTUUwiLCJUeXBlRXJyb3IiLCJpc0FycmF5IiwiQXJyYXkiLCJsZW5ndGgiLCJpc051bGwiLCJFcnJvciIsInF1ZXJ5Iiwic3FsIiwiY2FwQ2FzZSIsImxvd0Nhc2UiLCJmbU9wdGlvbnMiLCJmb3JtYXQiLCJhcyIsIm5hbWUiLCJuYW1lcyIsIm1hcCIsImQiLCJpbmRleCIsInZhcmlhYmxlcyIsInByZXBhcmUiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/insert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/sets.js":
/*!*************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/sets.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ColumnSet } = __webpack_require__(/*! ../column-set */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\");\nconst npm = {\n    format: (__webpack_require__(/*! ../../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\").as.format),\n    utils: __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @method helpers.sets\r\n * @description\r\n * Generates a string of comma-separated value-set statements from a single object: `col1=val1, col2=val2, ...`,\r\n * to be used as part of a query.\r\n *\r\n * Since it is to be used as part of `UPDATE` queries, {@link helpers.Column Column} properties `cnd` and `skip` apply.\r\n *\r\n * @param {object} data\r\n * A simple, non-null and non-array source object.\r\n *\r\n * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Columns for which to set values.\r\n *\r\n * When not specified, properties of the `data` object are used.\r\n *\r\n * When no effective columns are found, an empty string is returned.\r\n *\r\n * @returns {string}\r\n * - comma-separated value-set statements for the `data` object\r\n * - an empty string, if no effective columns found\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const data = {id: 1, val: 123, msg: 'hello'};\r\n *\r\n * // Properties can be pulled automatically from the object:\r\n *\r\n * pgp.helpers.sets(data);\r\n * //=> \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance);\r\n * // NOTE: Conditional columns (start with '?') are skipped:\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id','val', 'msg']);\r\n *\r\n * pgp.helpers.sets(data, cs);\r\n * //=> \"val\"=123,\"msg\"='hello'\r\n *\r\n */ function sets(data, columns, capSQL) {\n    if (!data || typeof data !== \"object\" || Array.isArray(data)) {\n        throw new TypeError(\"Invalid parameter 'data' specified.\");\n    }\n    if (!(columns instanceof ColumnSet)) {\n        columns = new ColumnSet(columns || data);\n    }\n    return npm.format(columns.assign({\n        source: data\n    }), columns.prepare(data), {\n        capSQL\n    });\n}\nmodule.exports = {\n    sets\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL3NldHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsU0FBUyxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1DLE1BQU07SUFDUkMsUUFBUUYsNEdBQXFDO0lBQzdDSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaURDLEdBQ0QsU0FBU0ssS0FBS0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE1BQU07SUFFL0IsSUFBSSxDQUFDRixRQUFRLE9BQU9BLFNBQVMsWUFBWUcsTUFBTUMsT0FBTyxDQUFDSixPQUFPO1FBQzFELE1BQU0sSUFBSUssVUFBVTtJQUN4QjtJQUVBLElBQUksQ0FBRUosQ0FBQUEsbUJBQW1CUixTQUFRLEdBQUk7UUFDakNRLFVBQVUsSUFBSVIsVUFBVVEsV0FBV0Q7SUFDdkM7SUFFQSxPQUFPTCxJQUFJQyxNQUFNLENBQUNLLFFBQVFLLE1BQU0sQ0FBQztRQUFDQyxRQUFRUDtJQUFJLElBQUlDLFFBQVFPLE9BQU8sQ0FBQ1IsT0FBTztRQUFDRTtJQUFNO0FBQ3BGO0FBRUFPLE9BQU9DLE9BQU8sR0FBRztJQUFDWDtBQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL3NldHMuanM/MGM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge0NvbHVtblNldH0gPSByZXF1aXJlKCcuLi9jb2x1bW4tc2V0Jyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICBmb3JtYXQ6IHJlcXVpcmUoJy4uLy4uL2Zvcm1hdHRpbmcnKS5hcy5mb3JtYXQsXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGVscGVycy5zZXRzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgb2YgY29tbWEtc2VwYXJhdGVkIHZhbHVlLXNldCBzdGF0ZW1lbnRzIGZyb20gYSBzaW5nbGUgb2JqZWN0OiBgY29sMT12YWwxLCBjb2wyPXZhbDIsIC4uLmAsXHJcbiAqIHRvIGJlIHVzZWQgYXMgcGFydCBvZiBhIHF1ZXJ5LlxyXG4gKlxyXG4gKiBTaW5jZSBpdCBpcyB0byBiZSB1c2VkIGFzIHBhcnQgb2YgYFVQREFURWAgcXVlcmllcywge0BsaW5rIGhlbHBlcnMuQ29sdW1uIENvbHVtbn0gcHJvcGVydGllcyBgY25kYCBhbmQgYHNraXBgIGFwcGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVxyXG4gKiBBIHNpbXBsZSwgbm9uLW51bGwgYW5kIG5vbi1hcnJheSBzb3VyY2Ugb2JqZWN0LlxyXG4gKlxyXG4gKiBJZiBpdCBpcyBhbnl0aGluZyBlbHNlLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYEludmFsaWQgcGFyYW1ldGVyICdkYXRhJyBzcGVjaWZpZWQuYFxyXG4gKlxyXG4gKiBAcGFyYW0ge2FycmF5fGhlbHBlcnMuQ29sdW1ufGhlbHBlcnMuQ29sdW1uU2V0fSBbY29sdW1uc11cclxuICogQ29sdW1ucyBmb3Igd2hpY2ggdG8gc2V0IHZhbHVlcy5cclxuICpcclxuICogV2hlbiBub3Qgc3BlY2lmaWVkLCBwcm9wZXJ0aWVzIG9mIHRoZSBgZGF0YWAgb2JqZWN0IGFyZSB1c2VkLlxyXG4gKlxyXG4gKiBXaGVuIG5vIGVmZmVjdGl2ZSBjb2x1bW5zIGFyZSBmb3VuZCwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiAtIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZS1zZXQgc3RhdGVtZW50cyBmb3IgdGhlIGBkYXRhYCBvYmplY3RcclxuICogLSBhbiBlbXB0eSBzdHJpbmcsIGlmIG5vIGVmZmVjdGl2ZSBjb2x1bW5zIGZvdW5kXHJcbiAqXHJcbiAqIEBzZWVcclxuICogIHtAbGluayBoZWxwZXJzLkNvbHVtbiBDb2x1bW59LFxyXG4gKiAge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH1cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgcGdwID0gcmVxdWlyZSgncGctcHJvbWlzZScpKCk7XHJcbiAqXHJcbiAqIGNvbnN0IGRhdGEgPSB7aWQ6IDEsIHZhbDogMTIzLCBtc2c6ICdoZWxsbyd9O1xyXG4gKlxyXG4gKiAvLyBQcm9wZXJ0aWVzIGNhbiBiZSBwdWxsZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBvYmplY3Q6XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnNldHMoZGF0YSk7XHJcbiAqIC8vPT4gXCJpZFwiPTEsXCJ2YWxcIj0xMjMsXCJtc2dcIj0naGVsbG8nXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIENvbHVtbiBkZXRhaWxzIGZyb20gYSByZXVzYWJsZSBDb2x1bW5TZXQgKHJlY29tbWVuZGVkIGZvciBwZXJmb3JtYW5jZSk7XHJcbiAqIC8vIE5PVEU6IENvbmRpdGlvbmFsIGNvbHVtbnMgKHN0YXJ0IHdpdGggJz8nKSBhcmUgc2tpcHBlZDpcclxuICpcclxuICogY29uc3QgY3MgPSBuZXcgcGdwLmhlbHBlcnMuQ29sdW1uU2V0KFsnP2lkJywndmFsJywgJ21zZyddKTtcclxuICpcclxuICogcGdwLmhlbHBlcnMuc2V0cyhkYXRhLCBjcyk7XHJcbiAqIC8vPT4gXCJ2YWxcIj0xMjMsXCJtc2dcIj0naGVsbG8nXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRzKGRhdGEsIGNvbHVtbnMsIGNhcFNRTCkge1xyXG5cclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIFxcJ2RhdGFcXCcgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGNvbHVtbnMgaW5zdGFuY2VvZiBDb2x1bW5TZXQpKSB7XHJcbiAgICAgICAgY29sdW1ucyA9IG5ldyBDb2x1bW5TZXQoY29sdW1ucyB8fCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnBtLmZvcm1hdChjb2x1bW5zLmFzc2lnbih7c291cmNlOiBkYXRhfSksIGNvbHVtbnMucHJlcGFyZShkYXRhKSwge2NhcFNRTH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtzZXRzfTtcclxuIl0sIm5hbWVzIjpbIkNvbHVtblNldCIsInJlcXVpcmUiLCJucG0iLCJmb3JtYXQiLCJhcyIsInV0aWxzIiwic2V0cyIsImRhdGEiLCJjb2x1bW5zIiwiY2FwU1FMIiwiQXJyYXkiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwiYXNzaWduIiwic291cmNlIiwicHJlcGFyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/sets.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/update.js":
/*!***************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/update.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { assert } = __webpack_require__(/*! ../../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst { TableName } = __webpack_require__(/*! ../table-name */ \"(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js\");\nconst { ColumnSet } = __webpack_require__(/*! ../column-set */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\");\nconst npm = {\n    formatting: __webpack_require__(/*! ../../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    utils: __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to specify the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {{}} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {*} [options.emptyUpdate]\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behavior when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {*}\r\n * An `UPDATE` query string that needs a `WHERE` condition appended.\r\n *\r\n * If it results in an empty update, and option `emptyUpdate` was passed in, then the method returns the value\r\n * to which the option was set.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * const dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * const dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * // Dynamic conditions must be escaped/formatted properly:\r\n * const condition = pgp.as.format(' WHERE id = ${id}', dataSingle);\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + condition;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * const result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */ function update(data, columns, table, options, capSQL) {\n    if (!data || typeof data !== \"object\") {\n        throw new TypeError(\"Invalid parameter 'data' specified.\");\n    }\n    const isArray = Array.isArray(data);\n    if (isArray && !data.length) {\n        throw new TypeError(\"Cannot generate an UPDATE from an empty array.\");\n    }\n    if (columns instanceof ColumnSet) {\n        if (npm.utils.isNull(table)) {\n            table = columns.table;\n        }\n    } else {\n        if (isArray && npm.utils.isNull(columns)) {\n            throw new TypeError(\"Parameter 'columns' is required when updating multiple records.\");\n        }\n        columns = new ColumnSet(columns || data);\n    }\n    options = assert(options, [\n        \"tableAlias\",\n        \"valueAlias\",\n        \"emptyUpdate\"\n    ]);\n    const format = npm.formatting.as.format, useEmptyUpdate = \"emptyUpdate\" in options, fmOptions = {\n        capSQL\n    };\n    if (isArray) {\n        const tableAlias = npm.formatting.as.alias(npm.utils.isNull(options.tableAlias) ? \"t\" : options.tableAlias);\n        const valueAlias = npm.formatting.as.alias(npm.utils.isNull(options.valueAlias) ? \"v\" : options.valueAlias);\n        const q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\n        const actualColumns = columns.columns.filter((c)=>!c.cnd);\n        if (checkColumns(actualColumns)) {\n            return options.emptyUpdate;\n        }\n        checkTable();\n        const targetCols = actualColumns.map((c)=>c.escapedName + \"=\" + valueAlias + \".\" + c.escapedName).join();\n        const values = data.map((d, index)=>{\n            if (!d || typeof d !== \"object\") {\n                throw new Error(`Invalid update object at index ${index}.`);\n            }\n            return \"(\" + format(columns.variables, columns.prepare(d), fmOptions) + \")\";\n        }).join();\n        return format(q, [\n            table.name,\n            tableAlias,\n            targetCols,\n            values,\n            valueAlias,\n            columns.names\n        ], fmOptions);\n    }\n    const updates = columns.assign({\n        source: data\n    });\n    if (checkColumns(updates)) {\n        return options.emptyUpdate;\n    }\n    checkTable();\n    const query = capSQL ? sql.single.capCase : sql.single.lowCase;\n    return format(query, table.name) + format(updates, columns.prepare(data), fmOptions);\n    function checkTable() {\n        if (table && !(table instanceof TableName)) {\n            table = new TableName(table);\n        }\n        if (!table) {\n            throw new Error(\"Table name is unknown.\");\n        }\n    }\n    function checkColumns(cols) {\n        if (!cols.length) {\n            if (useEmptyUpdate) {\n                return true;\n            }\n            throw new Error(\"Cannot generate an UPDATE without any columns.\");\n        }\n    }\n}\nconst sql = {\n    single: {\n        lowCase: \"update $1^ set \",\n        capCase: \"UPDATE $1^ SET \"\n    },\n    multi: {\n        lowCase: \"update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)\",\n        capCase: \"UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)\"\n    }\n};\nmodule.exports = {\n    update\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL3VwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxNQUFNLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFDQyxTQUFTLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFDRSxTQUFTLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFFNUIsTUFBTUcsTUFBTTtJQUNSQyxZQUFZSixtQkFBT0EsQ0FBQztJQUNwQkssT0FBT0wsbUJBQU9BLENBQUM7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnSUMsR0FDRCxTQUFTTSxPQUFPQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLE1BQU07SUFFakQsSUFBSSxDQUFDSixRQUFRLE9BQU9BLFNBQVMsVUFBVTtRQUNuQyxNQUFNLElBQUlLLFVBQVU7SUFDeEI7SUFFQSxNQUFNQyxVQUFVQyxNQUFNRCxPQUFPLENBQUNOO0lBRTlCLElBQUlNLFdBQVcsQ0FBQ04sS0FBS1EsTUFBTSxFQUFFO1FBQ3pCLE1BQU0sSUFBSUgsVUFBVTtJQUN4QjtJQUVBLElBQUlKLG1CQUFtQk4sV0FBVztRQUM5QixJQUFJQyxJQUFJRSxLQUFLLENBQUNXLE1BQU0sQ0FBQ1AsUUFBUTtZQUN6QkEsUUFBUUQsUUFBUUMsS0FBSztRQUN6QjtJQUNKLE9BQU87UUFDSCxJQUFJSSxXQUFXVixJQUFJRSxLQUFLLENBQUNXLE1BQU0sQ0FBQ1IsVUFBVTtZQUN0QyxNQUFNLElBQUlJLFVBQVU7UUFDeEI7UUFDQUosVUFBVSxJQUFJTixVQUFVTSxX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L3BnLXByb21pc2UvbGliL2hlbHBlcnMvbWV0aG9kcy91cGRhdGUuanM/MzY4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge2Fzc2VydH0gPSByZXF1aXJlKCcuLi8uLi9hc3NlcnQnKTtcclxuY29uc3Qge1RhYmxlTmFtZX0gPSByZXF1aXJlKCcuLi90YWJsZS1uYW1lJyk7XHJcbmNvbnN0IHtDb2x1bW5TZXR9ID0gcmVxdWlyZSgnLi4vY29sdW1uLXNldCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgZm9ybWF0dGluZzogcmVxdWlyZSgnLi4vLi4vZm9ybWF0dGluZycpLFxyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhlbHBlcnMudXBkYXRlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBHZW5lcmF0ZXMgYSBzaW1wbGlmaWVkIGBVUERBVEVgIHF1ZXJ5IGZvciBlaXRoZXIgb25lIG9iamVjdCBvciBhbiBhcnJheSBvZiBvYmplY3RzLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0aW5nIHF1ZXJ5IG5lZWRzIGEgYFdIRVJFYCBjbGF1c2UgdG8gYmUgYXBwZW5kZWQgdG8gaXQsIHRvIHNwZWNpZnkgdGhlIHVwZGF0ZSBsb2dpYy5cclxuICogVGhpcyBpcyB0byBhbGxvdyBmb3IgdXBkYXRlIGNvbmRpdGlvbnMgb2YgYW55IGNvbXBsZXhpdHkgdGhhdCBhcmUgZWFzeSB0byBhZGQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBkYXRhXHJcbiAqIEFuIHVwZGF0ZSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZvciB1cGRhdGUgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdWNoIG9iamVjdHMuXHJcbiAqXHJcbiAqIFdoZW4gYGRhdGFgIGlzIG5vdCBhIG5vbi1udWxsIG9iamVjdCBhbmQgbm90IGFuIGFycmF5LCBpdCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBJbnZhbGlkIHBhcmFtZXRlciAnZGF0YScgc3BlY2lmaWVkLmBcclxuICpcclxuICogV2hlbiBgZGF0YWAgaXMgYW4gZW1wdHkgYXJyYXksIGl0IHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYENhbm5vdCBnZW5lcmF0ZSBhbiBVUERBVEUgZnJvbSBhbiBlbXB0eSBhcnJheS5gXHJcbiAqXHJcbiAqIFdoZW4gYGRhdGFgIGlzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYSBub24tb2JqZWN0IHZhbHVlLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSA9XHJcbiAqIGBJbnZhbGlkIHVwZGF0ZSBvYmplY3QgYXQgaW5kZXggTi5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7YXJyYXl8aGVscGVycy5Db2x1bW58aGVscGVycy5Db2x1bW5TZXR9IFtjb2x1bW5zXVxyXG4gKiBTZXQgb2YgY29sdW1ucyB0byBiZSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBJdCBpcyBvcHRpb25hbCB3aGVuIGBkYXRhYCBpcyBhIHNpbmdsZSBvYmplY3QsIGFuZCByZXF1aXJlZCB3aGVuIGBkYXRhYCBpcyBhbiBhcnJheSBvZiBvYmplY3RzLiBJZiBub3Qgc3BlY2lmaWVkIGZvciBhbiBhcnJheVxyXG4gKiBvZiBvYmplY3RzLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYFBhcmFtZXRlciAnY29sdW1ucycgaXMgcmVxdWlyZWQgd2hlbiB1cGRhdGluZyBtdWx0aXBsZSByZWNvcmRzLmBcclxuICpcclxuICogV2hlbiBgY29sdW1uc2AgaXMgbm90IGEge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0gb2JqZWN0LCBhIHRlbXBvcmFyeSB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fVxyXG4gKiBpcyBjcmVhdGVkIC0gZnJvbSB0aGUgdmFsdWUgb2YgYGNvbHVtbnNgIChpZiBpdCB3YXMgc3BlY2lmaWVkKSwgb3IgZnJvbSB0aGUgdmFsdWUgb2YgYGRhdGFgIChpZiBpdCBpcyBub3QgYW4gYXJyYXkpLlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBmaW5hbCB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBpcyBlbXB0eSAobm8gY29sdW1ucyBpbiBpdCksIHRoZSBtZXRob2Qgd2lsbCB0aHJvd1xyXG4gKiB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID0gYENhbm5vdCBnZW5lcmF0ZSBhbiBVUERBVEUgd2l0aG91dCBhbnkgY29sdW1ucy5gLCB1bmxlc3Mgb3B0aW9uIGBlbXB0eVVwZGF0ZWAgd2FzIHNwZWNpZmllZC5cclxuICpcclxuICogQHBhcmFtIHtoZWxwZXJzLlRhYmxlTmFtZXxzdHJpbmd8e3RhYmxlLHNjaGVtYX19IFt0YWJsZV1cclxuICogVGFibGUgdG8gYmUgdXBkYXRlZC5cclxuICpcclxuICogSXQgaXMgbm9ybWFsbHkgYSByZXF1aXJlZCBwYXJhbWV0ZXIuIEJ1dCB3aGVuIGBjb2x1bW5zYCBpcyBwYXNzZWQgaW4gYXMgYSB7QGxpbmsgaGVscGVycy5Db2x1bW5TZXQgQ29sdW1uU2V0fSBvYmplY3RcclxuICogd2l0aCBgdGFibGVgIHNldCBpbiBpdCwgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiB0aGlzIHBhcmFtZXRlciBpc24ndCBzcGVjaWZpZWQuIFdoZW4gbmVpdGhlciBpcyBhdmFpbGFibGUsIHRoZSBtZXRob2RcclxuICogd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID0gYFRhYmxlIG5hbWUgaXMgdW5rbm93bi5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7e319IFtvcHRpb25zXVxyXG4gKiBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIG11bHRpLXJvdyBgVVBEQVRFYCBxdWVyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFibGVBbGlhcz10XVxyXG4gKiBOYW1lIG9mIHRoZSBTUUwgdmFyaWFibGUgdGhhdCByZXByZXNlbnRzIHRoZSBkZXN0aW5hdGlvbiB0YWJsZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhbHVlQWxpYXM9dl1cclxuICogTmFtZSBvZiB0aGUgU1FMIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyB0aGUgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IFtvcHRpb25zLmVtcHR5VXBkYXRlXVxyXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2Ugb3B0aW9uLCB0byBhdm9pZCB0aHJvd2luZyBhbiBlcnJvciB3aGVuIGdlbmVyYXRpbmcgYSBjb25kaXRpb25hbCB1cGRhdGUgcmVzdWx0cyBpbiBubyBjb2x1bW5zLlxyXG4gKlxyXG4gKiBXaGVuIHByZXNlbnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlLCB0aGlzIG9wdGlvbiBvdmVycmlkZXMgdGhlIG1ldGhvZCdzIGJlaGF2aW9yIHdoZW4gYXBwbHlpbmcgYHNraXBgIGxvZ2ljIHJlc3VsdHMgaW4gbm8gY29sdW1ucyxcclxuICogaS5lLiB3aGVuIGV2ZXJ5IGNvbHVtbiBpcyBiZWluZyBza2lwcGVkLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBpbiB0aGF0IHNpdHVhdGlvbiB0aGUgbWV0aG9kIHRocm93cyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID0gYENhbm5vdCBnZW5lcmF0ZSBhbiBVUERBVEUgd2l0aG91dCBhbnkgY29sdW1ucy5gXHJcbiAqIEJ1dCB3aGVuIHRoaXMgb3B0aW9uIGlzIHByZXNlbnQsIHRoZSBtZXRob2Qgd2lsbCBpbnN0ZWFkIHJldHVybiB3aGF0ZXZlciB2YWx1ZSB0aGUgb3B0aW9uIHdhcyBwYXNzZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKiBBbiBgVVBEQVRFYCBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyBhIGBXSEVSRWAgY29uZGl0aW9uIGFwcGVuZGVkLlxyXG4gKlxyXG4gKiBJZiBpdCByZXN1bHRzIGluIGFuIGVtcHR5IHVwZGF0ZSwgYW5kIG9wdGlvbiBgZW1wdHlVcGRhdGVgIHdhcyBwYXNzZWQgaW4sIHRoZW4gdGhlIG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZVxyXG4gKiB0byB3aGljaCB0aGUgb3B0aW9uIHdhcyBzZXQuXHJcbiAqXHJcbiAqIEBzZWVcclxuICogIHtAbGluayBoZWxwZXJzLkNvbHVtbiBDb2x1bW59LFxyXG4gKiAge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0sXHJcbiAqICB7QGxpbmsgaGVscGVycy5UYWJsZU5hbWUgVGFibGVOYW1lfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBjb25zdCBwZ3AgPSByZXF1aXJlKCdwZy1wcm9taXNlJykoe1xyXG4gKiAgICBjYXBTUUw6IHRydWUgLy8gaWYgeW91IHdhbnQgYWxsIGdlbmVyYXRlZCBTUUwgY2FwaXRhbGl6ZWRcclxuICogfSk7XHJcbiAqXHJcbiAqIGNvbnN0IGRhdGFTaW5nbGUgPSB7aWQ6IDEsIHZhbDogMTIzLCBtc2c6ICdoZWxsbyd9O1xyXG4gKiBjb25zdCBkYXRhTXVsdGkgPSBbe2lkOiAxLCB2YWw6IDEyMywgbXNnOiAnaGVsbG8nfSwge2lkOiAyLCB2YWw6IDQ1NiwgbXNnOiAnd29ybGQhJ31dO1xyXG4gKlxyXG4gKiAvLyBBbHRob3VnaCBjb2x1bW4gZGV0YWlscyBjYW4gYmUgdGFrZW4gZnJvbSB0aGUgZGF0YSBvYmplY3QsIGl0IGlzIG5vdFxyXG4gKiAvLyBhIGxpa2VseSBzY2VuYXJpbyBmb3IgYW4gdXBkYXRlLCB1bmxlc3MgdXBkYXRpbmcgdGhlIHdob2xlIHRhYmxlOlxyXG4gKlxyXG4gKiBwZ3AuaGVscGVycy51cGRhdGUoZGF0YVNpbmdsZSwgbnVsbCwgJ215LXRhYmxlJyk7XHJcbiAqIC8vPT4gVVBEQVRFIFwibXktdGFibGVcIiBTRVQgXCJpZFwiPTEsXCJ2YWxcIj0xMjMsXCJtc2dcIj0naGVsbG8nXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEEgdHlwaWNhbCBzaW5nbGUtb2JqZWN0IHVwZGF0ZTpcclxuICpcclxuICogLy8gRHluYW1pYyBjb25kaXRpb25zIG11c3QgYmUgZXNjYXBlZC9mb3JtYXR0ZWQgcHJvcGVybHk6XHJcbiAqIGNvbnN0IGNvbmRpdGlvbiA9IHBncC5hcy5mb3JtYXQoJyBXSEVSRSBpZCA9ICR7aWR9JywgZGF0YVNpbmdsZSk7XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnVwZGF0ZShkYXRhU2luZ2xlLCBbJ3ZhbCcsICdtc2cnXSwgJ215LXRhYmxlJykgKyBjb25kaXRpb247XHJcbiAqIC8vPT4gVVBEQVRFIFwibXktdGFibGVcIiBTRVQgXCJ2YWxcIj0xMjMsXCJtc2dcIj0naGVsbG8nIFdIRVJFIGlkID0gMVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBDb2x1bW4gZGV0YWlscyBhcmUgcmVxdWlyZWQgZm9yIGEgbXVsdGktcm93IGBVUERBVEVgO1xyXG4gKiAvLyBBZGRpbmcgJz8nIGluIGZyb250IG9mIGEgY29sdW1uIG5hbWUgbWVhbnMgaXQgaXMgb25seSBmb3IgYSBXSEVSRSBjb25kaXRpb246XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnVwZGF0ZShkYXRhTXVsdGksIFsnP2lkJywgJ3ZhbCcsICdtc2cnXSwgJ215LXRhYmxlJykgKyAnIFdIRVJFIHYuaWQgPSB0LmlkJztcclxuICogLy89PiBVUERBVEUgXCJteS10YWJsZVwiIEFTIHQgU0VUIFwidmFsXCI9di5cInZhbFwiLFwibXNnXCI9di5cIm1zZ1wiIEZST00gKFZBTFVFUygxLDEyMywnaGVsbG8nKSwoMiw0NTYsJ3dvcmxkIScpKVxyXG4gKiAvLyAgIEFTIHYoXCJpZFwiLFwidmFsXCIsXCJtc2dcIikgV0hFUkUgdi5pZCA9IHQuaWRcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQ29sdW1uIGRldGFpbHMgZnJvbSBhIHJldXNhYmxlIENvbHVtblNldCAocmVjb21tZW5kZWQgZm9yIHBlcmZvcm1hbmNlKTpcclxuICpcclxuICogY29uc3QgY3MgPSBuZXcgcGdwLmhlbHBlcnMuQ29sdW1uU2V0KFsnP2lkJywgJ3ZhbCcsICdtc2cnXSwge3RhYmxlOiAnbXktdGFibGUnfSk7XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnVwZGF0ZShkYXRhTXVsdGksIGNzKSArICcgV0hFUkUgdi5pZCA9IHQuaWQnO1xyXG4gKiAvLz0+IFVQREFURSBcIm15LXRhYmxlXCIgQVMgdCBTRVQgXCJ2YWxcIj12LlwidmFsXCIsXCJtc2dcIj12LlwibXNnXCIgRlJPTSAoVkFMVUVTKDEsMTIzLCdoZWxsbycpLCgyLDQ1Niwnd29ybGQhJykpXHJcbiAqIC8vICAgQVMgdihcImlkXCIsXCJ2YWxcIixcIm1zZ1wiKSBXSEVSRSB2LmlkID0gdC5pZFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBVc2luZyBwYXJhbWV0ZXIgYG9wdGlvbnNgIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBhbGlhcyBuYW1lczpcclxuICpcclxuICogcGdwLmhlbHBlcnMudXBkYXRlKGRhdGFNdWx0aSwgY3MsIG51bGwsIHt0YWJsZUFsaWFzOiAnWCcsIHZhbHVlQWxpYXM6ICdZJ30pICsgJyBXSEVSRSBZLmlkID0gWC5pZCc7XHJcbiAqIC8vPT4gVVBEQVRFIFwibXktdGFibGVcIiBBUyBYIFNFVCBcInZhbFwiPVkuXCJ2YWxcIixcIm1zZ1wiPVkuXCJtc2dcIiBGUk9NIChWQUxVRVMoMSwxMjMsJ2hlbGxvJyksKDIsNDU2LCd3b3JsZCEnKSlcclxuICogLy8gICBBUyBZKFwiaWRcIixcInZhbFwiLFwibXNnXCIpIFdIRVJFIFkuaWQgPSBYLmlkXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEhhbmRsaW5nIGFuIGVtcHR5IHVwZGF0ZVxyXG4gKlxyXG4gKiBjb25zdCBjcyA9IG5ldyBwZ3AuaGVscGVycy5Db2x1bW5TZXQoWyc/aWQnLCAnP25hbWUnXSwge3RhYmxlOiAndHQnfSk7IC8vIG5vIGFjdHVhbCB1cGRhdGUtYWJsZSBjb2x1bW5zXHJcbiAqIGNvbnN0IHJlc3VsdCA9IHBncC5oZWxwZXJzLnVwZGF0ZShkYXRhTXVsdGksIGNzLCBudWxsLCB7ZW1wdHlVcGRhdGU6IDEyM30pO1xyXG4gKiBpZihyZXN1bHQgPT09IDEyMykge1xyXG4gKiAgICAvLyBXZSBrbm93IHRoZSB1cGRhdGUgaXMgZW1wdHksIGkuZS4gbm8gY29sdW1ucyB0aGF0IGNhbiBiZSB1cGRhdGVkO1xyXG4gKiAgICAvLyBBbmQgaXQgZGlkbid0IHRocm93IGJlY2F1c2Ugd2Ugc3BlY2lmaWVkIGBlbXB0eVVwZGF0ZWAgb3B0aW9uLlxyXG4gKiB9XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGUoZGF0YSwgY29sdW1ucywgdGFibGUsIG9wdGlvbnMsIGNhcFNRTCkge1xyXG5cclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciBcXCdkYXRhXFwnIHNwZWNpZmllZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcclxuXHJcbiAgICBpZiAoaXNBcnJheSAmJiAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgYW4gVVBEQVRFIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbHVtbnMgaW5zdGFuY2VvZiBDb2x1bW5TZXQpIHtcclxuICAgICAgICBpZiAobnBtLnV0aWxzLmlzTnVsbCh0YWJsZSkpIHtcclxuICAgICAgICAgICAgdGFibGUgPSBjb2x1bW5zLnRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkgJiYgbnBtLnV0aWxzLmlzTnVsbChjb2x1bW5zKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgXFwnY29sdW1uc1xcJyBpcyByZXF1aXJlZCB3aGVuIHVwZGF0aW5nIG11bHRpcGxlIHJlY29yZHMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbHVtbnMgPSBuZXcgQ29sdW1uU2V0KGNvbHVtbnMgfHwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyA9IGFzc2VydChvcHRpb25zLCBbJ3RhYmxlQWxpYXMnLCAndmFsdWVBbGlhcycsICdlbXB0eVVwZGF0ZSddKTtcclxuXHJcbiAgICBjb25zdCBmb3JtYXQgPSBucG0uZm9ybWF0dGluZy5hcy5mb3JtYXQsXHJcbiAgICAgICAgdXNlRW1wdHlVcGRhdGUgPSAnZW1wdHlVcGRhdGUnIGluIG9wdGlvbnMsXHJcbiAgICAgICAgZm1PcHRpb25zID0ge2NhcFNRTH07XHJcblxyXG4gICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICBjb25zdCB0YWJsZUFsaWFzID0gbnBtLmZvcm1hdHRpbmcuYXMuYWxpYXMobnBtLnV0aWxzLmlzTnVsbChvcHRpb25zLnRhYmxlQWxpYXMpID8gJ3QnIDogb3B0aW9ucy50YWJsZUFsaWFzKTtcclxuICAgICAgICBjb25zdCB2YWx1ZUFsaWFzID0gbnBtLmZvcm1hdHRpbmcuYXMuYWxpYXMobnBtLnV0aWxzLmlzTnVsbChvcHRpb25zLnZhbHVlQWxpYXMpID8gJ3YnIDogb3B0aW9ucy52YWx1ZUFsaWFzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcSA9IGNhcFNRTCA/IHNxbC5tdWx0aS5jYXBDYXNlIDogc3FsLm11bHRpLmxvd0Nhc2U7XHJcblxyXG4gICAgICAgIGNvbnN0IGFjdHVhbENvbHVtbnMgPSBjb2x1bW5zLmNvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY25kKTtcclxuXHJcbiAgICAgICAgaWYgKGNoZWNrQ29sdW1ucyhhY3R1YWxDb2x1bW5zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbXB0eVVwZGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoZWNrVGFibGUoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q29scyA9IGFjdHVhbENvbHVtbnMubWFwKGMgPT4gYy5lc2NhcGVkTmFtZSArICc9JyArIHZhbHVlQWxpYXMgKyAnLicgKyBjLmVzY2FwZWROYW1lKS5qb2luKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEubWFwKChkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWQgfHwgdHlwZW9mIGQgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdXBkYXRlIG9iamVjdCBhdCBpbmRleCAke2luZGV4fS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJygnICsgZm9ybWF0KGNvbHVtbnMudmFyaWFibGVzLCBjb2x1bW5zLnByZXBhcmUoZCksIGZtT3B0aW9ucykgKyAnKSc7XHJcbiAgICAgICAgfSkuam9pbigpO1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0KHEsIFt0YWJsZS5uYW1lLCB0YWJsZUFsaWFzLCB0YXJnZXRDb2xzLCB2YWx1ZXMsIHZhbHVlQWxpYXMsIGNvbHVtbnMubmFtZXNdLCBmbU9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZXMgPSBjb2x1bW5zLmFzc2lnbih7c291cmNlOiBkYXRhfSk7XHJcblxyXG4gICAgaWYgKGNoZWNrQ29sdW1ucyh1cGRhdGVzKSkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmVtcHR5VXBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrVGFibGUoKTtcclxuXHJcbiAgICBjb25zdCBxdWVyeSA9IGNhcFNRTCA/IHNxbC5zaW5nbGUuY2FwQ2FzZSA6IHNxbC5zaW5nbGUubG93Q2FzZTtcclxuXHJcbiAgICByZXR1cm4gZm9ybWF0KHF1ZXJ5LCB0YWJsZS5uYW1lKSArIGZvcm1hdCh1cGRhdGVzLCBjb2x1bW5zLnByZXBhcmUoZGF0YSksIGZtT3B0aW9ucyk7XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tUYWJsZSgpIHtcclxuICAgICAgICBpZiAodGFibGUgJiYgISh0YWJsZSBpbnN0YW5jZW9mIFRhYmxlTmFtZSkpIHtcclxuICAgICAgICAgICAgdGFibGUgPSBuZXcgVGFibGVOYW1lKHRhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YWJsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIG5hbWUgaXMgdW5rbm93bi4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2x1bW5zKGNvbHMpIHtcclxuICAgICAgICBpZiAoIWNvbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VFbXB0eVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgYW4gVVBEQVRFIHdpdGhvdXQgYW55IGNvbHVtbnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBzcWwgPSB7XHJcbiAgICBzaW5nbGU6IHtcclxuICAgICAgICBsb3dDYXNlOiAndXBkYXRlICQxXiBzZXQgJyxcclxuICAgICAgICBjYXBDYXNlOiAnVVBEQVRFICQxXiBTRVQgJ1xyXG4gICAgfSxcclxuICAgIG11bHRpOiB7XHJcbiAgICAgICAgbG93Q2FzZTogJ3VwZGF0ZSAkMV4gYXMgJDJeIHNldCAkM14gZnJvbSAodmFsdWVzJDReKSBhcyAkNV4oJDZeKScsXHJcbiAgICAgICAgY2FwQ2FzZTogJ1VQREFURSAkMV4gQVMgJDJeIFNFVCAkM14gRlJPTSAoVkFMVUVTJDReKSBBUyAkNV4oJDZeKSdcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge3VwZGF0ZX07XHJcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiVGFibGVOYW1lIiwiQ29sdW1uU2V0IiwibnBtIiwiZm9ybWF0dGluZyIsInV0aWxzIiwidXBkYXRlIiwiZGF0YSIsImNvbHVtbnMiLCJ0YWJsZSIsIm9wdGlvbnMiLCJjYXBTUUwiLCJUeXBlRXJyb3IiLCJpc0FycmF5IiwiQXJyYXkiLCJsZW5ndGgiLCJpc051bGwiLCJmb3JtYXQiLCJhcyIsInVzZUVtcHR5VXBkYXRlIiwiZm1PcHRpb25zIiwidGFibGVBbGlhcyIsImFsaWFzIiwidmFsdWVBbGlhcyIsInEiLCJzcWwiLCJtdWx0aSIsImNhcENhc2UiLCJsb3dDYXNlIiwiYWN0dWFsQ29sdW1ucyIsImZpbHRlciIsImMiLCJjbmQiLCJjaGVja0NvbHVtbnMiLCJlbXB0eVVwZGF0ZSIsImNoZWNrVGFibGUiLCJ0YXJnZXRDb2xzIiwibWFwIiwiZXNjYXBlZE5hbWUiLCJqb2luIiwidmFsdWVzIiwiZCIsImluZGV4IiwiRXJyb3IiLCJ2YXJpYWJsZXMiLCJwcmVwYXJlIiwibmFtZSIsIm5hbWVzIiwidXBkYXRlcyIsImFzc2lnbiIsInNvdXJjZSIsInF1ZXJ5Iiwic2luZ2xlIiwiY29scyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/update.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/methods/values.js":
/*!***************************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/methods/values.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ColumnSet } = __webpack_require__(/*! ../column-set */ \"(rsc)/./node_modules/pg-promise/lib/helpers/column-set.js\");\nconst npm = {\n    formatting: __webpack_require__(/*! ../../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    utils: __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @method helpers.values\r\n * @description\r\n * Generates a string of comma-separated value groups from either one object or an array of objects,\r\n * to be used as part of a query:\r\n *\r\n * - from a single object: `(val_1, val_2, ...)`\r\n * - from an array of objects: `(val_11, val_12, ...), (val_21, val_22, ...)`\r\n *\r\n * @param {object|object[]} data\r\n * A source object with properties as values, or an array of such objects.\r\n *\r\n * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid object at index N.`\r\n *\r\n * When `data` is an empty array, an empty string is returned.\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Columns for which to return values.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when generating multi-row values.`\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate values without any columns.`\r\n *\r\n * @returns {string}\r\n * - comma-separated value groups, according to `data`\r\n * - an empty string, if `data` is an empty array\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet}\r\n *\r\n * @example\r\n *\r\n * const pgp = require('pg-promise')();\r\n *\r\n * const dataSingle = {val: 123, msg: 'hello'};\r\n * const dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];\r\n *\r\n * // Properties can be pulled automatically from a single object:\r\n *\r\n * pgp.helpers.values(dataSingle);\r\n * //=> (123,'hello')\r\n *\r\n * @example\r\n *\r\n * // Column details are required when using an array of objects:\r\n *\r\n * pgp.helpers.values(dataMulti, ['val', 'msg']);\r\n * //=> (123,'hello'),(456,'world!')\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * const cs = new pgp.helpers.ColumnSet(['val', 'msg']);\r\n *\r\n * pgp.helpers.values(dataMulti, cs);\r\n * //=> (123,'hello'),(456,'world!')\r\n *\r\n */ function values(data, columns, capSQL) {\n    if (!data || typeof data !== \"object\") {\n        throw new TypeError(\"Invalid parameter 'data' specified.\");\n    }\n    const isArray = Array.isArray(data);\n    if (!(columns instanceof ColumnSet)) {\n        if (isArray && npm.utils.isNull(columns)) {\n            throw new TypeError(\"Parameter 'columns' is required when generating multi-row values.\");\n        }\n        columns = new ColumnSet(columns || data);\n    }\n    if (!columns.columns.length) {\n        throw new Error(\"Cannot generate values without any columns.\");\n    }\n    const format = npm.formatting.as.format, fmOptions = {\n        capSQL\n    };\n    if (isArray) {\n        return data.map((d, index)=>{\n            if (!d || typeof d !== \"object\") {\n                throw new Error(`Invalid object at index ${index}.`);\n            }\n            return \"(\" + format(columns.variables, columns.prepare(d), fmOptions) + \")\";\n        }).join();\n    }\n    return \"(\" + format(columns.variables, columns.prepare(data), fmOptions) + \")\";\n}\nmodule.exports = {\n    values\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy9tZXRob2RzL3ZhbHVlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxTQUFTLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFNUIsTUFBTUMsTUFBTTtJQUNSQyxZQUFZRixtQkFBT0EsQ0FBQztJQUNwQkcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdFQyxHQUNELFNBQVNJLE9BQU9DLElBQUksRUFBRUMsT0FBTyxFQUFFQyxNQUFNO0lBRWpDLElBQUksQ0FBQ0YsUUFBUSxPQUFPQSxTQUFTLFVBQVU7UUFDbkMsTUFBTSxJQUFJRyxVQUFVO0lBQ3hCO0lBRUEsTUFBTUMsVUFBVUMsTUFBTUQsT0FBTyxDQUFDSjtJQUU5QixJQUFJLENBQUVDLENBQUFBLG1CQUFtQlAsU0FBUSxHQUFJO1FBQ2pDLElBQUlVLFdBQVdSLElBQUlFLEtBQUssQ0FBQ1EsTUFBTSxDQUFDTCxVQUFVO1lBQ3RDLE1BQU0sSUFBSUUsVUFBVTtRQUN4QjtRQUNBRixVQUFVLElBQUlQLFVBQVVPLFdBQVdEO0lBQ3ZDO0lBRUEsSUFBSSxDQUFDQyxRQUFRQSxPQUFPLENBQUNNLE1BQU0sRUFBRTtRQUN6QixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFFQSxNQUFNQyxTQUFTYixJQUFJQyxVQUFVLENBQUNhLEVBQUUsQ0FBQ0QsTUFBTSxFQUNuQ0UsWUFBWTtRQUFDVDtJQUFNO0lBRXZCLElBQUlFLFNBQVM7UUFDVCxPQUFPSixLQUFLWSxHQUFHLENBQUMsQ0FBQ0MsR0FBR0M7WUFDaEIsSUFBSSxDQUFDRCxLQUFLLE9BQU9BLE1BQU0sVUFBVTtnQkFDN0IsTUFBTSxJQUFJTCxNQUFNLENBQUMsd0JBQXdCLEVBQUVNLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZEO1lBQ0EsT0FBTyxNQUFNTCxPQUFPUixRQUFRYyxTQUFTLEVBQUVkLFFBQVFlLE9BQU8sQ0FBQ0gsSUFBSUYsYUFBYTtRQUM1RSxHQUFHTSxJQUFJO0lBQ1g7SUFDQSxPQUFPLE1BQU1SLE9BQU9SLFFBQVFjLFNBQVMsRUFBRWQsUUFBUWUsT0FBTyxDQUFDaEIsT0FBT1csYUFBYTtBQUMvRTtBQUVBTyxPQUFPQyxPQUFPLEdBQUc7SUFBQ3BCO0FBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9oZWxwZXJzL21ldGhvZHMvdmFsdWVzLmpzP2I0M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtDb2x1bW5TZXR9ID0gcmVxdWlyZSgnLi4vY29sdW1uLXNldCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgZm9ybWF0dGluZzogcmVxdWlyZSgnLi4vLi4vZm9ybWF0dGluZycpLFxyXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhlbHBlcnMudmFsdWVzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgb2YgY29tbWEtc2VwYXJhdGVkIHZhbHVlIGdyb3VwcyBmcm9tIGVpdGhlciBvbmUgb2JqZWN0IG9yIGFuIGFycmF5IG9mIG9iamVjdHMsXHJcbiAqIHRvIGJlIHVzZWQgYXMgcGFydCBvZiBhIHF1ZXJ5OlxyXG4gKlxyXG4gKiAtIGZyb20gYSBzaW5nbGUgb2JqZWN0OiBgKHZhbF8xLCB2YWxfMiwgLi4uKWBcclxuICogLSBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHM6IGAodmFsXzExLCB2YWxfMTIsIC4uLiksICh2YWxfMjEsIHZhbF8yMiwgLi4uKWBcclxuICpcclxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGFcclxuICogQSBzb3VyY2Ugb2JqZWN0IHdpdGggcHJvcGVydGllcyBhcyB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN1Y2ggb2JqZWN0cy5cclxuICpcclxuICogSWYgaXQgaXMgYW55dGhpbmcgZWxzZSwgdGhlIG1ldGhvZCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBJbnZhbGlkIHBhcmFtZXRlciAnZGF0YScgc3BlY2lmaWVkLmBcclxuICpcclxuICogV2hlbiBgZGF0YWAgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhIG5vbi1vYmplY3QgdmFsdWUsIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6RXJyb3IgRXJyb3J9ID1cclxuICogYEludmFsaWQgb2JqZWN0IGF0IGluZGV4IE4uYFxyXG4gKlxyXG4gKiBXaGVuIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheSwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FycmF5fGhlbHBlcnMuQ29sdW1ufGhlbHBlcnMuQ29sdW1uU2V0fSBbY29sdW1uc11cclxuICogQ29sdW1ucyBmb3Igd2hpY2ggdG8gcmV0dXJuIHZhbHVlcy5cclxuICpcclxuICogSXQgaXMgb3B0aW9uYWwgd2hlbiBgZGF0YWAgaXMgYSBzaW5nbGUgb2JqZWN0LCBhbmQgcmVxdWlyZWQgd2hlbiBgZGF0YWAgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cy4gSWYgbm90IHNwZWNpZmllZCBmb3IgYW4gYXJyYXlcclxuICogb2Ygb2JqZWN0cywgdGhlIG1ldGhvZCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBQYXJhbWV0ZXIgJ2NvbHVtbnMnIGlzIHJlcXVpcmVkIHdoZW4gZ2VuZXJhdGluZyBtdWx0aS1yb3cgdmFsdWVzLmBcclxuICpcclxuICogV2hlbiB0aGUgZmluYWwge0BsaW5rIGhlbHBlcnMuQ29sdW1uU2V0IENvbHVtblNldH0gaXMgZW1wdHkgKG5vIGNvbHVtbnMgaW4gaXQpLCB0aGUgbWV0aG9kIHdpbGwgdGhyb3dcclxuICoge0BsaW5rIGV4dGVybmFsOkVycm9yIEVycm9yfSA9IGBDYW5ub3QgZ2VuZXJhdGUgdmFsdWVzIHdpdGhvdXQgYW55IGNvbHVtbnMuYFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiAtIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZSBncm91cHMsIGFjY29yZGluZyB0byBgZGF0YWBcclxuICogLSBhbiBlbXB0eSBzdHJpbmcsIGlmIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheVxyXG4gKlxyXG4gKiBAc2VlXHJcbiAqICB7QGxpbmsgaGVscGVycy5Db2x1bW4gQ29sdW1ufSxcclxuICogIHtAbGluayBoZWxwZXJzLkNvbHVtblNldCBDb2x1bW5TZXR9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKSgpO1xyXG4gKlxyXG4gKiBjb25zdCBkYXRhU2luZ2xlID0ge3ZhbDogMTIzLCBtc2c6ICdoZWxsbyd9O1xyXG4gKiBjb25zdCBkYXRhTXVsdGkgPSBbe3ZhbDogMTIzLCBtc2c6ICdoZWxsbyd9LCB7dmFsOiA0NTYsIG1zZzogJ3dvcmxkISd9XTtcclxuICpcclxuICogLy8gUHJvcGVydGllcyBjYW4gYmUgcHVsbGVkIGF1dG9tYXRpY2FsbHkgZnJvbSBhIHNpbmdsZSBvYmplY3Q6XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnZhbHVlcyhkYXRhU2luZ2xlKTtcclxuICogLy89PiAoMTIzLCdoZWxsbycpXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIENvbHVtbiBkZXRhaWxzIGFyZSByZXF1aXJlZCB3aGVuIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHM6XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnZhbHVlcyhkYXRhTXVsdGksIFsndmFsJywgJ21zZyddKTtcclxuICogLy89PiAoMTIzLCdoZWxsbycpLCg0NTYsJ3dvcmxkIScpXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIENvbHVtbiBkZXRhaWxzIGZyb20gYSByZXVzYWJsZSBDb2x1bW5TZXQgKHJlY29tbWVuZGVkIGZvciBwZXJmb3JtYW5jZSk6XHJcbiAqXHJcbiAqIGNvbnN0IGNzID0gbmV3IHBncC5oZWxwZXJzLkNvbHVtblNldChbJ3ZhbCcsICdtc2cnXSk7XHJcbiAqXHJcbiAqIHBncC5oZWxwZXJzLnZhbHVlcyhkYXRhTXVsdGksIGNzKTtcclxuICogLy89PiAoMTIzLCdoZWxsbycpLCg0NTYsJ3dvcmxkIScpXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWx1ZXMoZGF0YSwgY29sdW1ucywgY2FwU1FMKSB7XHJcblxyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIFxcJ2RhdGFcXCcgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xyXG5cclxuICAgIGlmICghKGNvbHVtbnMgaW5zdGFuY2VvZiBDb2x1bW5TZXQpKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkgJiYgbnBtLnV0aWxzLmlzTnVsbChjb2x1bW5zKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgXFwnY29sdW1uc1xcJyBpcyByZXF1aXJlZCB3aGVuIGdlbmVyYXRpbmcgbXVsdGktcm93IHZhbHVlcy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sdW1ucyA9IG5ldyBDb2x1bW5TZXQoY29sdW1ucyB8fCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbHVtbnMuY29sdW1ucy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSB2YWx1ZXMgd2l0aG91dCBhbnkgY29sdW1ucy4nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3JtYXQgPSBucG0uZm9ybWF0dGluZy5hcy5mb3JtYXQsXHJcbiAgICAgICAgZm1PcHRpb25zID0ge2NhcFNRTH07XHJcblxyXG4gICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZCB8fCB0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvYmplY3QgYXQgaW5kZXggJHtpbmRleH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcoJyArIGZvcm1hdChjb2x1bW5zLnZhcmlhYmxlcywgY29sdW1ucy5wcmVwYXJlKGQpLCBmbU9wdGlvbnMpICsgJyknO1xyXG4gICAgICAgIH0pLmpvaW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiAnKCcgKyBmb3JtYXQoY29sdW1ucy52YXJpYWJsZXMsIGNvbHVtbnMucHJlcGFyZShkYXRhKSwgZm1PcHRpb25zKSArICcpJztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7dmFsdWVzfTtcclxuIl0sIm5hbWVzIjpbIkNvbHVtblNldCIsInJlcXVpcmUiLCJucG0iLCJmb3JtYXR0aW5nIiwidXRpbHMiLCJ2YWx1ZXMiLCJkYXRhIiwiY29sdW1ucyIsImNhcFNRTCIsIlR5cGVFcnJvciIsImlzQXJyYXkiLCJBcnJheSIsImlzTnVsbCIsImxlbmd0aCIsIkVycm9yIiwiZm9ybWF0IiwiYXMiLCJmbU9wdGlvbnMiLCJtYXAiLCJkIiwiaW5kZXgiLCJ2YXJpYWJsZXMiLCJwcmVwYXJlIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/methods/values.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js":
/*!***********************************************************!*\
  !*** ./node_modules/pg-promise/lib/helpers/table-name.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    format: (__webpack_require__(/*! ../formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\").as) // formatting namespace\n};\n/**\r\n * @class helpers.TableName\r\n * @description\r\n * Represents a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * Filter `:alias` is an alternative approach to splitting an SQL name into multiple ones.\r\n *\r\n * @param {string|object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, combining `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no valid schema was specified.\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @see\r\n * {@link helpers.TableName#toPostgres toPostgres}\r\n *\r\n * @example\r\n *\r\n * const table = new pgp.helpers.TableName({table: 'my-table', schema: 'my-schema'});\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format('SELECT * FROM $1', table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */ class TableName {\n    constructor(table){\n        if (typeof table === \"string\") {\n            this.table = table;\n        } else {\n            const config = assert(table, [\n                \"table\",\n                \"schema\"\n            ]);\n            this.table = config.table;\n            if (npm.utils.isText(config.schema)) {\n                this.schema = config.schema;\n            }\n        }\n        if (!npm.utils.isText(this.table)) {\n            throw new TypeError(\"Table name must be a non-empty text string.\");\n        }\n        this.name = npm.format.name(this.table);\n        if (this.schema) {\n            this.name = npm.format.name(this.schema) + \".\" + this.name;\n        }\n        Object.freeze(this);\n    }\n}\n/**\r\n * @method helpers.TableName#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const fullName = tn[ctf.toPostgres]; // tn = an object of type TableName\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `TableName`\r\n * injects full table name as raw text.\r\n *\r\n * @param {helpers.TableName} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * Escaped full table name that includes optional schema name, if specified.\r\n */ TableName.prototype[npm.format.ctf.toPostgres] = function(self) {\n    self = this instanceof TableName && this || self;\n    return self.name;\n};\nTableName.prototype[npm.format.ctf.rawType] = true; // use as pre-formatted\n/**\r\n * @method helpers.TableName#toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */ TableName.prototype.toString = function() {\n    return this.name;\n};\nnpm.utils.addInspection(TableName, function() {\n    return this.toString();\n});\nmodule.exports = {\n    TableName\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaGVscGVycy90YWJsZS1uYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLE1BQU0sRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUV6QixNQUFNQyxNQUFNO0lBQ1JDLE9BQU9GLG1CQUFPQSxDQUFDO0lBQ2ZHLFFBQVFILGtHQUEyQixDQUFDLHVCQUF1QjtBQUMvRDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRDQyxHQUNELE1BQU1LO0lBRUZDLFlBQVlDLEtBQUssQ0FBRTtRQUNmLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzNCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNqQixPQUFPO1lBQ0gsTUFBTUMsU0FBU1QsT0FBT1EsT0FBTztnQkFBQztnQkFBUzthQUFTO1lBQ2hELElBQUksQ0FBQ0EsS0FBSyxHQUFHQyxPQUFPRCxLQUFLO1lBQ3pCLElBQUlOLElBQUlDLEtBQUssQ0FBQ08sTUFBTSxDQUFDRCxPQUFPRSxNQUFNLEdBQUc7Z0JBQ2pDLElBQUksQ0FBQ0EsTUFBTSxHQUFHRixPQUFPRSxNQUFNO1lBQy9CO1FBQ0o7UUFDQSxJQUFJLENBQUNULElBQUlDLEtBQUssQ0FBQ08sTUFBTSxDQUFDLElBQUksQ0FBQ0YsS0FBSyxHQUFHO1lBQy9CLE1BQU0sSUFBSUksVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxJQUFJRSxNQUFNLENBQUNTLElBQUksQ0FBQyxJQUFJLENBQUNMLEtBQUs7UUFDdEMsSUFBSSxJQUFJLENBQUNHLE1BQU0sRUFBRTtZQUNiLElBQUksQ0FBQ0UsSUFBSSxHQUFHWCxJQUFJRSxNQUFNLENBQUNTLElBQUksQ0FBQyxJQUFJLENBQUNGLE1BQU0sSUFBSSxNQUFNLElBQUksQ0FBQ0UsSUFBSTtRQUM5RDtRQUNBQyxPQUFPQyxNQUFNLENBQUMsSUFBSTtJQUN0QjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNEVCxVQUFVVSxTQUFTLENBQUNkLElBQUlFLE1BQU0sQ0FBQ2EsR0FBRyxDQUFDQyxVQUFVLENBQUMsR0FBRyxTQUFVQyxJQUFJO0lBQzNEQSxPQUFPLElBQUksWUFBWWIsYUFBYSxJQUFJLElBQUlhO0lBQzVDLE9BQU9BLEtBQUtOLElBQUk7QUFDcEI7QUFFQVAsVUFBVVUsU0FBUyxDQUFDZCxJQUFJRSxNQUFNLENBQUNhLEdBQUcsQ0FBQ0csT0FBTyxDQUFDLEdBQUcsTUFBTSx1QkFBdUI7QUFFM0U7Ozs7Ozs7O0NBUUMsR0FDRGQsVUFBVVUsU0FBUyxDQUFDSyxRQUFRLEdBQUc7SUFDM0IsT0FBTyxJQUFJLENBQUNSLElBQUk7QUFDcEI7QUFFQVgsSUFBSUMsS0FBSyxDQUFDbUIsYUFBYSxDQUFDaEIsV0FBVztJQUMvQixPQUFPLElBQUksQ0FBQ2UsUUFBUTtBQUN4QjtBQUVBRSxPQUFPQyxPQUFPLEdBQUc7SUFBQ2xCO0FBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9oZWxwZXJzL3RhYmxlLW5hbWUuanM/YmY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge2Fzc2VydH0gPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuLi91dGlscycpLFxyXG4gICAgZm9ybWF0OiByZXF1aXJlKCcuLi9mb3JtYXR0aW5nJykuYXMgLy8gZm9ybWF0dGluZyBuYW1lc3BhY2VcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgaGVscGVycy5UYWJsZU5hbWVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJlcHJlc2VudHMgYSBmdWxsIHRhYmxlIG5hbWUgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgaW50byBxdWVyaWVzIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgcmVhZC1vbmx5IHR5cGUgdGhhdCBjYW4gYmUgdXNlZCB3aGVyZXZlciBwYXJhbWV0ZXIgYHRhYmxlYCBpcyBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEl0IHN1cHBvcnRzICRbQ3VzdG9tIFR5cGUgRm9ybWF0dGluZ10sIHdoaWNoIG1lYW5zIHlvdSBjYW4gdXNlIHRoZSB0eXBlIGRpcmVjdGx5IGFzIGEgZm9ybWF0dGluZ1xyXG4gKiBwYXJhbWV0ZXIsIHdpdGhvdXQgc3BlY2lmeWluZyBhbnkgZXNjYXBpbmcuXHJcbiAqXHJcbiAqIEZpbHRlciBgOmFsaWFzYCBpcyBhbiBhbHRlcm5hdGl2ZSBhcHByb2FjaCB0byBzcGxpdHRpbmcgYW4gU1FMIG5hbWUgaW50byBtdWx0aXBsZSBvbmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRhYmxlXHJcbiAqIFRhYmxlIG5hbWUgZGV0YWlscywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlOlxyXG4gKlxyXG4gKiAtIHRhYmxlIG5hbWUsIGlmIGB0YWJsZWAgaXMgYSBzdHJpbmdcclxuICogLSBvYmplY3QgYHt0YWJsZSwgW3NjaGVtYV19YFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxyXG4gKiBGb3JtYXR0ZWQvZXNjYXBlZCBmdWxsIHRhYmxlIG5hbWUsIGNvbWJpbmluZyBgc2NoZW1hYCArIGB0YWJsZWAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWJsZVxyXG4gKiBUYWJsZSBuYW1lLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2NoZW1hXHJcbiAqIERhdGFiYXNlIHNjaGVtYSBuYW1lLlxyXG4gKlxyXG4gKiBJdCBpcyBgdW5kZWZpbmVkYCB3aGVuIG5vIHZhbGlkIHNjaGVtYSB3YXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7aGVscGVycy5UYWJsZU5hbWV9XHJcbiAqXHJcbiAqIEBzZWVcclxuICoge0BsaW5rIGhlbHBlcnMuVGFibGVOYW1lI3RvUG9zdGdyZXMgdG9Qb3N0Z3Jlc31cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3QgdGFibGUgPSBuZXcgcGdwLmhlbHBlcnMuVGFibGVOYW1lKHt0YWJsZTogJ215LXRhYmxlJywgc2NoZW1hOiAnbXktc2NoZW1hJ30pO1xyXG4gKiBjb25zb2xlLmxvZyh0YWJsZSk7XHJcbiAqIC8vPT4gXCJteS1zY2hlbWFcIi5cIm15LXRhYmxlXCJcclxuICpcclxuICogLy8gRm9ybWF0dGluZyB0aGUgdHlwZSBkaXJlY3RseTpcclxuICogcGdwLmFzLmZvcm1hdCgnU0VMRUNUICogRlJPTSAkMScsIHRhYmxlKTtcclxuICogLy89PiBTRUxFQ1QgKiBGUk9NIFwibXktc2NoZW1hXCIuXCJteS10YWJsZVwiXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBUYWJsZU5hbWUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhYmxlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGFzc2VydCh0YWJsZSwgWyd0YWJsZScsICdzY2hlbWEnXSk7XHJcbiAgICAgICAgICAgIHRoaXMudGFibGUgPSBjb25maWcudGFibGU7XHJcbiAgICAgICAgICAgIGlmIChucG0udXRpbHMuaXNUZXh0KGNvbmZpZy5zY2hlbWEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IGNvbmZpZy5zY2hlbWE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFucG0udXRpbHMuaXNUZXh0KHRoaXMudGFibGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RhYmxlIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSB0ZXh0IHN0cmluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbnBtLmZvcm1hdC5uYW1lKHRoaXMudGFibGUpO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtYSkge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBucG0uZm9ybWF0Lm5hbWUodGhpcy5zY2hlbWEpICsgJy4nICsgdGhpcy5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBoZWxwZXJzLlRhYmxlTmFtZSN0b1Bvc3RncmVzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAkW0N1c3RvbSBUeXBlIEZvcm1hdHRpbmddLCBiYXNlZCBvbiAkW1N5bWJvbGljIENURl0sIGkuZS4gdGhlIGFjdHVhbCBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgdmlhIHtAbGluayBleHRlcm5hbDpTeW1ib2wgU3ltYm9sfTpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgY3RmID0gcGdwLmFzLmN0ZjsgLy8gQ3VzdG9tIFR5cGUgRm9ybWF0dGluZyBzeW1ib2xzIG5hbWVzcGFjZVxyXG4gKiBjb25zdCBmdWxsTmFtZSA9IHRuW2N0Zi50b1Bvc3RncmVzXTsgLy8gdG4gPSBhbiBvYmplY3Qgb2YgdHlwZSBUYWJsZU5hbWVcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSByYXcgZm9ybWF0dGluZyB0eXBlIChgcmF3VHlwZSA9IHRydWVgKSwgaS5lLiB3aGVuIHVzZWQgYXMgYSBxdWVyeS1mb3JtYXR0aW5nIHBhcmFtZXRlciwgdHlwZSBgVGFibGVOYW1lYFxyXG4gKiBpbmplY3RzIGZ1bGwgdGFibGUgbmFtZSBhcyByYXcgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHtoZWxwZXJzLlRhYmxlTmFtZX0gW3NlbGZdXHJcbiAqIE9wdGlvbmFsIHNlbGYtcmVmZXJlbmNlLCBmb3IgRVM2IGFycm93IGZ1bmN0aW9ucy5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogRXNjYXBlZCBmdWxsIHRhYmxlIG5hbWUgdGhhdCBpbmNsdWRlcyBvcHRpb25hbCBzY2hlbWEgbmFtZSwgaWYgc3BlY2lmaWVkLlxyXG4gKi9cclxuVGFibGVOYW1lLnByb3RvdHlwZVtucG0uZm9ybWF0LmN0Zi50b1Bvc3RncmVzXSA9IGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICBzZWxmID0gdGhpcyBpbnN0YW5jZW9mIFRhYmxlTmFtZSAmJiB0aGlzIHx8IHNlbGY7XHJcbiAgICByZXR1cm4gc2VsZi5uYW1lO1xyXG59O1xyXG5cclxuVGFibGVOYW1lLnByb3RvdHlwZVtucG0uZm9ybWF0LmN0Zi5yYXdUeXBlXSA9IHRydWU7IC8vIHVzZSBhcyBwcmUtZm9ybWF0dGVkXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBoZWxwZXJzLlRhYmxlTmFtZSN0b1N0cmluZ1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHdlbGwtZm9ybWF0dGVkIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIG9iamVjdC5cclxuICpcclxuICogSXQgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB3cml0aW5nIHRoZSBvYmplY3QgaW50byB0aGUgY29uc29sZS5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblRhYmxlTmFtZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG59O1xyXG5cclxubnBtLnV0aWxzLmFkZEluc3BlY3Rpb24oVGFibGVOYW1lLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1RhYmxlTmFtZX07XHJcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwibnBtIiwidXRpbHMiLCJmb3JtYXQiLCJhcyIsIlRhYmxlTmFtZSIsImNvbnN0cnVjdG9yIiwidGFibGUiLCJjb25maWciLCJpc1RleHQiLCJzY2hlbWEiLCJUeXBlRXJyb3IiLCJuYW1lIiwiT2JqZWN0IiwiZnJlZXplIiwicHJvdG90eXBlIiwiY3RmIiwidG9Qb3N0Z3JlcyIsInNlbGYiLCJyYXdUeXBlIiwidG9TdHJpbmciLCJhZGRJbnNwZWN0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/helpers/table-name.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pg-promise/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ /* eslint no-var: off */ \nvar v = process.versions.node.split(\".\"), highVer = +v[0];\n// istanbul ignore next\nif (highVer < 14) {\n    // From pg-promise v11.0.0, the oldest supported Node.js is v14.0.0\n    // Node.js v12.0.0 was supported up to pg-promise v10.15.4\n    // Node.js v8.0.0 was supported up to pg-promise v10.14.2\n    // Node.js v7.6.0 was supported up to pg-promise v10.3.5\n    // Node.js v4.5.0 was supported up to pg-promise v8.7.5\n    // Node.js v0.10 was supported up to pg-promise v5.5.8\n    throw new Error(\"Minimum Node.js version supported by pg-promise is 14.0.0\");\n}\nmodule.exports = __webpack_require__(/*! ./main */ \"(rsc)/./node_modules/pg-promise/lib/main.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQyxHQUVELHNCQUFzQjtBQUN0QixJQUFJQSxJQUFJQyxRQUFRQyxRQUFRLENBQUNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDLE1BQ2hDQyxVQUFVLENBQUNMLENBQUMsQ0FBQyxFQUFFO0FBRW5CLHVCQUF1QjtBQUN2QixJQUFJSyxVQUFVLElBQUk7SUFFZCxtRUFBbUU7SUFFbkUsMERBQTBEO0lBQzFELHlEQUF5RDtJQUN6RCx3REFBd0Q7SUFDeEQsdURBQXVEO0lBQ3ZELHNEQUFzRDtJQUV0RCxNQUFNLElBQUlDLE1BQU07QUFDcEI7QUFFQUMsaUdBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaW5kZXguanM/MTgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuLyogZXNsaW50IG5vLXZhcjogb2ZmICovXHJcbnZhciB2ID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJyksXHJcbiAgICBoaWdoVmVyID0gK3ZbMF07XHJcblxyXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG5pZiAoaGlnaFZlciA8IDE0KSB7XHJcblxyXG4gICAgLy8gRnJvbSBwZy1wcm9taXNlIHYxMS4wLjAsIHRoZSBvbGRlc3Qgc3VwcG9ydGVkIE5vZGUuanMgaXMgdjE0LjAuMFxyXG5cclxuICAgIC8vIE5vZGUuanMgdjEyLjAuMCB3YXMgc3VwcG9ydGVkIHVwIHRvIHBnLXByb21pc2UgdjEwLjE1LjRcclxuICAgIC8vIE5vZGUuanMgdjguMC4wIHdhcyBzdXBwb3J0ZWQgdXAgdG8gcGctcHJvbWlzZSB2MTAuMTQuMlxyXG4gICAgLy8gTm9kZS5qcyB2Ny42LjAgd2FzIHN1cHBvcnRlZCB1cCB0byBwZy1wcm9taXNlIHYxMC4zLjVcclxuICAgIC8vIE5vZGUuanMgdjQuNS4wIHdhcyBzdXBwb3J0ZWQgdXAgdG8gcGctcHJvbWlzZSB2OC43LjVcclxuICAgIC8vIE5vZGUuanMgdjAuMTAgd2FzIHN1cHBvcnRlZCB1cCB0byBwZy1wcm9taXNlIHY1LjUuOFxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSBOb2RlLmpzIHZlcnNpb24gc3VwcG9ydGVkIGJ5IHBnLXByb21pc2UgaXMgMTQuMC4wJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJyk7XHJcbiJdLCJuYW1lcyI6WyJ2IiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInNwbGl0IiwiaGlnaFZlciIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/inner-state.js":
/*!****************************************************!*\
  !*** ./node_modules/pg-promise/lib/inner-state.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { addReadProp } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\");\n/**\r\n * @private\r\n * @class InnerState\r\n * @description\r\n * Implements support for private/inner state object inside the class,\r\n * which can be accessed by a derived class via hidden read-only property _inner.\r\n */ class InnerState {\n    constructor(initialState){\n        addReadProp(this, \"_inner\", {}, true);\n        if (initialState && typeof initialState === \"object\") {\n            this.extendState(initialState);\n        }\n    }\n    /**\r\n     * Extends or overrides inner state with the specified properties.\r\n     *\r\n     * Only own properties are used, i.e. inherited ones are skipped.\r\n     */ extendState(state) {\n        for(const a in state){\n            // istanbul ignore else\n            if (Object.prototype.hasOwnProperty.call(state, a)) {\n                this._inner[a] = state[a];\n            }\n        }\n    }\n}\n/**\r\n * @member InnerState#_inner\r\n * Private/Inner object state.\r\n */ module.exports = {\n    InnerState\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvaW5uZXItc3RhdGUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sRUFBQ0EsV0FBVyxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTlCOzs7Ozs7Q0FNQyxHQUNELE1BQU1DO0lBRUZDLFlBQVlDLFlBQVksQ0FBRTtRQUN0QkosWUFBWSxJQUFJLEVBQUUsVUFBVSxDQUFDLEdBQUc7UUFDaEMsSUFBSUksZ0JBQWdCLE9BQU9BLGlCQUFpQixVQUFVO1lBQ2xELElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtRQUNyQjtJQUNKO0lBRUE7Ozs7S0FJQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFLLE1BQU1DLEtBQUtELE1BQU87WUFDbkIsdUJBQXVCO1lBQ3ZCLElBQUlFLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNMLE9BQU9DLElBQUk7Z0JBQ2hELElBQUksQ0FBQ0ssTUFBTSxDQUFDTCxFQUFFLEdBQUdELEtBQUssQ0FBQ0MsRUFBRTtZQUM3QjtRQUNKO0lBQ0o7QUFDSjtBQUVBOzs7Q0FHQyxHQUVETSxPQUFPQyxPQUFPLEdBQUc7SUFBQ1o7QUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL2lubmVyLXN0YXRlLmpzPzg3ZDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2FkZFJlYWRQcm9wfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3MgSW5uZXJTdGF0ZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSW1wbGVtZW50cyBzdXBwb3J0IGZvciBwcml2YXRlL2lubmVyIHN0YXRlIG9iamVjdCBpbnNpZGUgdGhlIGNsYXNzLFxyXG4gKiB3aGljaCBjYW4gYmUgYWNjZXNzZWQgYnkgYSBkZXJpdmVkIGNsYXNzIHZpYSBoaWRkZW4gcmVhZC1vbmx5IHByb3BlcnR5IF9pbm5lci5cclxuICovXHJcbmNsYXNzIElubmVyU3RhdGUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZSkge1xyXG4gICAgICAgIGFkZFJlYWRQcm9wKHRoaXMsICdfaW5uZXInLCB7fSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSAmJiB0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuZFN0YXRlKGluaXRpYWxTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyBvciBvdmVycmlkZXMgaW5uZXIgc3RhdGUgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogT25seSBvd24gcHJvcGVydGllcyBhcmUgdXNlZCwgaS5lLiBpbmhlcml0ZWQgb25lcyBhcmUgc2tpcHBlZC5cclxuICAgICAqL1xyXG4gICAgZXh0ZW5kU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGEgaW4gc3RhdGUpIHtcclxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZSwgYSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyW2FdID0gc3RhdGVbYV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWVtYmVyIElubmVyU3RhdGUjX2lubmVyXHJcbiAqIFByaXZhdGUvSW5uZXIgb2JqZWN0IHN0YXRlLlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge0lubmVyU3RhdGV9O1xyXG4iXSwibmFtZXMiOlsiYWRkUmVhZFByb3AiLCJyZXF1aXJlIiwiSW5uZXJTdGF0ZSIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFN0YXRlIiwiZXh0ZW5kU3RhdGUiLCJzdGF0ZSIsImEiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfaW5uZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/inner-state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/main.js":
/*!*********************************************!*\
  !*** ./node_modules/pg-promise/lib/main.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { PromiseAdapter } = __webpack_require__(/*! ./promise-adapter */ \"(rsc)/./node_modules/pg-promise/lib/promise-adapter.js\");\nconst { DatabasePool } = __webpack_require__(/*! ./database-pool */ \"(rsc)/./node_modules/pg-promise/lib/database-pool.js\");\nconst { PreparedStatement, ParameterizedQuery } = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/pg-promise/lib/types/index.js\");\nconst { QueryFile } = __webpack_require__(/*! ./query-file */ \"(rsc)/./node_modules/pg-promise/lib/query-file.js\");\nconst { queryResult } = __webpack_require__(/*! ./query-result */ \"(rsc)/./node_modules/pg-promise/lib/query-result.js\");\nconst { parsePromise } = __webpack_require__(/*! ./promise-parser */ \"(rsc)/./node_modules/pg-promise/lib/promise-parser.js\");\nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    path: __webpack_require__(/*! path */ \"path\"),\n    pg: __webpack_require__(/*! pg */ \"pg\"),\n    minify: __webpack_require__(/*! pg-minify */ \"(rsc)/./node_modules/pg-minify/lib/index.js\"),\n    formatting: __webpack_require__(/*! ./formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    helpers: __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pg-promise/lib/helpers/index.js\"),\n    errors: __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/pg-promise/lib/errors/index.js\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    pubUtils: __webpack_require__(/*! ./utils/public */ \"(rsc)/./node_modules/pg-promise/lib/utils/public.js\"),\n    mode: __webpack_require__(/*! ./tx-mode */ \"(rsc)/./node_modules/pg-promise/lib/tx-mode.js\"),\n    package: __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/pg-promise/package.json\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\nlet originalClientConnect;\n/**\r\n * @author Vitaly Tomilov\r\n * @module pg-promise\r\n *\r\n * @description\r\n * ## pg-promise v11.4\r\n * All documentation here is for the latest official release only.\r\n *\r\n * ### Initialization Options\r\n *\r\n * Below is the complete list of _Initialization Options_ for the library that can be passed in during\r\n * the library's initialization:\r\n *\r\n * ```js\r\n * const initOptions = {&#47;* options as documented below *&#47;};\r\n *\r\n * const pgp = require('pg-promise')(initOptions);\r\n * ```\r\n *\r\n * @property {{}} [options]\r\n * Library Initialization Options.\r\n *\r\n * @property {boolean} [options.pgFormatting=false]\r\n * Redirects all query formatting to the $[pg] driver.\r\n *\r\n * By default (`false`), the library uses its own advanced query-formatting engine.\r\n * If you set this option to a truthy value, query formatting will be done entirely by the\r\n * $[pg] driver, which means you won't be able to use any of the feature-rich query formatting\r\n * that this library implements, restricting yourself to the very basic `$1, $2,...` syntax.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {boolean} [options.pgNative=false]\r\n * Use $[Native Bindings]. Library $[pg-native] must be included and installed independently, or else there will\r\n * be an error thrown: {@link external:Error Error} = `Failed to initialize Native Bindings.`\r\n *\r\n * This is a static option (can only be set prior to initialization).\r\n *\r\n * @property {object|function} [options.promiseLib=Promise]\r\n * Overrides the default (ES6 Promise) promise library for its internal use.\r\n *\r\n * Example below sets to use $[Bluebird] - the best and recommended promise library. It is the fastest one,\r\n * and supports $[Long Stack Traces], essential for debugging promises.\r\n *\r\n * ```js\r\n * const Promise = require('bluebird');\r\n * const initOptions = {\r\n *     promiseLib: Promise\r\n * };\r\n * const pgp = require('pg-promise')(initOptions);\r\n * ```\r\n *\r\n * All existing promise libraries are supported. The ones with recognizable signature are used automatically,\r\n * while the rest can be configured via the $[Promise Adapter].\r\n *\r\n * This is a static option (can only be set prior to initialization).\r\n *\r\n * @property {boolean} [options.capSQL=false]\r\n * Capitalizes any SQL generated by the library.\r\n *\r\n * By default, all internal SQL within the library is generated using the low case.\r\n * If, however, you want all SQL to be capitalized instead, set `capSQL` = `true`.\r\n *\r\n * It is purely a cosmetic feature.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {string|Array<string>|null|undefined|function} [options.schema]\r\n * Forces change of the default database schema(s) for every fresh connection, i.e.\r\n * the library will execute `SET search_path TO schema_1, schema_2, ...` in the background\r\n * whenever a fresh physical connection is allocated.\r\n *\r\n * Normally, one changes the default schema(s) by $[changing the database or the role], but sometimes you\r\n * may want to switch the default schema(s) without persisting the change, and then use this option.\r\n *\r\n * It can be a string, an array of strings, or a callback function that takes `dc` (database context)\r\n * as the only parameter (and as `this`), and returns schema(s) according to the database context. A callback function\r\n * can also return nothing (`undefined` or `null`), if no schema change needed for the specified database context.\r\n *\r\n * The order of schema names matters, so if a table name exists in more than one schema, its default access resolves\r\n * to the table from the first such schema on the list.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {boolean} [options.noWarnings=false]\r\n * Disables all diagnostic warnings in the library (it is ill-advised).\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.connect]\r\n * Global event {@link event:connect connect} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.disconnect]\r\n * Global event {@link event:disconnect disconnect} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.query]\r\n * Global event {@link event:query query} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.receive]\r\n * Global event {@link event:receive receive} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.task]\r\n * Global event {@link event:task task} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.transact]\r\n * Global event {@link event:transact transact} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.error]\r\n * Global event {@link event:error error} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @property {function} [options.extend]\r\n * Global event {@link event:extend extend} handler.\r\n *\r\n * This option is dynamic (can be set before or after initialization).\r\n *\r\n * @see\r\n * {@link module:pg-promise~end end},\r\n * {@link module:pg-promise~as as},\r\n * {@link module:pg-promise~errors errors},\r\n * {@link module:pg-promise~helpers helpers},\r\n * {@link module:pg-promise~minify minify},\r\n * {@link module:pg-promise~ParameterizedQuery ParameterizedQuery},\r\n * {@link module:pg-promise~PreparedStatement PreparedStatement},\r\n * {@link module:pg-promise~pg pg},\r\n * {@link module:pg-promise~QueryFile QueryFile},\r\n * {@link module:pg-promise~queryResult queryResult},\r\n * {@link module:pg-promise~spex spex},\r\n * {@link module:pg-promise~txMode txMode},\r\n * {@link module:pg-promise~utils utils}\r\n *\r\n */ function $main(options) {\n    options = assert(options, [\n        \"pgFormatting\",\n        \"pgNative\",\n        \"promiseLib\",\n        \"capSQL\",\n        \"noWarnings\",\n        \"connect\",\n        \"disconnect\",\n        \"query\",\n        \"receive\",\n        \"task\",\n        \"transact\",\n        \"error\",\n        \"extend\",\n        \"schema\"\n    ]);\n    let pg = npm.pg;\n    const p = parsePromise(options.promiseLib);\n    const config = {\n        version: npm.package.version,\n        promiseLib: p.promiseLib,\n        promise: p.promise\n    };\n    npm.utils.addReadProp(config, \"$npm\", {}, true);\n    // Locking properties that cannot be changed later:\n    npm.utils.addReadProp(options, \"promiseLib\", options.promiseLib);\n    npm.utils.addReadProp(options, \"pgNative\", !!options.pgNative);\n    config.options = options;\n    // istanbul ignore next:\n    // we do not cover code specific to Native Bindings\n    if (options.pgNative) {\n        pg = npm.pg.native;\n        if (npm.utils.isNull(pg)) {\n            throw new Error(npm.text.nativeError);\n        }\n    } else {\n        if (!originalClientConnect) {\n            originalClientConnect = pg.Client.prototype.connect;\n            pg.Client.prototype.connect = function() {\n                const handler = (msg)=>{\n                    if (msg.parameterName === \"server_version\") {\n                        this.serverVersion = msg.parameterValue;\n                        this.connection.removeListener(\"parameterStatus\", handler);\n                    }\n                };\n                this.connection.on(\"parameterStatus\", handler);\n                return originalClientConnect.call(this, ...arguments);\n            };\n        }\n    }\n    const Database = __webpack_require__(/*! ./database */ \"(rsc)/./node_modules/pg-promise/lib/database.js\")(config);\n    const inst = (cn, dc)=>{\n        if (npm.utils.isText(cn) || cn && typeof cn === \"object\") {\n            return new Database(cn, dc, config);\n        }\n        throw new TypeError(\"Invalid connection details: \" + npm.utils.toJson(cn));\n    };\n    npm.utils.addReadProperties(inst, rootNameSpace);\n    /**\r\n     * @member {external:PG} pg\r\n     * @description\r\n     * Instance of the $[pg] library that's being used, depending on initialization option `pgNative`:\r\n     *  - regular `pg` module instance, without option `pgNative`, or equal to `false` (default)\r\n     *  - `pg` module instance with $[Native Bindings], if option `pgNative` was set.\r\n     *\r\n     * Available as `pgp.pg`, after initializing the library.\r\n     */ inst.pg = pg; // keep it modifiable, so the protocol can be mocked\n    /**\r\n     * @member {function} end\r\n     * @readonly\r\n     * @description\r\n     * Shuts down all connection pools created in the process, so it can terminate without delay.\r\n     * It is available as `pgp.end`, after initializing the library.\r\n     *\r\n     * All {@link Database} objects created previously can no longer be used, and their query methods will be rejecting\r\n     * with {@link external:Error Error} = `Connection pool of the database object has been destroyed.`\r\n     *\r\n     * And if you want to shut down only a specific connection pool, you do so via the {@link Database}\r\n     * object that owns the pool: `db.$pool.end()` (see {@link Database#$pool Database.$pool}).\r\n     *\r\n     * For more details see $[Library de-initialization].\r\n     */ npm.utils.addReadProp(inst, \"end\", ()=>{\n        DatabasePool.shutDown();\n    });\n    /**\r\n     * @member {helpers} helpers\r\n     * @readonly\r\n     * @description\r\n     * Namespace for {@link helpers all query-formatting helper functions}.\r\n     *\r\n     * Available as `pgp.helpers`, after initializing the library.\r\n     *\r\n     * @see {@link helpers}.\r\n     */ npm.utils.addReadProp(inst, \"helpers\", npm.helpers(config));\n    /**\r\n     * @member {external:spex} spex\r\n     * @readonly\r\n     * @description\r\n     * Initialized instance of the $[spex] module, used by the library within tasks and transactions.\r\n     *\r\n     * Available as `pgp.spex`, after initializing the library.\r\n     *\r\n     * @see\r\n     * {@link Task#batch},\r\n     * {@link Task#page},\r\n     * {@link Task#sequence}\r\n     */ npm.utils.addReadProp(inst, \"spex\", config.$npm.spex);\n    config.pgp = inst;\n    return inst;\n}\nconst rootNameSpace = {\n    /**\r\n     * @member {formatting} as\r\n     * @readonly\r\n     * @description\r\n     * Namespace for {@link formatting all query-formatting functions}.\r\n     *\r\n     * Available as `pgp.as`, before and after initializing the library.\r\n     *\r\n     * @see {@link formatting}.\r\n     */ as: npm.formatting.as,\n    /**\r\n     * @member {external:pg-minify} minify\r\n     * @readonly\r\n     * @description\r\n     * Instance of the $[pg-minify] library used internally to minify SQL scripts.\r\n     *\r\n     * Available as `pgp.minify`, before and after initializing the library.\r\n     */ minify: npm.minify,\n    /**\r\n     * @member {queryResult} queryResult\r\n     * @readonly\r\n     * @description\r\n     * Query Result Mask enumerator.\r\n     *\r\n     * Available as `pgp.queryResult`, before and after initializing the library.\r\n     */ queryResult,\n    /**\r\n     * @member {PromiseAdapter} PromiseAdapter\r\n     * @readonly\r\n     * @description\r\n     * {@link PromiseAdapter} class.\r\n     *\r\n     * Available as `pgp.PromiseAdapter`, before and after initializing the library.\r\n     */ PromiseAdapter,\n    /**\r\n     * @member {ParameterizedQuery} ParameterizedQuery\r\n     * @readonly\r\n     * @description\r\n     * {@link ParameterizedQuery} class.\r\n     *\r\n     * Available as `pgp.ParameterizedQuery`, before and after initializing the library.\r\n     */ ParameterizedQuery,\n    /**\r\n     * @member {PreparedStatement} PreparedStatement\r\n     * @readonly\r\n     * @description\r\n     * {@link PreparedStatement} class.\r\n     *\r\n     * Available as `pgp.PreparedStatement`, before and after initializing the library.\r\n     */ PreparedStatement,\n    /**\r\n     * @member {QueryFile} QueryFile\r\n     * @readonly\r\n     * @description\r\n     * {@link QueryFile} class.\r\n     *\r\n     * Available as `pgp.QueryFile`, before and after initializing the library.\r\n     */ QueryFile,\n    /**\r\n     * @member {errors} errors\r\n     * @readonly\r\n     * @description\r\n     * {@link errors} - namespace for all error types.\r\n     *\r\n     * Available as `pgp.errors`, before and after initializing the library.\r\n     */ errors: npm.errors,\n    /**\r\n     * @member {utils} utils\r\n     * @readonly\r\n     * @description\r\n     * {@link utils} - namespace for utility functions.\r\n     *\r\n     * Available as `pgp.utils`, before and after initializing the library.\r\n     */ utils: npm.pubUtils,\n    /**\r\n     * @member {txMode} txMode\r\n     * @readonly\r\n     * @description\r\n     * {@link txMode Transaction Mode} namespace.\r\n     *\r\n     * Available as `pgp.txMode`, before and after initializing the library.\r\n     */ txMode: npm.mode\n};\nnpm.utils.addReadProperties($main, rootNameSpace);\nmodule.exports = $main; /**\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */  /**\r\n * @external PG\r\n * @see https://node-postgres.com\r\n */  /**\r\n * @external Client\r\n * @see https://node-postgres.com/api/client\r\n */  /**\r\n * @external pg-minify\r\n * @see https://github.com/vitaly-t/pg-minify\r\n */  /**\r\n * @external spex\r\n * @see https://github.com/vitaly-t/spex\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxjQUFjLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFDQyxZQUFZLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFDRSxpQkFBaUIsRUFBRUMsa0JBQWtCLEVBQUMsR0FBR0gsbUJBQU9BLENBQUM7QUFDeEQsTUFBTSxFQUFDSSxTQUFTLEVBQUMsR0FBR0osbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFDSyxXQUFXLEVBQUMsR0FBR0wsbUJBQU9BLENBQUM7QUFDOUIsTUFBTSxFQUFDTSxZQUFZLEVBQUMsR0FBR04sbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFDTyxNQUFNLEVBQUMsR0FBR1AsbUJBQU9BLENBQUM7QUFFekIsTUFBTVEsTUFBTTtJQUNSQyxNQUFNVCxtQkFBT0EsQ0FBQztJQUNkVSxJQUFJVixtQkFBT0EsQ0FBQztJQUNaVyxRQUFRWCxtQkFBT0EsQ0FBQztJQUNoQlksWUFBWVosbUJBQU9BLENBQUM7SUFDcEJhLFNBQVNiLG1CQUFPQSxDQUFDO0lBQ2pCYyxRQUFRZCxtQkFBT0EsQ0FBQztJQUNoQmUsT0FBT2YsbUJBQU9BLENBQUM7SUFDZmdCLFVBQVVoQixtQkFBT0EsQ0FBQztJQUNsQmlCLE1BQU1qQixtQkFBT0EsQ0FBQztJQUNka0IsU0FBU2xCLG1CQUFPQSxDQUFDO0lBQ2pCbUIsTUFBTW5CLG1CQUFPQSxDQUFDO0FBQ2xCO0FBRUEsSUFBSW9CO0FBRUo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdKQyxHQUNELFNBQVND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VUFBVSxDQUFDZ0QsRUFBRTtJQUVyQjs7Ozs7OztLQU9DLEdBQ0RqRCxRQUFRSCxJQUFJRyxNQUFNO0lBRWxCOzs7Ozs7O0tBT0MsR0FDRE47SUFFQTs7Ozs7OztLQU9DLEdBQ0ROO0lBRUE7Ozs7Ozs7S0FPQyxHQUNESTtJQUVBOzs7Ozs7O0tBT0MsR0FDREQ7SUFFQTs7Ozs7OztLQU9DLEdBQ0RFO0lBRUE7Ozs7Ozs7S0FPQyxHQUNEVSxRQUFRTixJQUFJTSxNQUFNO0lBRWxCOzs7Ozs7O0tBT0MsR0FDREMsT0FBT1AsSUFBSVEsUUFBUTtJQUVuQjs7Ozs7OztLQU9DLEdBQ0Q2QyxRQUFRckQsSUFBSVMsSUFBSTtBQUNwQjtBQUVBVCxJQUFJTyxLQUFLLENBQUN1QyxpQkFBaUIsQ0FBQ2pDLE9BQU9rQztBQUVuQ08sT0FBT0MsT0FBTyxHQUFHMUMsT0FFakI7OztDQUdDLElBRUQ7OztDQUdDLElBRUQ7OztDQUdDLElBRUQ7OztDQUdDLElBRUQ7OztDQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvbWFpbi5qcz9mMTBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7UHJvbWlzZUFkYXB0ZXJ9ID0gcmVxdWlyZSgnLi9wcm9taXNlLWFkYXB0ZXInKTtcclxuY29uc3Qge0RhdGFiYXNlUG9vbH0gPSByZXF1aXJlKCcuL2RhdGFiYXNlLXBvb2wnKTtcclxuY29uc3Qge1ByZXBhcmVkU3RhdGVtZW50LCBQYXJhbWV0ZXJpemVkUXVlcnl9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG5jb25zdCB7UXVlcnlGaWxlfSA9IHJlcXVpcmUoJy4vcXVlcnktZmlsZScpO1xyXG5jb25zdCB7cXVlcnlSZXN1bHR9ID0gcmVxdWlyZSgnLi9xdWVyeS1yZXN1bHQnKTtcclxuY29uc3Qge3BhcnNlUHJvbWlzZX0gPSByZXF1aXJlKCcuL3Byb21pc2UtcGFyc2VyJyk7XHJcbmNvbnN0IHthc3NlcnR9ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIHBhdGg6IHJlcXVpcmUoJ3BhdGgnKSxcclxuICAgIHBnOiByZXF1aXJlKCdwZycpLFxyXG4gICAgbWluaWZ5OiByZXF1aXJlKCdwZy1taW5pZnknKSxcclxuICAgIGZvcm1hdHRpbmc6IHJlcXVpcmUoJy4vZm9ybWF0dGluZycpLFxyXG4gICAgaGVscGVyczogcmVxdWlyZSgnLi9oZWxwZXJzJyksXHJcbiAgICBlcnJvcnM6IHJlcXVpcmUoJy4vZXJyb3JzJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpLFxyXG4gICAgcHViVXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMvcHVibGljJyksXHJcbiAgICBtb2RlOiByZXF1aXJlKCcuL3R4LW1vZGUnKSxcclxuICAgIHBhY2thZ2U6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLFxyXG4gICAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JylcclxufTtcclxuXHJcbmxldCBvcmlnaW5hbENsaWVudENvbm5lY3Q7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBWaXRhbHkgVG9taWxvdlxyXG4gKiBAbW9kdWxlIHBnLXByb21pc2VcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICMjIHBnLXByb21pc2UgdjExLjRcclxuICogQWxsIGRvY3VtZW50YXRpb24gaGVyZSBpcyBmb3IgdGhlIGxhdGVzdCBvZmZpY2lhbCByZWxlYXNlIG9ubHkuXHJcbiAqXHJcbiAqICMjIyBJbml0aWFsaXphdGlvbiBPcHRpb25zXHJcbiAqXHJcbiAqIEJlbG93IGlzIHRoZSBjb21wbGV0ZSBsaXN0IG9mIF9Jbml0aWFsaXphdGlvbiBPcHRpb25zXyBmb3IgdGhlIGxpYnJhcnkgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGR1cmluZ1xyXG4gKiB0aGUgbGlicmFyeSdzIGluaXRpYWxpemF0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBpbml0T3B0aW9ucyA9IHsmIzQ3Oyogb3B0aW9ucyBhcyBkb2N1bWVudGVkIGJlbG93IComIzQ3O307XHJcbiAqXHJcbiAqIGNvbnN0IHBncCA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKShpbml0T3B0aW9ucyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3t9fSBbb3B0aW9uc11cclxuICogTGlicmFyeSBJbml0aWFsaXphdGlvbiBPcHRpb25zLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcHRpb25zLnBnRm9ybWF0dGluZz1mYWxzZV1cclxuICogUmVkaXJlY3RzIGFsbCBxdWVyeSBmb3JtYXR0aW5nIHRvIHRoZSAkW3BnXSBkcml2ZXIuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgKGBmYWxzZWApLCB0aGUgbGlicmFyeSB1c2VzIGl0cyBvd24gYWR2YW5jZWQgcXVlcnktZm9ybWF0dGluZyBlbmdpbmUuXHJcbiAqIElmIHlvdSBzZXQgdGhpcyBvcHRpb24gdG8gYSB0cnV0aHkgdmFsdWUsIHF1ZXJ5IGZvcm1hdHRpbmcgd2lsbCBiZSBkb25lIGVudGlyZWx5IGJ5IHRoZVxyXG4gKiAkW3BnXSBkcml2ZXIsIHdoaWNoIG1lYW5zIHlvdSB3b24ndCBiZSBhYmxlIHRvIHVzZSBhbnkgb2YgdGhlIGZlYXR1cmUtcmljaCBxdWVyeSBmb3JtYXR0aW5nXHJcbiAqIHRoYXQgdGhpcyBsaWJyYXJ5IGltcGxlbWVudHMsIHJlc3RyaWN0aW5nIHlvdXJzZWxmIHRvIHRoZSB2ZXJ5IGJhc2ljIGAkMSwgJDIsLi4uYCBzeW50YXguXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3B0aW9ucy5wZ05hdGl2ZT1mYWxzZV1cclxuICogVXNlICRbTmF0aXZlIEJpbmRpbmdzXS4gTGlicmFyeSAkW3BnLW5hdGl2ZV0gbXVzdCBiZSBpbmNsdWRlZCBhbmQgaW5zdGFsbGVkIGluZGVwZW5kZW50bHksIG9yIGVsc2UgdGhlcmUgd2lsbFxyXG4gKiBiZSBhbiBlcnJvciB0aHJvd246IHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gPSBgRmFpbGVkIHRvIGluaXRpYWxpemUgTmF0aXZlIEJpbmRpbmdzLmBcclxuICpcclxuICogVGhpcyBpcyBhIHN0YXRpYyBvcHRpb24gKGNhbiBvbmx5IGJlIHNldCBwcmlvciB0byBpbml0aWFsaXphdGlvbikuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fGZ1bmN0aW9ufSBbb3B0aW9ucy5wcm9taXNlTGliPVByb21pc2VdXHJcbiAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCAoRVM2IFByb21pc2UpIHByb21pc2UgbGlicmFyeSBmb3IgaXRzIGludGVybmFsIHVzZS5cclxuICpcclxuICogRXhhbXBsZSBiZWxvdyBzZXRzIHRvIHVzZSAkW0JsdWViaXJkXSAtIHRoZSBiZXN0IGFuZCByZWNvbW1lbmRlZCBwcm9taXNlIGxpYnJhcnkuIEl0IGlzIHRoZSBmYXN0ZXN0IG9uZSxcclxuICogYW5kIHN1cHBvcnRzICRbTG9uZyBTdGFjayBUcmFjZXNdLCBlc3NlbnRpYWwgZm9yIGRlYnVnZ2luZyBwcm9taXNlcy5cclxuICpcclxuICogYGBganNcclxuICogY29uc3QgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XHJcbiAqIGNvbnN0IGluaXRPcHRpb25zID0ge1xyXG4gKiAgICAgcHJvbWlzZUxpYjogUHJvbWlzZVxyXG4gKiB9O1xyXG4gKiBjb25zdCBwZ3AgPSByZXF1aXJlKCdwZy1wcm9taXNlJykoaW5pdE9wdGlvbnMpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIGV4aXN0aW5nIHByb21pc2UgbGlicmFyaWVzIGFyZSBzdXBwb3J0ZWQuIFRoZSBvbmVzIHdpdGggcmVjb2duaXphYmxlIHNpZ25hdHVyZSBhcmUgdXNlZCBhdXRvbWF0aWNhbGx5LFxyXG4gKiB3aGlsZSB0aGUgcmVzdCBjYW4gYmUgY29uZmlndXJlZCB2aWEgdGhlICRbUHJvbWlzZSBBZGFwdGVyXS5cclxuICpcclxuICogVGhpcyBpcyBhIHN0YXRpYyBvcHRpb24gKGNhbiBvbmx5IGJlIHNldCBwcmlvciB0byBpbml0aWFsaXphdGlvbikuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FwU1FMPWZhbHNlXVxyXG4gKiBDYXBpdGFsaXplcyBhbnkgU1FMIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeS5cclxuICpcclxuICogQnkgZGVmYXVsdCwgYWxsIGludGVybmFsIFNRTCB3aXRoaW4gdGhlIGxpYnJhcnkgaXMgZ2VuZXJhdGVkIHVzaW5nIHRoZSBsb3cgY2FzZS5cclxuICogSWYsIGhvd2V2ZXIsIHlvdSB3YW50IGFsbCBTUUwgdG8gYmUgY2FwaXRhbGl6ZWQgaW5zdGVhZCwgc2V0IGBjYXBTUUxgID0gYHRydWVgLlxyXG4gKlxyXG4gKiBJdCBpcyBwdXJlbHkgYSBjb3NtZXRpYyBmZWF0dXJlLlxyXG4gKlxyXG4gKiBUaGlzIG9wdGlvbiBpcyBkeW5hbWljIChjYW4gYmUgc2V0IGJlZm9yZSBvciBhZnRlciBpbml0aWFsaXphdGlvbikuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEFycmF5PHN0cmluZz58bnVsbHx1bmRlZmluZWR8ZnVuY3Rpb259IFtvcHRpb25zLnNjaGVtYV1cclxuICogRm9yY2VzIGNoYW5nZSBvZiB0aGUgZGVmYXVsdCBkYXRhYmFzZSBzY2hlbWEocykgZm9yIGV2ZXJ5IGZyZXNoIGNvbm5lY3Rpb24sIGkuZS5cclxuICogdGhlIGxpYnJhcnkgd2lsbCBleGVjdXRlIGBTRVQgc2VhcmNoX3BhdGggVE8gc2NoZW1hXzEsIHNjaGVtYV8yLCAuLi5gIGluIHRoZSBiYWNrZ3JvdW5kXHJcbiAqIHdoZW5ldmVyIGEgZnJlc2ggcGh5c2ljYWwgY29ubmVjdGlvbiBpcyBhbGxvY2F0ZWQuXHJcbiAqXHJcbiAqIE5vcm1hbGx5LCBvbmUgY2hhbmdlcyB0aGUgZGVmYXVsdCBzY2hlbWEocykgYnkgJFtjaGFuZ2luZyB0aGUgZGF0YWJhc2Ugb3IgdGhlIHJvbGVdLCBidXQgc29tZXRpbWVzIHlvdVxyXG4gKiBtYXkgd2FudCB0byBzd2l0Y2ggdGhlIGRlZmF1bHQgc2NoZW1hKHMpIHdpdGhvdXQgcGVyc2lzdGluZyB0aGUgY2hhbmdlLCBhbmQgdGhlbiB1c2UgdGhpcyBvcHRpb24uXHJcbiAqXHJcbiAqIEl0IGNhbiBiZSBhIHN0cmluZywgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb3IgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGBkY2AgKGRhdGFiYXNlIGNvbnRleHQpXHJcbiAqIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAoYW5kIGFzIGB0aGlzYCksIGFuZCByZXR1cm5zIHNjaGVtYShzKSBhY2NvcmRpbmcgdG8gdGhlIGRhdGFiYXNlIGNvbnRleHQuIEEgY2FsbGJhY2sgZnVuY3Rpb25cclxuICogY2FuIGFsc28gcmV0dXJuIG5vdGhpbmcgKGB1bmRlZmluZWRgIG9yIGBudWxsYCksIGlmIG5vIHNjaGVtYSBjaGFuZ2UgbmVlZGVkIGZvciB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlIGNvbnRleHQuXHJcbiAqXHJcbiAqIFRoZSBvcmRlciBvZiBzY2hlbWEgbmFtZXMgbWF0dGVycywgc28gaWYgYSB0YWJsZSBuYW1lIGV4aXN0cyBpbiBtb3JlIHRoYW4gb25lIHNjaGVtYSwgaXRzIGRlZmF1bHQgYWNjZXNzIHJlc29sdmVzXHJcbiAqIHRvIHRoZSB0YWJsZSBmcm9tIHRoZSBmaXJzdCBzdWNoIHNjaGVtYSBvbiB0aGUgbGlzdC5cclxuICpcclxuICogVGhpcyBvcHRpb24gaXMgZHluYW1pYyAoY2FuIGJlIHNldCBiZWZvcmUgb3IgYWZ0ZXIgaW5pdGlhbGl6YXRpb24pLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcHRpb25zLm5vV2FybmluZ3M9ZmFsc2VdXHJcbiAqIERpc2FibGVzIGFsbCBkaWFnbm9zdGljIHdhcm5pbmdzIGluIHRoZSBsaWJyYXJ5IChpdCBpcyBpbGwtYWR2aXNlZCkuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMuY29ubmVjdF1cclxuICogR2xvYmFsIGV2ZW50IHtAbGluayBldmVudDpjb25uZWN0IGNvbm5lY3R9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMuZGlzY29ubmVjdF1cclxuICogR2xvYmFsIGV2ZW50IHtAbGluayBldmVudDpkaXNjb25uZWN0IGRpc2Nvbm5lY3R9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMucXVlcnldXHJcbiAqIEdsb2JhbCBldmVudCB7QGxpbmsgZXZlbnQ6cXVlcnkgcXVlcnl9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMucmVjZWl2ZV1cclxuICogR2xvYmFsIGV2ZW50IHtAbGluayBldmVudDpyZWNlaXZlIHJlY2VpdmV9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMudGFza11cclxuICogR2xvYmFsIGV2ZW50IHtAbGluayBldmVudDp0YXNrIHRhc2t9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMudHJhbnNhY3RdXHJcbiAqIEdsb2JhbCBldmVudCB7QGxpbmsgZXZlbnQ6dHJhbnNhY3QgdHJhbnNhY3R9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdXHJcbiAqIEdsb2JhbCBldmVudCB7QGxpbmsgZXZlbnQ6ZXJyb3IgZXJyb3J9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMuZXh0ZW5kXVxyXG4gKiBHbG9iYWwgZXZlbnQge0BsaW5rIGV2ZW50OmV4dGVuZCBleHRlbmR9IGhhbmRsZXIuXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGlzIGR5bmFtaWMgKGNhbiBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIGluaXRpYWxpemF0aW9uKS5cclxuICpcclxuICogQHNlZVxyXG4gKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+ZW5kIGVuZH0sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX5hcyBhc30sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX5lcnJvcnMgZXJyb3JzfSxcclxuICoge0BsaW5rIG1vZHVsZTpwZy1wcm9taXNlfmhlbHBlcnMgaGVscGVyc30sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX5taW5pZnkgbWluaWZ5fSxcclxuICoge0BsaW5rIG1vZHVsZTpwZy1wcm9taXNlflBhcmFtZXRlcml6ZWRRdWVyeSBQYXJhbWV0ZXJpemVkUXVlcnl9LFxyXG4gKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+UHJlcGFyZWRTdGF0ZW1lbnQgUHJlcGFyZWRTdGF0ZW1lbnR9LFxyXG4gKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+cGcgcGd9LFxyXG4gKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+UXVlcnlGaWxlIFF1ZXJ5RmlsZX0sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX5xdWVyeVJlc3VsdCBxdWVyeVJlc3VsdH0sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX5zcGV4IHNwZXh9LFxyXG4gKiB7QGxpbmsgbW9kdWxlOnBnLXByb21pc2V+dHhNb2RlIHR4TW9kZX0sXHJcbiAqIHtAbGluayBtb2R1bGU6cGctcHJvbWlzZX51dGlscyB1dGlsc31cclxuICpcclxuICovXHJcbmZ1bmN0aW9uICRtYWluKG9wdGlvbnMpIHtcclxuXHJcbiAgICBvcHRpb25zID0gYXNzZXJ0KG9wdGlvbnMsIFsncGdGb3JtYXR0aW5nJywgJ3BnTmF0aXZlJywgJ3Byb21pc2VMaWInLCAnY2FwU1FMJywgJ25vV2FybmluZ3MnLFxyXG4gICAgICAgICdjb25uZWN0JywgJ2Rpc2Nvbm5lY3QnLCAncXVlcnknLCAncmVjZWl2ZScsICd0YXNrJywgJ3RyYW5zYWN0JywgJ2Vycm9yJywgJ2V4dGVuZCcsICdzY2hlbWEnXSk7XHJcblxyXG4gICAgbGV0IHBnID0gbnBtLnBnO1xyXG4gICAgY29uc3QgcCA9IHBhcnNlUHJvbWlzZShvcHRpb25zLnByb21pc2VMaWIpO1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICB2ZXJzaW9uOiBucG0ucGFja2FnZS52ZXJzaW9uLFxyXG4gICAgICAgIHByb21pc2VMaWI6IHAucHJvbWlzZUxpYixcclxuICAgICAgICBwcm9taXNlOiBwLnByb21pc2VcclxuICAgIH07XHJcblxyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKGNvbmZpZywgJyRucG0nLCB7fSwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gTG9ja2luZyBwcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNoYW5nZWQgbGF0ZXI6XHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3Aob3B0aW9ucywgJ3Byb21pc2VMaWInLCBvcHRpb25zLnByb21pc2VMaWIpO1xyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKG9wdGlvbnMsICdwZ05hdGl2ZScsICEhb3B0aW9ucy5wZ05hdGl2ZSk7XHJcblxyXG4gICAgY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cclxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OlxyXG4gICAgLy8gd2UgZG8gbm90IGNvdmVyIGNvZGUgc3BlY2lmaWMgdG8gTmF0aXZlIEJpbmRpbmdzXHJcbiAgICBpZiAob3B0aW9ucy5wZ05hdGl2ZSkge1xyXG4gICAgICAgIHBnID0gbnBtLnBnLm5hdGl2ZTtcclxuICAgICAgICBpZiAobnBtLnV0aWxzLmlzTnVsbChwZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5wbS50ZXh0Lm5hdGl2ZUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghb3JpZ2luYWxDbGllbnRDb25uZWN0KSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ2xpZW50Q29ubmVjdCA9IHBnLkNsaWVudC5wcm90b3R5cGUuY29ubmVjdDtcclxuICAgICAgICAgICAgcGcuQ2xpZW50LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IG1zZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5wYXJhbWV0ZXJOYW1lID09PSAnc2VydmVyX3ZlcnNpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVmVyc2lvbiA9IG1zZy5wYXJhbWV0ZXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdwYXJhbWV0ZXJTdGF0dXMnLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdwYXJhbWV0ZXJTdGF0dXMnLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbENsaWVudENvbm5lY3QuY2FsbCh0aGlzLCAuLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBEYXRhYmFzZSA9IHJlcXVpcmUoJy4vZGF0YWJhc2UnKShjb25maWcpO1xyXG5cclxuICAgIGNvbnN0IGluc3QgPSAoY24sIGRjKSA9PiB7XHJcbiAgICAgICAgaWYgKG5wbS51dGlscy5pc1RleHQoY24pIHx8IChjbiAmJiB0eXBlb2YgY24gPT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFiYXNlKGNuLCBkYywgY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb25uZWN0aW9uIGRldGFpbHM6ICcgKyBucG0udXRpbHMudG9Kc29uKGNuKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcGVydGllcyhpbnN0LCByb290TmFtZVNwYWNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2V4dGVybmFsOlBHfSBwZ1xyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBJbnN0YW5jZSBvZiB0aGUgJFtwZ10gbGlicmFyeSB0aGF0J3MgYmVpbmcgdXNlZCwgZGVwZW5kaW5nIG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiBgcGdOYXRpdmVgOlxyXG4gICAgICogIC0gcmVndWxhciBgcGdgIG1vZHVsZSBpbnN0YW5jZSwgd2l0aG91dCBvcHRpb24gYHBnTmF0aXZlYCwgb3IgZXF1YWwgdG8gYGZhbHNlYCAoZGVmYXVsdClcclxuICAgICAqICAtIGBwZ2AgbW9kdWxlIGluc3RhbmNlIHdpdGggJFtOYXRpdmUgQmluZGluZ3NdLCBpZiBvcHRpb24gYHBnTmF0aXZlYCB3YXMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLnBnYCwgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBpbnN0LnBnID0gcGc7IC8vIGtlZXAgaXQgbW9kaWZpYWJsZSwgc28gdGhlIHByb3RvY29sIGNhbiBiZSBtb2NrZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufSBlbmRcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaHV0cyBkb3duIGFsbCBjb25uZWN0aW9uIHBvb2xzIGNyZWF0ZWQgaW4gdGhlIHByb2Nlc3MsIHNvIGl0IGNhbiB0ZXJtaW5hdGUgd2l0aG91dCBkZWxheS5cclxuICAgICAqIEl0IGlzIGF2YWlsYWJsZSBhcyBgcGdwLmVuZGAsIGFmdGVyIGluaXRpYWxpemluZyB0aGUgbGlicmFyeS5cclxuICAgICAqXHJcbiAgICAgKiBBbGwge0BsaW5rIERhdGFiYXNlfSBvYmplY3RzIGNyZWF0ZWQgcHJldmlvdXNseSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQsIGFuZCB0aGVpciBxdWVyeSBtZXRob2RzIHdpbGwgYmUgcmVqZWN0aW5nXHJcbiAgICAgKiB3aXRoIHtAbGluayBleHRlcm5hbDpFcnJvciBFcnJvcn0gPSBgQ29ubmVjdGlvbiBwb29sIG9mIHRoZSBkYXRhYmFzZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLmBcclxuICAgICAqXHJcbiAgICAgKiBBbmQgaWYgeW91IHdhbnQgdG8gc2h1dCBkb3duIG9ubHkgYSBzcGVjaWZpYyBjb25uZWN0aW9uIHBvb2wsIHlvdSBkbyBzbyB2aWEgdGhlIHtAbGluayBEYXRhYmFzZX1cclxuICAgICAqIG9iamVjdCB0aGF0IG93bnMgdGhlIHBvb2w6IGBkYi4kcG9vbC5lbmQoKWAgKHNlZSB7QGxpbmsgRGF0YWJhc2UjJHBvb2wgRGF0YWJhc2UuJHBvb2x9KS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzIHNlZSAkW0xpYnJhcnkgZGUtaW5pdGlhbGl6YXRpb25dLlxyXG4gICAgICovXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AoaW5zdCwgJ2VuZCcsICgpID0+IHtcclxuICAgICAgICBEYXRhYmFzZVBvb2wuc2h1dERvd24oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7aGVscGVyc30gaGVscGVyc1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIE5hbWVzcGFjZSBmb3Ige0BsaW5rIGhlbHBlcnMgYWxsIHF1ZXJ5LWZvcm1hdHRpbmcgaGVscGVyIGZ1bmN0aW9uc30uXHJcbiAgICAgKlxyXG4gICAgICogQXZhaWxhYmxlIGFzIGBwZ3AuaGVscGVyc2AsIGFmdGVyIGluaXRpYWxpemluZyB0aGUgbGlicmFyeS5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBoZWxwZXJzfS5cclxuICAgICAqL1xyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKGluc3QsICdoZWxwZXJzJywgbnBtLmhlbHBlcnMoY29uZmlnKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtleHRlcm5hbDpzcGV4fSBzcGV4XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogSW5pdGlhbGl6ZWQgaW5zdGFuY2Ugb2YgdGhlICRbc3BleF0gbW9kdWxlLCB1c2VkIGJ5IHRoZSBsaWJyYXJ5IHdpdGhpbiB0YXNrcyBhbmQgdHJhbnNhY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLnNwZXhgLCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZVxyXG4gICAgICoge0BsaW5rIFRhc2sjYmF0Y2h9LFxyXG4gICAgICoge0BsaW5rIFRhc2sjcGFnZX0sXHJcbiAgICAgKiB7QGxpbmsgVGFzayNzZXF1ZW5jZX1cclxuICAgICAqL1xyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKGluc3QsICdzcGV4JywgY29uZmlnLiRucG0uc3BleCk7XHJcblxyXG4gICAgY29uZmlnLnBncCA9IGluc3Q7XHJcblxyXG4gICAgcmV0dXJuIGluc3Q7XHJcbn1cclxuXHJcbmNvbnN0IHJvb3ROYW1lU3BhY2UgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtmb3JtYXR0aW5nfSBhc1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIE5hbWVzcGFjZSBmb3Ige0BsaW5rIGZvcm1hdHRpbmcgYWxsIHF1ZXJ5LWZvcm1hdHRpbmcgZnVuY3Rpb25zfS5cclxuICAgICAqXHJcbiAgICAgKiBBdmFpbGFibGUgYXMgYHBncC5hc2AsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGZvcm1hdHRpbmd9LlxyXG4gICAgICovXHJcbiAgICBhczogbnBtLmZvcm1hdHRpbmcuYXMsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtleHRlcm5hbDpwZy1taW5pZnl9IG1pbmlmeVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEluc3RhbmNlIG9mIHRoZSAkW3BnLW1pbmlmeV0gbGlicmFyeSB1c2VkIGludGVybmFsbHkgdG8gbWluaWZ5IFNRTCBzY3JpcHRzLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLm1pbmlmeWAsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBtaW5pZnk6IG5wbS5taW5pZnksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtxdWVyeVJlc3VsdH0gcXVlcnlSZXN1bHRcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBRdWVyeSBSZXN1bHQgTWFzayBlbnVtZXJhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLnF1ZXJ5UmVzdWx0YCwgYmVmb3JlIGFuZCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5UmVzdWx0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7UHJvbWlzZUFkYXB0ZXJ9IFByb21pc2VBZGFwdGVyXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICoge0BsaW5rIFByb21pc2VBZGFwdGVyfSBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBBdmFpbGFibGUgYXMgYHBncC5Qcm9taXNlQWRhcHRlcmAsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBQcm9taXNlQWRhcHRlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge1BhcmFtZXRlcml6ZWRRdWVyeX0gUGFyYW1ldGVyaXplZFF1ZXJ5XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICoge0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQXZhaWxhYmxlIGFzIGBwZ3AuUGFyYW1ldGVyaXplZFF1ZXJ5YCwgYmVmb3JlIGFuZCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIFBhcmFtZXRlcml6ZWRRdWVyeSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge1ByZXBhcmVkU3RhdGVtZW50fSBQcmVwYXJlZFN0YXRlbWVudFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudH0gY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQXZhaWxhYmxlIGFzIGBwZ3AuUHJlcGFyZWRTdGF0ZW1lbnRgLCBiZWZvcmUgYW5kIGFmdGVyIGluaXRpYWxpemluZyB0aGUgbGlicmFyeS5cclxuICAgICAqL1xyXG4gICAgUHJlcGFyZWRTdGF0ZW1lbnQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtRdWVyeUZpbGV9IFF1ZXJ5RmlsZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIHtAbGluayBRdWVyeUZpbGV9IGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLlF1ZXJ5RmlsZWAsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBRdWVyeUZpbGUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtlcnJvcnN9IGVycm9yc1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIHtAbGluayBlcnJvcnN9IC0gbmFtZXNwYWNlIGZvciBhbGwgZXJyb3IgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogQXZhaWxhYmxlIGFzIGBwZ3AuZXJyb3JzYCwgYmVmb3JlIGFuZCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIGVycm9yczogbnBtLmVycm9ycyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge3V0aWxzfSB1dGlsc1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIHtAbGluayB1dGlsc30gLSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgZnVuY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLnV0aWxzYCwgYmVmb3JlIGFuZCBhZnRlciBpbml0aWFsaXppbmcgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIHV0aWxzOiBucG0ucHViVXRpbHMsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHt0eE1vZGV9IHR4TW9kZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIHtAbGluayB0eE1vZGUgVHJhbnNhY3Rpb24gTW9kZX0gbmFtZXNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIEF2YWlsYWJsZSBhcyBgcGdwLnR4TW9kZWAsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICB0eE1vZGU6IG5wbS5tb2RlXHJcbn07XHJcblxyXG5ucG0udXRpbHMuYWRkUmVhZFByb3BlcnRpZXMoJG1haW4sIHJvb3ROYW1lU3BhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAkbWFpbjtcclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgUHJvbWlzZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2VcclxuICovXHJcblxyXG4vKipcclxuICogQGV4dGVybmFsIFBHXHJcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlLXBvc3RncmVzLmNvbVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXh0ZXJuYWwgQ2xpZW50XHJcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlLXBvc3RncmVzLmNvbS9hcGkvY2xpZW50XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBleHRlcm5hbCBwZy1taW5pZnlcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWx5LXQvcGctbWluaWZ5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBleHRlcm5hbCBzcGV4XHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFseS10L3NwZXhcclxuICovXHJcbiJdLCJuYW1lcyI6WyJQcm9taXNlQWRhcHRlciIsInJlcXVpcmUiLCJEYXRhYmFzZVBvb2wiLCJQcmVwYXJlZFN0YXRlbWVudCIsIlBhcmFtZXRlcml6ZWRRdWVyeSIsIlF1ZXJ5RmlsZSIsInF1ZXJ5UmVzdWx0IiwicGFyc2VQcm9taXNlIiwiYXNzZXJ0IiwibnBtIiwicGF0aCIsInBnIiwibWluaWZ5IiwiZm9ybWF0dGluZyIsImhlbHBlcnMiLCJlcnJvcnMiLCJ1dGlscyIsInB1YlV0aWxzIiwibW9kZSIsInBhY2thZ2UiLCJ0ZXh0Iiwib3JpZ2luYWxDbGllbnRDb25uZWN0IiwiJG1haW4iLCJvcHRpb25zIiwicCIsInByb21pc2VMaWIiLCJjb25maWciLCJ2ZXJzaW9uIiwicHJvbWlzZSIsImFkZFJlYWRQcm9wIiwicGdOYXRpdmUiLCJuYXRpdmUiLCJpc051bGwiLCJFcnJvciIsIm5hdGl2ZUVycm9yIiwiQ2xpZW50IiwicHJvdG90eXBlIiwiY29ubmVjdCIsImhhbmRsZXIiLCJtc2ciLCJwYXJhbWV0ZXJOYW1lIiwic2VydmVyVmVyc2lvbiIsInBhcmFtZXRlclZhbHVlIiwiY29ubmVjdGlvbiIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJjYWxsIiwiYXJndW1lbnRzIiwiRGF0YWJhc2UiLCJpbnN0IiwiY24iLCJkYyIsImlzVGV4dCIsIlR5cGVFcnJvciIsInRvSnNvbiIsImFkZFJlYWRQcm9wZXJ0aWVzIiwicm9vdE5hbWVTcGFjZSIsInNodXREb3duIiwiJG5wbSIsInNwZXgiLCJwZ3AiLCJhcyIsInR4TW9kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/patterns.js":
/*!*************************************************!*\
  !*** ./node_modules/pg-promise/lib/patterns.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ /*\r\n  The most important regular expressions and data as used by the library,\r\n  isolated here to help with possible edge cases during integration.\r\n*/ \nmodule.exports = {\n    // Searches for all Named Parameters, supporting any of the following syntax:\n    // ${propName}, $(propName), $[propName], $/propName/, $<propName>\n    // Nested property names are also supported: ${propName.abc}\n    namedParameters: /\\$(?:({)|(\\()|(<)|(\\[)|(\\/))\\s*[a-zA-Z0-9$_.]+(\\^|~|#|:raw|:alias|:name|:json|:csv|:list|:value)?\\s*(?:(?=\\2)(?=\\3)(?=\\4)(?=\\5)}|(?=\\1)(?=\\3)(?=\\4)(?=\\5)\\)|(?=\\1)(?=\\2)(?=\\4)(?=\\5)>|(?=\\1)(?=\\2)(?=\\3)(?=\\5)]|(?=\\1)(?=\\2)(?=\\3)(?=\\4)\\/)/g,\n    // Searches for all variables $1, $2, ...$100000, and while it will find greater than $100000\n    // variables, the formatting engine is expected to throw an error for those.\n    multipleValues: /\\$([1-9][0-9]{0,16}(?![0-9])(\\^|~|#|:raw|:alias|:name|:json|:csv|:list|:value)?)/g,\n    // Searches for all occurrences of variable $1\n    singleValue: /\\$1(?![0-9])(\\^|~|#|:raw|:alias|:name|:json|:csv|:list|:value)?/g,\n    // Matches a valid column name for the Column type parser, according to the following rules:\n    // - can contain: any combination of a-z, A-Z, 0-9, $ or _\n    // - can contain ? at the start\n    // - can contain one of the supported filters/modifiers\n    validColumn: /\\??[a-zA-Z0-9$_]+(\\^|~|#|:raw|:alias|:name|:json|:csv|:list|:value)?/,\n    // Matches a valid open-name JavaScript variable, according to the following rules:\n    // - can contain: any combination of a-z, A-Z, 0-9, $ or _\n    validVariable: /[a-zA-Z0-9$_]+/,\n    // Matches a valid modifier in a column/property:\n    hasValidModifier: /\\^|~|#|:raw|:alias|:name|:json|:csv|:list|:value/,\n    // List of all supported formatting modifiers:\n    validModifiers: [\n        \"^\",\n        \"~\",\n        \"#\",\n        \":raw\",\n        \":alias\",\n        \":name\",\n        \":json\",\n        \":csv\",\n        \":list\",\n        \":value\"\n    ]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcGF0dGVybnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQyxHQUVEOzs7QUFHQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDYiw2RUFBNkU7SUFDN0Usa0VBQWtFO0lBQ2xFLDREQUE0RDtJQUM1REMsaUJBQWlCO0lBRWpCLDZGQUE2RjtJQUM3Riw0RUFBNEU7SUFDNUVDLGdCQUFnQjtJQUVoQiw4Q0FBOEM7SUFDOUNDLGFBQWE7SUFFYiw0RkFBNEY7SUFDNUYsMERBQTBEO0lBQzFELCtCQUErQjtJQUMvQix1REFBdUQ7SUFDdkRDLGFBQWE7SUFFYixtRkFBbUY7SUFDbkYsMERBQTBEO0lBQzFEQyxlQUFlO0lBRWYsaURBQWlEO0lBQ2pEQyxrQkFBa0I7SUFFbEIsOENBQThDO0lBQzlDQyxnQkFBZ0I7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFRO1FBQVU7UUFBUztRQUFTO1FBQVE7UUFBUztLQUFTO0FBQ2xHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcGF0dGVybnMuanM/NDc3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuLypcclxuICBUaGUgbW9zdCBpbXBvcnRhbnQgcmVndWxhciBleHByZXNzaW9ucyBhbmQgZGF0YSBhcyB1c2VkIGJ5IHRoZSBsaWJyYXJ5LFxyXG4gIGlzb2xhdGVkIGhlcmUgdG8gaGVscCB3aXRoIHBvc3NpYmxlIGVkZ2UgY2FzZXMgZHVyaW5nIGludGVncmF0aW9uLlxyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAvLyBTZWFyY2hlcyBmb3IgYWxsIE5hbWVkIFBhcmFtZXRlcnMsIHN1cHBvcnRpbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3ludGF4OlxyXG4gICAgLy8gJHtwcm9wTmFtZX0sICQocHJvcE5hbWUpLCAkW3Byb3BOYW1lXSwgJC9wcm9wTmFtZS8sICQ8cHJvcE5hbWU+XHJcbiAgICAvLyBOZXN0ZWQgcHJvcGVydHkgbmFtZXMgYXJlIGFsc28gc3VwcG9ydGVkOiAke3Byb3BOYW1lLmFiY31cclxuICAgIG5hbWVkUGFyYW1ldGVyczogL1xcJCg/Oih7KXwoXFwoKXwoPCl8KFxcWyl8KFxcLykpXFxzKlthLXpBLVowLTkkXy5dKyhcXF58fnwjfDpyYXd8OmFsaWFzfDpuYW1lfDpqc29ufDpjc3Z8Omxpc3R8OnZhbHVlKT9cXHMqKD86KD89XFwyKSg/PVxcMykoPz1cXDQpKD89XFw1KX18KD89XFwxKSg/PVxcMykoPz1cXDQpKD89XFw1KVxcKXwoPz1cXDEpKD89XFwyKSg/PVxcNCkoPz1cXDUpPnwoPz1cXDEpKD89XFwyKSg/PVxcMykoPz1cXDUpXXwoPz1cXDEpKD89XFwyKSg/PVxcMykoPz1cXDQpXFwvKS9nLFxyXG5cclxuICAgIC8vIFNlYXJjaGVzIGZvciBhbGwgdmFyaWFibGVzICQxLCAkMiwgLi4uJDEwMDAwMCwgYW5kIHdoaWxlIGl0IHdpbGwgZmluZCBncmVhdGVyIHRoYW4gJDEwMDAwMFxyXG4gICAgLy8gdmFyaWFibGVzLCB0aGUgZm9ybWF0dGluZyBlbmdpbmUgaXMgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlLlxyXG4gICAgbXVsdGlwbGVWYWx1ZXM6IC9cXCQoWzEtOV1bMC05XXswLDE2fSg/IVswLTldKShcXF58fnwjfDpyYXd8OmFsaWFzfDpuYW1lfDpqc29ufDpjc3Z8Omxpc3R8OnZhbHVlKT8pL2csXHJcblxyXG4gICAgLy8gU2VhcmNoZXMgZm9yIGFsbCBvY2N1cnJlbmNlcyBvZiB2YXJpYWJsZSAkMVxyXG4gICAgc2luZ2xlVmFsdWU6IC9cXCQxKD8hWzAtOV0pKFxcXnx+fCN8OnJhd3w6YWxpYXN8Om5hbWV8Ompzb258OmNzdnw6bGlzdHw6dmFsdWUpPy9nLFxyXG5cclxuICAgIC8vIE1hdGNoZXMgYSB2YWxpZCBjb2x1bW4gbmFtZSBmb3IgdGhlIENvbHVtbiB0eXBlIHBhcnNlciwgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXM6XHJcbiAgICAvLyAtIGNhbiBjb250YWluOiBhbnkgY29tYmluYXRpb24gb2YgYS16LCBBLVosIDAtOSwgJCBvciBfXHJcbiAgICAvLyAtIGNhbiBjb250YWluID8gYXQgdGhlIHN0YXJ0XHJcbiAgICAvLyAtIGNhbiBjb250YWluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbHRlcnMvbW9kaWZpZXJzXHJcbiAgICB2YWxpZENvbHVtbjogL1xcPz9bYS16QS1aMC05JF9dKyhcXF58fnwjfDpyYXd8OmFsaWFzfDpuYW1lfDpqc29ufDpjc3Z8Omxpc3R8OnZhbHVlKT8vLFxyXG5cclxuICAgIC8vIE1hdGNoZXMgYSB2YWxpZCBvcGVuLW5hbWUgSmF2YVNjcmlwdCB2YXJpYWJsZSwgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXM6XHJcbiAgICAvLyAtIGNhbiBjb250YWluOiBhbnkgY29tYmluYXRpb24gb2YgYS16LCBBLVosIDAtOSwgJCBvciBfXHJcbiAgICB2YWxpZFZhcmlhYmxlOiAvW2EtekEtWjAtOSRfXSsvLFxyXG5cclxuICAgIC8vIE1hdGNoZXMgYSB2YWxpZCBtb2RpZmllciBpbiBhIGNvbHVtbi9wcm9wZXJ0eTpcclxuICAgIGhhc1ZhbGlkTW9kaWZpZXI6IC9cXF58fnwjfDpyYXd8OmFsaWFzfDpuYW1lfDpqc29ufDpjc3Z8Omxpc3R8OnZhbHVlLyxcclxuXHJcbiAgICAvLyBMaXN0IG9mIGFsbCBzdXBwb3J0ZWQgZm9ybWF0dGluZyBtb2RpZmllcnM6XHJcbiAgICB2YWxpZE1vZGlmaWVyczogWydeJywgJ34nLCAnIycsICc6cmF3JywgJzphbGlhcycsICc6bmFtZScsICc6anNvbicsICc6Y3N2JywgJzpsaXN0JywgJzp2YWx1ZSddXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibmFtZWRQYXJhbWV0ZXJzIiwibXVsdGlwbGVWYWx1ZXMiLCJzaW5nbGVWYWx1ZSIsInZhbGlkQ29sdW1uIiwidmFsaWRWYXJpYWJsZSIsImhhc1ZhbGlkTW9kaWZpZXIiLCJ2YWxpZE1vZGlmaWVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/patterns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/promise-adapter.js":
/*!********************************************************!*\
  !*** ./node_modules/pg-promise/lib/promise-adapter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\n/**\r\n * @class PromiseAdapter\r\n * @summary Adapter for the primary promise operations.\r\n * @description\r\n * Provides compatibility with promise libraries that cannot be recognized automatically,\r\n * via functions that implement the primary operations with promises:\r\n *\r\n *  - construct a new promise with a callback function\r\n *  - resolve a promise with some result data\r\n *  - reject a promise with a reason\r\n *  - resolve an array of promises\r\n *\r\n * The type is available from the library's root: `pgp.PromiseAdapter`.\r\n *\r\n * @param {object} api\r\n * Promise API configuration object.\r\n *\r\n * Passing in anything other than an object will throw {@link external:TypeError TypeError} = `Adapter requires an api configuration object.`\r\n *\r\n * @param {function} api.create\r\n * A function that takes a callback parameter and returns a new promise object.\r\n * The callback parameter is expected to be `function(resolve, reject)`.\r\n *\r\n * Passing in anything other than a function will throw {@link external:TypeError TypeError} = `Function 'create' must be specified.`\r\n *\r\n * @param {function} api.resolve\r\n * A function that takes an optional data parameter and resolves a promise with it.\r\n *\r\n * Passing in anything other than a function will throw {@link external:TypeError TypeError} = `Function 'resolve' must be specified.`\r\n *\r\n * @param {function} api.reject\r\n * A function that takes an optional error parameter and rejects a promise with it.\r\n *\r\n * Passing in anything other than a function will throw {@link external:TypeError TypeError} = `Function 'reject' must be specified.`\r\n *\r\n * @param {function} api.all\r\n * A function that resolves an array of promises.\r\n *\r\n * Passing in anything other than a function will throw {@link external:TypeError TypeError} = `Function 'all' must be specified.`\r\n *\r\n * @returns {PromiseAdapter}\r\n */ class PromiseAdapter {\n    constructor(api){\n        if (!api || typeof api !== \"object\") {\n            throw new TypeError(\"Adapter requires an api configuration object.\");\n        }\n        api = assert(api, [\n            \"create\",\n            \"resolve\",\n            \"reject\",\n            \"all\"\n        ]);\n        this.create = api.create;\n        this.resolve = api.resolve;\n        this.reject = api.reject;\n        this.all = api.all;\n        if (typeof this.create !== \"function\") {\n            throw new TypeError(\"Function 'create' must be specified.\");\n        }\n        if (typeof this.resolve !== \"function\") {\n            throw new TypeError(\"Function 'resolve' must be specified.\");\n        }\n        if (typeof this.reject !== \"function\") {\n            throw new TypeError(\"Function 'reject' must be specified.\");\n        }\n        if (typeof this.all !== \"function\") {\n            throw new TypeError(\"Function 'all' must be specified.\");\n        }\n    }\n}\nmodule.exports = {\n    PromiseAdapter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcHJvbWlzZS1hZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLE1BQU0sRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUV6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5Q0MsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxHQUFHLENBQUU7UUFFYixJQUFJLENBQUNBLE9BQU8sT0FBT0EsUUFBUSxVQUFVO1lBQ2pDLE1BQU0sSUFBSUMsVUFBVTtRQUN4QjtRQUVBRCxNQUFNSixPQUFPSSxLQUFLO1lBQUM7WUFBVTtZQUFXO1lBQVU7U0FBTTtRQUV4RCxJQUFJLENBQUNFLE1BQU0sR0FBR0YsSUFBSUUsTUFBTTtRQUN4QixJQUFJLENBQUNDLE9BQU8sR0FBR0gsSUFBSUcsT0FBTztRQUMxQixJQUFJLENBQUNDLE1BQU0sR0FBR0osSUFBSUksTUFBTTtRQUN4QixJQUFJLENBQUNDLEdBQUcsR0FBR0wsSUFBSUssR0FBRztRQUVsQixJQUFJLE9BQU8sSUFBSSxDQUFDSCxNQUFNLEtBQUssWUFBWTtZQUNuQyxNQUFNLElBQUlELFVBQVU7UUFDeEI7UUFFQSxJQUFJLE9BQU8sSUFBSSxDQUFDRSxPQUFPLEtBQUssWUFBWTtZQUNwQyxNQUFNLElBQUlGLFVBQVU7UUFDeEI7UUFFQSxJQUFJLE9BQU8sSUFBSSxDQUFDRyxNQUFNLEtBQUssWUFBWTtZQUNuQyxNQUFNLElBQUlILFVBQVU7UUFDeEI7UUFFQSxJQUFJLE9BQU8sSUFBSSxDQUFDSSxHQUFHLEtBQUssWUFBWTtZQUNoQyxNQUFNLElBQUlKLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUFDVDtBQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcHJvbWlzZS1hZGFwdGVyLmpzPzAwODgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHthc3NlcnR9ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgUHJvbWlzZUFkYXB0ZXJcclxuICogQHN1bW1hcnkgQWRhcHRlciBmb3IgdGhlIHByaW1hcnkgcHJvbWlzZSBvcGVyYXRpb25zLlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUHJvdmlkZXMgY29tcGF0aWJpbGl0eSB3aXRoIHByb21pc2UgbGlicmFyaWVzIHRoYXQgY2Fubm90IGJlIHJlY29nbml6ZWQgYXV0b21hdGljYWxseSxcclxuICogdmlhIGZ1bmN0aW9ucyB0aGF0IGltcGxlbWVudCB0aGUgcHJpbWFyeSBvcGVyYXRpb25zIHdpdGggcHJvbWlzZXM6XHJcbiAqXHJcbiAqICAtIGNvbnN0cnVjdCBhIG5ldyBwcm9taXNlIHdpdGggYSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiAgLSByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIHNvbWUgcmVzdWx0IGRhdGFcclxuICogIC0gcmVqZWN0IGEgcHJvbWlzZSB3aXRoIGEgcmVhc29uXHJcbiAqICAtIHJlc29sdmUgYW4gYXJyYXkgb2YgcHJvbWlzZXNcclxuICpcclxuICogVGhlIHR5cGUgaXMgYXZhaWxhYmxlIGZyb20gdGhlIGxpYnJhcnkncyByb290OiBgcGdwLlByb21pc2VBZGFwdGVyYC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGFwaVxyXG4gKiBQcm9taXNlIEFQSSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGFuIG9iamVjdCB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBBZGFwdGVyIHJlcXVpcmVzIGFuIGFwaSBjb25maWd1cmF0aW9uIG9iamVjdC5gXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFwaS5jcmVhdGVcclxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2sgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugb2JqZWN0LlxyXG4gKiBUaGUgY2FsbGJhY2sgcGFyYW1ldGVyIGlzIGV4cGVjdGVkIHRvIGJlIGBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpYC5cclxuICpcclxuICogUGFzc2luZyBpbiBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb24gd2lsbCB0aHJvdyB7QGxpbmsgZXh0ZXJuYWw6VHlwZUVycm9yIFR5cGVFcnJvcn0gPSBgRnVuY3Rpb24gJ2NyZWF0ZScgbXVzdCBiZSBzcGVjaWZpZWQuYFxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcGkucmVzb2x2ZVxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3B0aW9uYWwgZGF0YSBwYXJhbWV0ZXIgYW5kIHJlc29sdmVzIGEgcHJvbWlzZSB3aXRoIGl0LlxyXG4gKlxyXG4gKiBQYXNzaW5nIGluIGFueXRoaW5nIG90aGVyIHRoYW4gYSBmdW5jdGlvbiB3aWxsIHRocm93IHtAbGluayBleHRlcm5hbDpUeXBlRXJyb3IgVHlwZUVycm9yfSA9IGBGdW5jdGlvbiAncmVzb2x2ZScgbXVzdCBiZSBzcGVjaWZpZWQuYFxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcGkucmVqZWN0XHJcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBlcnJvciBwYXJhbWV0ZXIgYW5kIHJlamVjdHMgYSBwcm9taXNlIHdpdGggaXQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYW55dGhpbmcgb3RoZXIgdGhhbiBhIGZ1bmN0aW9uIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYEZ1bmN0aW9uICdyZWplY3QnIG11c3QgYmUgc3BlY2lmaWVkLmBcclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gYXBpLmFsbFxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvbWlzZXMuXHJcbiAqXHJcbiAqIFBhc3NpbmcgaW4gYW55dGhpbmcgb3RoZXIgdGhhbiBhIGZ1bmN0aW9uIHdpbGwgdGhyb3cge0BsaW5rIGV4dGVybmFsOlR5cGVFcnJvciBUeXBlRXJyb3J9ID0gYEZ1bmN0aW9uICdhbGwnIG11c3QgYmUgc3BlY2lmaWVkLmBcclxuICpcclxuICogQHJldHVybnMge1Byb21pc2VBZGFwdGVyfVxyXG4gKi9cclxuY2xhc3MgUHJvbWlzZUFkYXB0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBpKSB7XHJcblxyXG4gICAgICAgIGlmICghYXBpIHx8IHR5cGVvZiBhcGkgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FkYXB0ZXIgcmVxdWlyZXMgYW4gYXBpIGNvbmZpZ3VyYXRpb24gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXBpID0gYXNzZXJ0KGFwaSwgWydjcmVhdGUnLCAncmVzb2x2ZScsICdyZWplY3QnLCAnYWxsJ10pO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFwaS5jcmVhdGU7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gYXBpLnJlc29sdmU7XHJcbiAgICAgICAgdGhpcy5yZWplY3QgPSBhcGkucmVqZWN0O1xyXG4gICAgICAgIHRoaXMuYWxsID0gYXBpLmFsbDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBcXCdjcmVhdGVcXCcgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBcXCdyZXNvbHZlXFwnIG11c3QgYmUgc3BlY2lmaWVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBcXCdyZWplY3RcXCcgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYWxsICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uIFxcJ2FsbFxcJyBtdXN0IGJlIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1Byb21pc2VBZGFwdGVyfTtcclxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJQcm9taXNlQWRhcHRlciIsImNvbnN0cnVjdG9yIiwiYXBpIiwiVHlwZUVycm9yIiwiY3JlYXRlIiwicmVzb2x2ZSIsInJlamVjdCIsImFsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/promise-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/promise-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/pg-promise/lib/promise-parser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { PromiseAdapter } = __webpack_require__(/*! ./promise-adapter */ \"(rsc)/./node_modules/pg-promise/lib/promise-adapter.js\");\n//////////////////////////////////////////\n// Parses and validates a promise library;\nfunction parse(pl) {\n    let promise;\n    if (pl instanceof PromiseAdapter) {\n        promise = function(func) {\n            return pl.create(func);\n        };\n        promise.resolve = pl.resolve;\n        promise.reject = pl.reject;\n        promise.all = pl.all;\n        return promise;\n    }\n    const t = typeof pl;\n    if (t === \"function\" || t === \"object\") {\n        const Root = typeof pl.Promise === \"function\" ? pl.Promise : pl;\n        promise = function(func) {\n            return new Root(func);\n        };\n        promise.resolve = Root.resolve;\n        promise.reject = Root.reject;\n        promise.all = Root.all;\n        if (typeof promise.resolve === \"function\" && typeof promise.reject === \"function\" && typeof promise.all === \"function\") {\n            return promise;\n        }\n    }\n    throw new TypeError(\"Invalid promise library specified.\");\n}\nfunction parsePromise(promiseLib) {\n    const result = {\n        promiseLib\n    };\n    if (promiseLib) {\n        result.promise = parse(promiseLib);\n    } else {\n        result.promise = parse(Promise);\n        result.promiseLib = Promise;\n    }\n    return result;\n}\nmodule.exports = {\n    parsePromise\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcHJvbWlzZS1wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsY0FBYyxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWpDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsU0FBU0MsTUFBTUMsRUFBRTtJQUViLElBQUlDO0lBQ0osSUFBSUQsY0FBY0gsZ0JBQWdCO1FBQzlCSSxVQUFVLFNBQVVDLElBQUk7WUFDcEIsT0FBT0YsR0FBR0csTUFBTSxDQUFDRDtRQUNyQjtRQUNBRCxRQUFRRyxPQUFPLEdBQUdKLEdBQUdJLE9BQU87UUFDNUJILFFBQVFJLE1BQU0sR0FBR0wsR0FBR0ssTUFBTTtRQUMxQkosUUFBUUssR0FBRyxHQUFHTixHQUFHTSxHQUFHO1FBQ3BCLE9BQU9MO0lBQ1g7SUFDQSxNQUFNTSxJQUFJLE9BQU9QO0lBQ2pCLElBQUlPLE1BQU0sY0FBY0EsTUFBTSxVQUFVO1FBQ3BDLE1BQU1DLE9BQU8sT0FBT1IsR0FBR1MsT0FBTyxLQUFLLGFBQWFULEdBQUdTLE9BQU8sR0FBR1Q7UUFDN0RDLFVBQVUsU0FBVUMsSUFBSTtZQUNwQixPQUFPLElBQUlNLEtBQUtOO1FBQ3BCO1FBQ0FELFFBQVFHLE9BQU8sR0FBR0ksS0FBS0osT0FBTztRQUM5QkgsUUFBUUksTUFBTSxHQUFHRyxLQUFLSCxNQUFNO1FBQzVCSixRQUFRSyxHQUFHLEdBQUdFLEtBQUtGLEdBQUc7UUFDdEIsSUFBSSxPQUFPTCxRQUFRRyxPQUFPLEtBQUssY0FDM0IsT0FBT0gsUUFBUUksTUFBTSxLQUFLLGNBQzFCLE9BQU9KLFFBQVFLLEdBQUcsS0FBSyxZQUFZO1lBQ25DLE9BQU9MO1FBQ1g7SUFDSjtJQUVBLE1BQU0sSUFBSVMsVUFBVTtBQUN4QjtBQUVBLFNBQVNDLGFBQWFDLFVBQVU7SUFDNUIsTUFBTUMsU0FBUztRQUFDRDtJQUFVO0lBQzFCLElBQUlBLFlBQVk7UUFDWkMsT0FBT1osT0FBTyxHQUFHRixNQUFNYTtJQUMzQixPQUFPO1FBQ0hDLE9BQU9aLE9BQU8sR0FBR0YsTUFBTVU7UUFDdkJJLE9BQU9ELFVBQVUsR0FBR0g7SUFDeEI7SUFDQSxPQUFPSTtBQUNYO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUFDSjtBQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcHJvbWlzZS1wYXJzZXIuanM/MTAzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1Byb21pc2VBZGFwdGVyfSA9IHJlcXVpcmUoJy4vcHJvbWlzZS1hZGFwdGVyJyk7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUGFyc2VzIGFuZCB2YWxpZGF0ZXMgYSBwcm9taXNlIGxpYnJhcnk7XHJcbmZ1bmN0aW9uIHBhcnNlKHBsKSB7XHJcblxyXG4gICAgbGV0IHByb21pc2U7XHJcbiAgICBpZiAocGwgaW5zdGFuY2VvZiBQcm9taXNlQWRhcHRlcikge1xyXG4gICAgICAgIHByb21pc2UgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGwuY3JlYXRlKGZ1bmMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlID0gcGwucmVzb2x2ZTtcclxuICAgICAgICBwcm9taXNlLnJlamVjdCA9IHBsLnJlamVjdDtcclxuICAgICAgICBwcm9taXNlLmFsbCA9IHBsLmFsbDtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHQgPSB0eXBlb2YgcGw7XHJcbiAgICBpZiAodCA9PT0gJ2Z1bmN0aW9uJyB8fCB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IFJvb3QgPSB0eXBlb2YgcGwuUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyA/IHBsLlByb21pc2UgOiBwbDtcclxuICAgICAgICBwcm9taXNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSb290KGZ1bmMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlID0gUm9vdC5yZXNvbHZlO1xyXG4gICAgICAgIHByb21pc2UucmVqZWN0ID0gUm9vdC5yZWplY3Q7XHJcbiAgICAgICAgcHJvbWlzZS5hbGwgPSBSb290LmFsbDtcclxuICAgICAgICBpZiAodHlwZW9mIHByb21pc2UucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcHJvbWlzZS5yZWplY3QgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHByb21pc2UuYWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHByb21pc2UgbGlicmFyeSBzcGVjaWZpZWQuJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlUHJvbWlzZShwcm9taXNlTGliKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7cHJvbWlzZUxpYn07XHJcbiAgICBpZiAocHJvbWlzZUxpYikge1xyXG4gICAgICAgIHJlc3VsdC5wcm9taXNlID0gcGFyc2UocHJvbWlzZUxpYik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5wcm9taXNlID0gcGFyc2UoUHJvbWlzZSk7XHJcbiAgICAgICAgcmVzdWx0LnByb21pc2VMaWIgPSBQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7cGFyc2VQcm9taXNlfTtcclxuIl0sIm5hbWVzIjpbIlByb21pc2VBZGFwdGVyIiwicmVxdWlyZSIsInBhcnNlIiwicGwiLCJwcm9taXNlIiwiZnVuYyIsImNyZWF0ZSIsInJlc29sdmUiLCJyZWplY3QiLCJhbGwiLCJ0IiwiUm9vdCIsIlByb21pc2UiLCJUeXBlRXJyb3IiLCJwYXJzZVByb21pc2UiLCJwcm9taXNlTGliIiwicmVzdWx0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/promise-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/query-file.js":
/*!***************************************************!*\
  !*** ./node_modules/pg-promise/lib/query-file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { InnerState } = __webpack_require__(/*! ./inner-state */ \"(rsc)/./node_modules/pg-promise/lib/inner-state.js\");\nconst { QueryFileError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/pg-promise/lib/errors/index.js\");\nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst { ColorConsole } = __webpack_require__(/*! ./utils/color */ \"(rsc)/./node_modules/pg-promise/lib/utils/color.js\");\nconst npm = {\n    fs: __webpack_require__(/*! fs */ \"fs\"),\n    os: __webpack_require__(/*! os */ \"os\"),\n    path: __webpack_require__(/*! path */ \"path\"),\n    minify: __webpack_require__(/*! pg-minify */ \"(rsc)/./node_modules/pg-minify/lib/index.js\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    formatting: __webpack_require__(/*! ./formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\")\n};\nconst file$query = Symbol(\"QueryFile.query\");\n/**\r\n * @class QueryFile\r\n * @description\r\n *\r\n * Represents an external SQL file. The type is available from the library's root: `pgp.QueryFile`.\r\n *\r\n * Reads a file with SQL and prepares it for execution, also parses and minifies it, if required.\r\n * The SQL can be of any complexity, with both single and multi-line comments.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly, plus as `text` in {@link PreparedStatement}\r\n * and {@link ParameterizedQuery}.\r\n *\r\n * It never throws any error, leaving it for query methods to reject with {@link errors.QueryFileError QueryFileError}.\r\n *\r\n * **IMPORTANT:** You should only create a single reusable object per file, in order to avoid repeated file reads,\r\n * as the IO is a very expensive resource. If you do not follow it, you will be seeing the following warning:\r\n * `Creating a duplicate QueryFile object for the same file`, which signals a bad-use pattern.\r\n *\r\n * @param {string} file\r\n * Path to the SQL file with the query, either absolute or relative to the application's entry point file.\r\n *\r\n * If there is any problem reading the file, it will be reported when executing the query.\r\n *\r\n * @param {QueryFile.Options} [options]\r\n * Set of configuration options, as documented by {@link QueryFile.Options}.\r\n *\r\n * @returns {QueryFile}\r\n *\r\n * @see\r\n * {@link errors.QueryFileError QueryFileError},\r\n * {@link QueryFile#toPostgres toPostgres}\r\n *\r\n * @example\r\n * // File sql.js\r\n *\r\n * // Proper way to organize an sql provider:\r\n * //\r\n * // - have all sql files for Users in ./sql/users\r\n * // - have all sql files for Products in ./sql/products\r\n * // - have your sql provider module as ./sql/index.js\r\n *\r\n * const {QueryFile} = require('pg-promise');\r\n * const {join: joinPath} = require('path');\r\n *\r\n * // Helper for linking to external query files:\r\n * function sql(file) {\r\n *     const fullPath = joinPath(__dirname, file); // generating full path;\r\n *     return new QueryFile(fullPath, {minify: true});\r\n * }\r\n *\r\n * module.exports = {\r\n *     // external queries for Users:\r\n *     users: {\r\n *         add: sql('users/create.sql'),\r\n *         search: sql('users/search.sql'),\r\n *         report: sql('users/report.sql'),\r\n *     },\r\n *     // external queries for Products:\r\n *     products: {\r\n *         add: sql('products/add.sql'),\r\n *         quote: sql('products/quote.sql'),\r\n *         search: sql('products/search.sql'),\r\n *     }\r\n * };\r\n *\r\n * @example\r\n * // Testing our SQL provider\r\n *\r\n * const db = require('./db'); // our database module;\r\n * const {users: sql} = require('./sql'); // sql for users;\r\n *\r\n * module.exports = {\r\n *     addUser: (name, age) => db.none(sql.add, [name, age]),\r\n *     findUser: name => db.any(sql.search, name)\r\n * };\r\n *\r\n */ class QueryFile extends InnerState {\n    constructor(file, options){\n        let filePath = file;\n        options = assert(options, {\n            debug: npm.utils.isDev(),\n            minify: options && options.compress && options.minify === undefined ? true : undefined,\n            compress: undefined,\n            params: undefined,\n            noWarnings: undefined\n        });\n        if (npm.utils.isText(filePath) && !npm.path.isAbsolute(filePath)) {\n            filePath = npm.path.join(npm.utils.startDir, filePath);\n        }\n        const { usedPath } = QueryFile.instance;\n        // istanbul ignore next:\n        if (!options.noWarnings) {\n            if (filePath in usedPath) {\n                usedPath[filePath]++;\n                ColorConsole.warn(`WARNING: Creating a duplicate QueryFile object for the same file - \\n    ${filePath}\\n${npm.utils.getLocalStack(2, 3)}\\n`);\n            } else {\n                usedPath[filePath] = 0;\n            }\n        }\n        const _inner = {\n            file,\n            filePath,\n            options,\n            sql: undefined,\n            error: undefined,\n            ready: undefined,\n            modTime: undefined\n        };\n        super(_inner);\n        this.prepare();\n    }\n    /**\r\n     * Global instance of the file-path repository.\r\n     *\r\n     * @return {{usedPath: {}}}\r\n     */ static get instance() {\n        const s = Symbol.for(\"pgPromiseQueryFile\");\n        let scope = global[s];\n        if (!scope) {\n            scope = {\n                usedPath: {} // used-path look-up dictionary\n            };\n            global[s] = scope;\n        }\n        return scope;\n    }\n    /**\r\n     * @name QueryFile#Symbol(QueryFile.$query)\r\n     * @type {string}\r\n     * @default undefined\r\n     * @readonly\r\n     * @private\r\n     * @summary Prepared query string.\r\n     * @description\r\n     * When property {@link QueryFile#error error} is set, the query is `undefined`.\r\n     *\r\n     * **IMPORTANT:** This property is for internal use by the library only, never use this\r\n     * property directly from your code.\r\n     */ get [file$query]() {\n        return this._inner.sql;\n    }\n    /**\r\n     * @name QueryFile#error\r\n     * @type {errors.QueryFileError}\r\n     * @default undefined\r\n     * @readonly\r\n     * @description\r\n     * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.\r\n     */ get error() {\n        return this._inner.error;\n    }\n    /**\r\n     * @name QueryFile#file\r\n     * @type {string}\r\n     * @readonly\r\n     * @description\r\n     * File name that was passed into the constructor.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */ get file() {\n        return this._inner.file;\n    }\n    /**\r\n     * @name QueryFile#options\r\n     * @type {QueryFile.Options}\r\n     * @readonly\r\n     * @description\r\n     * Set of options, as configured during the object's construction.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */ get options() {\n        return this._inner.options;\n    }\n    /**\r\n     * @summary Prepares the query for execution.\r\n     * @description\r\n     * If the query hasn't been prepared yet, it will read the file and process the content according\r\n     * to the parameters passed into the constructor.\r\n     *\r\n     * This method is primarily for internal use by the library.\r\n     *\r\n     * @param {boolean} [throwErrors=false]\r\n     * Throw any error encountered.\r\n     */ prepare(throwErrors) {\n        const i = this._inner, options = i.options;\n        let lastMod;\n        if (options.debug && i.ready) {\n            try {\n                lastMod = npm.fs.statSync(i.filePath).mtime.getTime();\n                // istanbul ignore if;\n                if (lastMod === i.modTime) {\n                    return;\n                }\n                i.ready = false;\n            } catch (e) {\n                i.sql = undefined;\n                i.ready = false;\n                i.error = e;\n                if (throwErrors) {\n                    throw i.error;\n                }\n                return;\n            }\n        }\n        if (i.ready) {\n            return;\n        }\n        try {\n            i.sql = npm.fs.readFileSync(i.filePath, \"utf8\");\n            i.modTime = lastMod || npm.fs.statSync(i.filePath).mtime.getTime();\n            if (options.minify && options.minify !== \"after\") {\n                i.sql = npm.minify(i.sql, {\n                    compress: options.compress\n                });\n            }\n            if (options.params !== undefined) {\n                i.sql = npm.formatting.as.format(i.sql, options.params, {\n                    partial: true\n                });\n            }\n            if (options.minify && options.minify === \"after\") {\n                i.sql = npm.minify(i.sql, {\n                    compress: options.compress\n                });\n            }\n            i.ready = true;\n            i.error = undefined;\n        } catch (e) {\n            i.sql = undefined;\n            i.error = new QueryFileError(e, this);\n            if (throwErrors) {\n                throw i.error;\n            }\n        }\n    }\n}\n// Hiding the query as a symbol within the type,\n// to make it even more difficult to misuse it:\nQueryFile.$query = file$query;\n/**\r\n * @method QueryFile#toPostgres\r\n * @description\r\n * $[Custom Type Formatting], based on $[Symbolic CTF], i.e. the actual method is available only via {@link external:Symbol Symbol}:\r\n *\r\n * ```js\r\n * const ctf = pgp.as.ctf; // Custom Type Formatting symbols namespace\r\n * const query = qf[ctf.toPostgres](); // qf = an object of type QueryFile\r\n * ```\r\n *\r\n * This is a raw formatting type (`rawType = true`), i.e. when used as a query-formatting parameter, type `QueryFile` injects SQL as raw text.\r\n *\r\n * If you need to support type `QueryFile` outside of query methods, this is the only safe way to get the most current SQL.\r\n * And you would want to use this method dynamically, as it reloads the SQL automatically, if option `debug` is set.\r\n * See {@link QueryFile.Options Options}.\r\n *\r\n * @param {QueryFile} [self]\r\n * Optional self-reference, for ES6 arrow functions.\r\n *\r\n * @returns {string}\r\n * SQL string from the file, according to the {@link QueryFile.Options options} specified.\r\n *\r\n */ QueryFile.prototype[npm.formatting.as.ctf.toPostgres] = function(self) {\n    self = this instanceof QueryFile && this || self;\n    self.prepare(true);\n    return self[QueryFile.$query];\n};\nQueryFile.prototype[npm.formatting.as.ctf.rawType] = true; // use as pre-formatted\n/**\r\n * @method QueryFile#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ QueryFile.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap = npm.utils.messageGap(level + 1);\n    const lines = [\n        \"QueryFile {\"\n    ];\n    this.prepare();\n    lines.push(gap + 'file: \"' + this.file + '\"');\n    lines.push(gap + \"options: \" + npm.utils.toJson(this.options));\n    if (this.error) {\n        lines.push(gap + \"error: \" + this.error.toString(level + 1));\n    } else {\n        lines.push(gap + 'query: \"' + this[QueryFile.$query] + '\"');\n    }\n    lines.push(npm.utils.messageGap(level) + \"}\");\n    return lines.join(npm.os.EOL);\n};\nnpm.utils.addInspection(QueryFile, function() {\n    return this.toString();\n});\nmodule.exports = {\n    QueryFile\n}; /**\r\n * @typedef QueryFile.Options\r\n * @description\r\n * A set of configuration options as passed into the {@link QueryFile} constructor.\r\n *\r\n * @property {boolean} debug\r\n * When in debug mode, the query file is checked for its last modification time on every query request,\r\n * so if it changes, the file is read afresh.\r\n *\r\n * The default for this property is `true` when `NODE_ENV` = `development`,\r\n * or `false` otherwise.\r\n *\r\n * @property {boolean|string} minify=false\r\n * Parses and minifies the SQL using $[pg-minify]:\r\n * - `false` - do not use $[pg-minify]\r\n * - `true` - use $[pg-minify] to parse and minify SQL\r\n * - `'after'` - use $[pg-minify] after applying static formatting parameters\r\n *   (option `params`), as opposed to before it (default)\r\n *\r\n * If option `compress` is set, then the default for `minify` is `true`.\r\n *\r\n * Failure to parse SQL will result in $[SQLParsingError].\r\n *\r\n * @property {boolean} compress=false\r\n * Sets option `compress` as supported by $[pg-minify], to uglify the SQL:\r\n * - `false` - no compression to be applied, keep minimum spaces for easier read\r\n * - `true` - remove all unnecessary spaces from SQL\r\n *\r\n * This option has no meaning, if `minify` is explicitly set to `false`. However, if `minify` is not\r\n * specified and `compress` is specified as `true`, then `minify` defaults to `true`.\r\n *\r\n * @property {array|object|value} params\r\n *\r\n * Static formatting parameters to be applied to the SQL, using the same method {@link formatting.format as.format},\r\n * but with option `partial` = `true`.\r\n *\r\n * Most of the time query formatting is fully dynamic, and applied just before executing the query.\r\n * In some cases though you may need to pre-format SQL with static values. Examples of it can be a\r\n * schema name, or a configurable table name.\r\n *\r\n * This option makes two-step SQL formatting easy: you can pre-format the SQL initially, and then\r\n * apply the second-step dynamic formatting when executing the query.\r\n *\r\n * @property {boolean} noWarnings=false\r\n * Suppresses all warnings produced by the class. It is not recommended for general use, only in specific tests\r\n * that may require it.\r\n *\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcXVlcnktZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxVQUFVLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFDQyxjQUFjLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFDRSxNQUFNLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFDRyxZQUFZLEVBQUMsR0FBR0gsbUJBQU9BLENBQUM7QUFFL0IsTUFBTUksTUFBTTtJQUNSQyxJQUFJTCxtQkFBT0EsQ0FBQztJQUNaTSxJQUFJTixtQkFBT0EsQ0FBQztJQUNaTyxNQUFNUCxtQkFBT0EsQ0FBQztJQUNkUSxRQUFRUixtQkFBT0EsQ0FBQztJQUNoQlMsT0FBT1QsbUJBQU9BLENBQUM7SUFDZlUsWUFBWVYsbUJBQU9BLENBQUM7QUFDeEI7QUFFQSxNQUFNVyxhQUFhQyxPQUFPO0FBRTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEVDLEdBQ0QsTUFBTUMsa0JBQWtCZDtJQUVwQmUsWUFBWUMsSUFBSSxFQUFFQyxPQUFPLENBQUU7UUFFdkIsSUFBSUMsV0FBV0Y7UUFFZkMsVUFBVWQsT0FBT2MsU0FBUztZQUN0QkUsT0FBT2QsSUFBSUssS0FBSyxDQUFDVSxLQUFLO1lBQ3RCWCxRQUFRLFdBQVlRLFFBQVFJLFFBQVEsSUFBSUosUUFBUVIsTUFBTSxLQUFLYSxZQUFhLE9BQU9BO1lBQy9FRCxVQUFVQztZQUNWQyxRQUFRRDtZQUNSRSxZQUFZRjtRQUNoQjtRQUVBLElBQUlqQixJQUFJSyxLQUFLLENBQUNlLE1BQU0sQ0FBQ1AsYUFBYSxDQUFDYixJQUFJRyxJQUFJLENBQUNrQixVQUFVLENBQUNSLFdBQVc7WUFDOURBLFdBQVdiLElBQUlHLElBQUks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aHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcXVlcnktZmlsZS5qcz8xZGRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7SW5uZXJTdGF0ZX0gPSByZXF1aXJlKCcuL2lubmVyLXN0YXRlJyk7XHJcbmNvbnN0IHtRdWVyeUZpbGVFcnJvcn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xyXG5jb25zdCB7YXNzZXJ0fSA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XHJcbmNvbnN0IHtDb2xvckNvbnNvbGV9ID0gcmVxdWlyZSgnLi91dGlscy9jb2xvcicpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgZnM6IHJlcXVpcmUoJ2ZzJyksXHJcbiAgICBvczogcmVxdWlyZSgnb3MnKSxcclxuICAgIHBhdGg6IHJlcXVpcmUoJ3BhdGgnKSxcclxuICAgIG1pbmlmeTogcmVxdWlyZSgncGctbWluaWZ5JyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpLFxyXG4gICAgZm9ybWF0dGluZzogcmVxdWlyZSgnLi9mb3JtYXR0aW5nJylcclxufTtcclxuXHJcbmNvbnN0IGZpbGUkcXVlcnkgPSBTeW1ib2woJ1F1ZXJ5RmlsZS5xdWVyeScpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBRdWVyeUZpbGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgU1FMIGZpbGUuIFRoZSB0eXBlIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSBsaWJyYXJ5J3Mgcm9vdDogYHBncC5RdWVyeUZpbGVgLlxyXG4gKlxyXG4gKiBSZWFkcyBhIGZpbGUgd2l0aCBTUUwgYW5kIHByZXBhcmVzIGl0IGZvciBleGVjdXRpb24sIGFsc28gcGFyc2VzIGFuZCBtaW5pZmllcyBpdCwgaWYgcmVxdWlyZWQuXHJcbiAqIFRoZSBTUUwgY2FuIGJlIG9mIGFueSBjb21wbGV4aXR5LCB3aXRoIGJvdGggc2luZ2xlIGFuZCBtdWx0aS1saW5lIGNvbW1lbnRzLlxyXG4gKlxyXG4gKiBUaGUgdHlwZSBjYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgYHF1ZXJ5YCBwYXJhbWV0ZXIsIHdpdGggYW55IHF1ZXJ5IG1ldGhvZCBkaXJlY3RseSwgcGx1cyBhcyBgdGV4dGAgaW4ge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fVxyXG4gKiBhbmQge0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0uXHJcbiAqXHJcbiAqIEl0IG5ldmVyIHRocm93cyBhbnkgZXJyb3IsIGxlYXZpbmcgaXQgZm9yIHF1ZXJ5IG1ldGhvZHMgdG8gcmVqZWN0IHdpdGgge0BsaW5rIGVycm9ycy5RdWVyeUZpbGVFcnJvciBRdWVyeUZpbGVFcnJvcn0uXHJcbiAqXHJcbiAqICoqSU1QT1JUQU5UOioqIFlvdSBzaG91bGQgb25seSBjcmVhdGUgYSBzaW5nbGUgcmV1c2FibGUgb2JqZWN0IHBlciBmaWxlLCBpbiBvcmRlciB0byBhdm9pZCByZXBlYXRlZCBmaWxlIHJlYWRzLFxyXG4gKiBhcyB0aGUgSU8gaXMgYSB2ZXJ5IGV4cGVuc2l2ZSByZXNvdXJjZS4gSWYgeW91IGRvIG5vdCBmb2xsb3cgaXQsIHlvdSB3aWxsIGJlIHNlZWluZyB0aGUgZm9sbG93aW5nIHdhcm5pbmc6XHJcbiAqIGBDcmVhdGluZyBhIGR1cGxpY2F0ZSBRdWVyeUZpbGUgb2JqZWN0IGZvciB0aGUgc2FtZSBmaWxlYCwgd2hpY2ggc2lnbmFscyBhIGJhZC11c2UgcGF0dGVybi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVcclxuICogUGF0aCB0byB0aGUgU1FMIGZpbGUgd2l0aCB0aGUgcXVlcnksIGVpdGhlciBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB0aGUgYXBwbGljYXRpb24ncyBlbnRyeSBwb2ludCBmaWxlLlxyXG4gKlxyXG4gKiBJZiB0aGVyZSBpcyBhbnkgcHJvYmxlbSByZWFkaW5nIHRoZSBmaWxlLCBpdCB3aWxsIGJlIHJlcG9ydGVkIHdoZW4gZXhlY3V0aW5nIHRoZSBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHtRdWVyeUZpbGUuT3B0aW9uc30gW29wdGlvbnNdXHJcbiAqIFNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMsIGFzIGRvY3VtZW50ZWQgYnkge0BsaW5rIFF1ZXJ5RmlsZS5PcHRpb25zfS5cclxuICpcclxuICogQHJldHVybnMge1F1ZXJ5RmlsZX1cclxuICpcclxuICogQHNlZVxyXG4gKiB7QGxpbmsgZXJyb3JzLlF1ZXJ5RmlsZUVycm9yIFF1ZXJ5RmlsZUVycm9yfSxcclxuICoge0BsaW5rIFF1ZXJ5RmlsZSN0b1Bvc3RncmVzIHRvUG9zdGdyZXN9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEZpbGUgc3FsLmpzXHJcbiAqXHJcbiAqIC8vIFByb3BlciB3YXkgdG8gb3JnYW5pemUgYW4gc3FsIHByb3ZpZGVyOlxyXG4gKiAvL1xyXG4gKiAvLyAtIGhhdmUgYWxsIHNxbCBmaWxlcyBmb3IgVXNlcnMgaW4gLi9zcWwvdXNlcnNcclxuICogLy8gLSBoYXZlIGFsbCBzcWwgZmlsZXMgZm9yIFByb2R1Y3RzIGluIC4vc3FsL3Byb2R1Y3RzXHJcbiAqIC8vIC0gaGF2ZSB5b3VyIHNxbCBwcm92aWRlciBtb2R1bGUgYXMgLi9zcWwvaW5kZXguanNcclxuICpcclxuICogY29uc3Qge1F1ZXJ5RmlsZX0gPSByZXF1aXJlKCdwZy1wcm9taXNlJyk7XHJcbiAqIGNvbnN0IHtqb2luOiBqb2luUGF0aH0gPSByZXF1aXJlKCdwYXRoJyk7XHJcbiAqXHJcbiAqIC8vIEhlbHBlciBmb3IgbGlua2luZyB0byBleHRlcm5hbCBxdWVyeSBmaWxlczpcclxuICogZnVuY3Rpb24gc3FsKGZpbGUpIHtcclxuICogICAgIGNvbnN0IGZ1bGxQYXRoID0gam9pblBhdGgoX19kaXJuYW1lLCBmaWxlKTsgLy8gZ2VuZXJhdGluZyBmdWxsIHBhdGg7XHJcbiAqICAgICByZXR1cm4gbmV3IFF1ZXJ5RmlsZShmdWxsUGF0aCwge21pbmlmeTogdHJ1ZX0pO1xyXG4gKiB9XHJcbiAqXHJcbiAqIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gKiAgICAgLy8gZXh0ZXJuYWwgcXVlcmllcyBmb3IgVXNlcnM6XHJcbiAqICAgICB1c2Vyczoge1xyXG4gKiAgICAgICAgIGFkZDogc3FsKCd1c2Vycy9jcmVhdGUuc3FsJyksXHJcbiAqICAgICAgICAgc2VhcmNoOiBzcWwoJ3VzZXJzL3NlYXJjaC5zcWwnKSxcclxuICogICAgICAgICByZXBvcnQ6IHNxbCgndXNlcnMvcmVwb3J0LnNxbCcpLFxyXG4gKiAgICAgfSxcclxuICogICAgIC8vIGV4dGVybmFsIHF1ZXJpZXMgZm9yIFByb2R1Y3RzOlxyXG4gKiAgICAgcHJvZHVjdHM6IHtcclxuICogICAgICAgICBhZGQ6IHNxbCgncHJvZHVjdHMvYWRkLnNxbCcpLFxyXG4gKiAgICAgICAgIHF1b3RlOiBzcWwoJ3Byb2R1Y3RzL3F1b3RlLnNxbCcpLFxyXG4gKiAgICAgICAgIHNlYXJjaDogc3FsKCdwcm9kdWN0cy9zZWFyY2guc3FsJyksXHJcbiAqICAgICB9XHJcbiAqIH07XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFRlc3Rpbmcgb3VyIFNRTCBwcm92aWRlclxyXG4gKlxyXG4gKiBjb25zdCBkYiA9IHJlcXVpcmUoJy4vZGInKTsgLy8gb3VyIGRhdGFiYXNlIG1vZHVsZTtcclxuICogY29uc3Qge3VzZXJzOiBzcWx9ID0gcmVxdWlyZSgnLi9zcWwnKTsgLy8gc3FsIGZvciB1c2VycztcclxuICpcclxuICogbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAqICAgICBhZGRVc2VyOiAobmFtZSwgYWdlKSA9PiBkYi5ub25lKHNxbC5hZGQsIFtuYW1lLCBhZ2VdKSxcclxuICogICAgIGZpbmRVc2VyOiBuYW1lID0+IGRiLmFueShzcWwuc2VhcmNoLCBuYW1lKVxyXG4gKiB9O1xyXG4gKlxyXG4gKi9cclxuY2xhc3MgUXVlcnlGaWxlIGV4dGVuZHMgSW5uZXJTdGF0ZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZmlsZSwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICBsZXQgZmlsZVBhdGggPSBmaWxlO1xyXG5cclxuICAgICAgICBvcHRpb25zID0gYXNzZXJ0KG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgZGVidWc6IG5wbS51dGlscy5pc0RldigpLFxyXG4gICAgICAgICAgICBtaW5pZnk6IChvcHRpb25zICYmIG9wdGlvbnMuY29tcHJlc3MgJiYgb3B0aW9ucy5taW5pZnkgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb21wcmVzczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbm9XYXJuaW5nczogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChucG0udXRpbHMuaXNUZXh0KGZpbGVQYXRoKSAmJiAhbnBtLnBhdGguaXNBYnNvbHV0ZShmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgZmlsZVBhdGggPSBucG0ucGF0aC5qb2luKG5wbS51dGlscy5zdGFydERpciwgZmlsZVBhdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qge3VzZWRQYXRofSA9IFF1ZXJ5RmlsZS5pbnN0YW5jZTtcclxuXHJcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLm5vV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGZpbGVQYXRoIGluIHVzZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VkUGF0aFtmaWxlUGF0aF0rKztcclxuICAgICAgICAgICAgICAgIENvbG9yQ29uc29sZS53YXJuKGBXQVJOSU5HOiBDcmVhdGluZyBhIGR1cGxpY2F0ZSBRdWVyeUZpbGUgb2JqZWN0IGZvciB0aGUgc2FtZSBmaWxlIC0gXFxuICAgICR7ZmlsZVBhdGh9XFxuJHtucG0udXRpbHMuZ2V0TG9jYWxTdGFjaygyLCAzKX1cXG5gKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVzZWRQYXRoW2ZpbGVQYXRoXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IF9pbm5lciA9IHtcclxuICAgICAgICAgICAgZmlsZSxcclxuICAgICAgICAgICAgZmlsZVBhdGgsXHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIHNxbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICByZWFkeTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtb2RUaW1lOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzdXBlcihfaW5uZXIpO1xyXG5cclxuICAgICAgICB0aGlzLnByZXBhcmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBpbnN0YW5jZSBvZiB0aGUgZmlsZS1wYXRoIHJlcG9zaXRvcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7e3VzZWRQYXRoOiB7fX19XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XHJcbiAgICAgICAgY29uc3QgcyA9IFN5bWJvbC5mb3IoJ3BnUHJvbWlzZVF1ZXJ5RmlsZScpO1xyXG4gICAgICAgIGxldCBzY29wZSA9IGdsb2JhbFtzXTtcclxuICAgICAgICBpZiAoIXNjb3BlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlID0ge1xyXG4gICAgICAgICAgICAgICAgdXNlZFBhdGg6IHt9IC8vIHVzZWQtcGF0aCBsb29rLXVwIGRpY3Rpb25hcnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZ2xvYmFsW3NdID0gc2NvcGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY29wZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFF1ZXJ5RmlsZSNTeW1ib2woUXVlcnlGaWxlLiRxdWVyeSlcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzdW1tYXJ5IFByZXBhcmVkIHF1ZXJ5IHN0cmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogV2hlbiBwcm9wZXJ0eSB7QGxpbmsgUXVlcnlGaWxlI2Vycm9yIGVycm9yfSBpcyBzZXQsIHRoZSBxdWVyeSBpcyBgdW5kZWZpbmVkYC5cclxuICAgICAqXHJcbiAgICAgKiAqKklNUE9SVEFOVDoqKiBUaGlzIHByb3BlcnR5IGlzIGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkgb25seSwgbmV2ZXIgdXNlIHRoaXNcclxuICAgICAqIHByb3BlcnR5IGRpcmVjdGx5IGZyb20geW91ciBjb2RlLlxyXG4gICAgICovXHJcbiAgICBnZXQgW2ZpbGUkcXVlcnldKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lci5zcWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBRdWVyeUZpbGUjZXJyb3JcclxuICAgICAqIEB0eXBlIHtlcnJvcnMuUXVlcnlGaWxlRXJyb3J9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBXaGVuIGluIGFuIGVycm9yIHN0YXRlLCBpdCBpcyBzZXQgdG8gYSB7QGxpbmsgZXJyb3JzLlF1ZXJ5RmlsZUVycm9yIFF1ZXJ5RmlsZUVycm9yfSBvYmplY3QuIE90aGVyd2lzZSwgaXQgaXMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBlcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIuZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBRdWVyeUZpbGUjZmlsZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBGaWxlIG5hbWUgdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIGdldCBmaWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lci5maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgUXVlcnlGaWxlI29wdGlvbnNcclxuICAgICAqIEB0eXBlIHtRdWVyeUZpbGUuT3B0aW9uc31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTZXQgb2Ygb3B0aW9ucywgYXMgY29uZmlndXJlZCBkdXJpbmcgdGhlIG9iamVjdCdzIGNvbnN0cnVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIub3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBzdW1tYXJ5IFByZXBhcmVzIHRoZSBxdWVyeSBmb3IgZXhlY3V0aW9uLlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBJZiB0aGUgcXVlcnkgaGFzbid0IGJlZW4gcHJlcGFyZWQgeWV0LCBpdCB3aWxsIHJlYWQgdGhlIGZpbGUgYW5kIHByb2Nlc3MgdGhlIGNvbnRlbnQgYWNjb3JkaW5nXHJcbiAgICAgKiB0byB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdGhyb3dFcnJvcnM9ZmFsc2VdXHJcbiAgICAgKiBUaHJvdyBhbnkgZXJyb3IgZW5jb3VudGVyZWQuXHJcbiAgICAgKi9cclxuICAgIHByZXBhcmUodGhyb3dFcnJvcnMpIHtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5faW5uZXIsIG9wdGlvbnMgPSBpLm9wdGlvbnM7XHJcbiAgICAgICAgbGV0IGxhc3RNb2Q7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcgJiYgaS5yZWFkeSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGFzdE1vZCA9IG5wbS5mcy5zdGF0U3luYyhpLmZpbGVQYXRoKS5tdGltZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWY7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdE1vZCA9PT0gaS5tb2RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaS5yZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpLnNxbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGkucmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGkuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRocm93RXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaS5lcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaS5yZWFkeSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGkuc3FsID0gbnBtLmZzLnJlYWRGaWxlU3luYyhpLmZpbGVQYXRoLCAndXRmOCcpO1xyXG4gICAgICAgICAgICBpLm1vZFRpbWUgPSBsYXN0TW9kIHx8IG5wbS5mcy5zdGF0U3luYyhpLmZpbGVQYXRoKS5tdGltZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbmlmeSAmJiBvcHRpb25zLm1pbmlmeSAhPT0gJ2FmdGVyJykge1xyXG4gICAgICAgICAgICAgICAgaS5zcWwgPSBucG0ubWluaWZ5KGkuc3FsLCB7Y29tcHJlc3M6IG9wdGlvbnMuY29tcHJlc3N9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaS5zcWwgPSBucG0uZm9ybWF0dGluZy5hcy5mb3JtYXQoaS5zcWwsIG9wdGlvbnMucGFyYW1zLCB7cGFydGlhbDogdHJ1ZX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbmlmeSAmJiBvcHRpb25zLm1pbmlmeSA9PT0gJ2FmdGVyJykge1xyXG4gICAgICAgICAgICAgICAgaS5zcWwgPSBucG0ubWluaWZ5KGkuc3FsLCB7Y29tcHJlc3M6IG9wdGlvbnMuY29tcHJlc3N9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpLnJlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaS5lcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGkuc3FsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpLmVycm9yID0gbmV3IFF1ZXJ5RmlsZUVycm9yKGUsIHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodGhyb3dFcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGkuZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vLyBIaWRpbmcgdGhlIHF1ZXJ5IGFzIGEgc3ltYm9sIHdpdGhpbiB0aGUgdHlwZSxcclxuLy8gdG8gbWFrZSBpdCBldmVuIG1vcmUgZGlmZmljdWx0IHRvIG1pc3VzZSBpdDpcclxuUXVlcnlGaWxlLiRxdWVyeSA9IGZpbGUkcXVlcnk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBRdWVyeUZpbGUjdG9Qb3N0Z3Jlc1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogJFtDdXN0b20gVHlwZSBGb3JtYXR0aW5nXSwgYmFzZWQgb24gJFtTeW1ib2xpYyBDVEZdLCBpLmUuIHRoZSBhY3R1YWwgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IHZpYSB7QGxpbmsgZXh0ZXJuYWw6U3ltYm9sIFN5bWJvbH06XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IGN0ZiA9IHBncC5hcy5jdGY7IC8vIEN1c3RvbSBUeXBlIEZvcm1hdHRpbmcgc3ltYm9scyBuYW1lc3BhY2VcclxuICogY29uc3QgcXVlcnkgPSBxZltjdGYudG9Qb3N0Z3Jlc10oKTsgLy8gcWYgPSBhbiBvYmplY3Qgb2YgdHlwZSBRdWVyeUZpbGVcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSByYXcgZm9ybWF0dGluZyB0eXBlIChgcmF3VHlwZSA9IHRydWVgKSwgaS5lLiB3aGVuIHVzZWQgYXMgYSBxdWVyeS1mb3JtYXR0aW5nIHBhcmFtZXRlciwgdHlwZSBgUXVlcnlGaWxlYCBpbmplY3RzIFNRTCBhcyByYXcgdGV4dC5cclxuICpcclxuICogSWYgeW91IG5lZWQgdG8gc3VwcG9ydCB0eXBlIGBRdWVyeUZpbGVgIG91dHNpZGUgb2YgcXVlcnkgbWV0aG9kcywgdGhpcyBpcyB0aGUgb25seSBzYWZlIHdheSB0byBnZXQgdGhlIG1vc3QgY3VycmVudCBTUUwuXHJcbiAqIEFuZCB5b3Ugd291bGQgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZHluYW1pY2FsbHksIGFzIGl0IHJlbG9hZHMgdGhlIFNRTCBhdXRvbWF0aWNhbGx5LCBpZiBvcHRpb24gYGRlYnVnYCBpcyBzZXQuXHJcbiAqIFNlZSB7QGxpbmsgUXVlcnlGaWxlLk9wdGlvbnMgT3B0aW9uc30uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UXVlcnlGaWxlfSBbc2VsZl1cclxuICogT3B0aW9uYWwgc2VsZi1yZWZlcmVuY2UsIGZvciBFUzYgYXJyb3cgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBTUUwgc3RyaW5nIGZyb20gdGhlIGZpbGUsIGFjY29yZGluZyB0byB0aGUge0BsaW5rIFF1ZXJ5RmlsZS5PcHRpb25zIG9wdGlvbnN9IHNwZWNpZmllZC5cclxuICpcclxuICovXHJcblF1ZXJ5RmlsZS5wcm90b3R5cGVbbnBtLmZvcm1hdHRpbmcuYXMuY3RmLnRvUG9zdGdyZXNdID0gZnVuY3Rpb24gKHNlbGYpIHtcclxuICAgIHNlbGYgPSB0aGlzIGluc3RhbmNlb2YgUXVlcnlGaWxlICYmIHRoaXMgfHwgc2VsZjtcclxuICAgIHNlbGYucHJlcGFyZSh0cnVlKTtcclxuICAgIHJldHVybiBzZWxmW1F1ZXJ5RmlsZS4kcXVlcnldO1xyXG59O1xyXG5cclxuUXVlcnlGaWxlLnByb3RvdHlwZVtucG0uZm9ybWF0dGluZy5hcy5jdGYucmF3VHlwZV0gPSB0cnVlOyAvLyB1c2UgYXMgcHJlLWZvcm1hdHRlZFxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgUXVlcnlGaWxlI3RvU3RyaW5nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgd2VsbC1mb3JtYXR0ZWQgbXVsdGktbGluZSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QncyBjdXJyZW50IHN0YXRlLlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblF1ZXJ5RmlsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcCA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSk7XHJcbiAgICBjb25zdCBsaW5lcyA9IFtcclxuICAgICAgICAnUXVlcnlGaWxlIHsnXHJcbiAgICBdO1xyXG4gICAgdGhpcy5wcmVwYXJlKCk7XHJcbiAgICBsaW5lcy5wdXNoKGdhcCArICdmaWxlOiBcIicgKyB0aGlzLmZpbGUgKyAnXCInKTtcclxuICAgIGxpbmVzLnB1c2goZ2FwICsgJ29wdGlvbnM6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMub3B0aW9ucykpO1xyXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdlcnJvcjogJyArIHRoaXMuZXJyb3IudG9TdHJpbmcobGV2ZWwgKyAxKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwICsgJ3F1ZXJ5OiBcIicgKyB0aGlzW1F1ZXJ5RmlsZS4kcXVlcnldICsgJ1wiJyk7XHJcbiAgICB9XHJcbiAgICBsaW5lcy5wdXNoKG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsKSArICd9Jyk7XHJcbiAgICByZXR1cm4gbGluZXMuam9pbihucG0ub3MuRU9MKTtcclxufTtcclxuXHJcbm5wbS51dGlscy5hZGRJbnNwZWN0aW9uKFF1ZXJ5RmlsZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtRdWVyeUZpbGV9O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIFF1ZXJ5RmlsZS5PcHRpb25zXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIHNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgYXMgcGFzc2VkIGludG8gdGhlIHtAbGluayBRdWVyeUZpbGV9IGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRlYnVnXHJcbiAqIFdoZW4gaW4gZGVidWcgbW9kZSwgdGhlIHF1ZXJ5IGZpbGUgaXMgY2hlY2tlZCBmb3IgaXRzIGxhc3QgbW9kaWZpY2F0aW9uIHRpbWUgb24gZXZlcnkgcXVlcnkgcmVxdWVzdCxcclxuICogc28gaWYgaXQgY2hhbmdlcywgdGhlIGZpbGUgaXMgcmVhZCBhZnJlc2guXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IGZvciB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCB3aGVuIGBOT0RFX0VOVmAgPSBgZGV2ZWxvcG1lbnRgLFxyXG4gKiBvciBgZmFsc2VgIG90aGVyd2lzZS5cclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufHN0cmluZ30gbWluaWZ5PWZhbHNlXHJcbiAqIFBhcnNlcyBhbmQgbWluaWZpZXMgdGhlIFNRTCB1c2luZyAkW3BnLW1pbmlmeV06XHJcbiAqIC0gYGZhbHNlYCAtIGRvIG5vdCB1c2UgJFtwZy1taW5pZnldXHJcbiAqIC0gYHRydWVgIC0gdXNlICRbcGctbWluaWZ5XSB0byBwYXJzZSBhbmQgbWluaWZ5IFNRTFxyXG4gKiAtIGAnYWZ0ZXInYCAtIHVzZSAkW3BnLW1pbmlmeV0gYWZ0ZXIgYXBwbHlpbmcgc3RhdGljIGZvcm1hdHRpbmcgcGFyYW1ldGVyc1xyXG4gKiAgIChvcHRpb24gYHBhcmFtc2ApLCBhcyBvcHBvc2VkIHRvIGJlZm9yZSBpdCAoZGVmYXVsdClcclxuICpcclxuICogSWYgb3B0aW9uIGBjb21wcmVzc2AgaXMgc2V0LCB0aGVuIHRoZSBkZWZhdWx0IGZvciBgbWluaWZ5YCBpcyBgdHJ1ZWAuXHJcbiAqXHJcbiAqIEZhaWx1cmUgdG8gcGFyc2UgU1FMIHdpbGwgcmVzdWx0IGluICRbU1FMUGFyc2luZ0Vycm9yXS5cclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBjb21wcmVzcz1mYWxzZVxyXG4gKiBTZXRzIG9wdGlvbiBgY29tcHJlc3NgIGFzIHN1cHBvcnRlZCBieSAkW3BnLW1pbmlmeV0sIHRvIHVnbGlmeSB0aGUgU1FMOlxyXG4gKiAtIGBmYWxzZWAgLSBubyBjb21wcmVzc2lvbiB0byBiZSBhcHBsaWVkLCBrZWVwIG1pbmltdW0gc3BhY2VzIGZvciBlYXNpZXIgcmVhZFxyXG4gKiAtIGB0cnVlYCAtIHJlbW92ZSBhbGwgdW5uZWNlc3Nhcnkgc3BhY2VzIGZyb20gU1FMXHJcbiAqXHJcbiAqIFRoaXMgb3B0aW9uIGhhcyBubyBtZWFuaW5nLCBpZiBgbWluaWZ5YCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLiBIb3dldmVyLCBpZiBgbWluaWZ5YCBpcyBub3RcclxuICogc3BlY2lmaWVkIGFuZCBgY29tcHJlc3NgIGlzIHNwZWNpZmllZCBhcyBgdHJ1ZWAsIHRoZW4gYG1pbmlmeWAgZGVmYXVsdHMgdG8gYHRydWVgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2FycmF5fG9iamVjdHx2YWx1ZX0gcGFyYW1zXHJcbiAqXHJcbiAqIFN0YXRpYyBmb3JtYXR0aW5nIHBhcmFtZXRlcnMgdG8gYmUgYXBwbGllZCB0byB0aGUgU1FMLCB1c2luZyB0aGUgc2FtZSBtZXRob2Qge0BsaW5rIGZvcm1hdHRpbmcuZm9ybWF0IGFzLmZvcm1hdH0sXHJcbiAqIGJ1dCB3aXRoIG9wdGlvbiBgcGFydGlhbGAgPSBgdHJ1ZWAuXHJcbiAqXHJcbiAqIE1vc3Qgb2YgdGhlIHRpbWUgcXVlcnkgZm9ybWF0dGluZyBpcyBmdWxseSBkeW5hbWljLCBhbmQgYXBwbGllZCBqdXN0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHF1ZXJ5LlxyXG4gKiBJbiBzb21lIGNhc2VzIHRob3VnaCB5b3UgbWF5IG5lZWQgdG8gcHJlLWZvcm1hdCBTUUwgd2l0aCBzdGF0aWMgdmFsdWVzLiBFeGFtcGxlcyBvZiBpdCBjYW4gYmUgYVxyXG4gKiBzY2hlbWEgbmFtZSwgb3IgYSBjb25maWd1cmFibGUgdGFibGUgbmFtZS5cclxuICpcclxuICogVGhpcyBvcHRpb24gbWFrZXMgdHdvLXN0ZXAgU1FMIGZvcm1hdHRpbmcgZWFzeTogeW91IGNhbiBwcmUtZm9ybWF0IHRoZSBTUUwgaW5pdGlhbGx5LCBhbmQgdGhlblxyXG4gKiBhcHBseSB0aGUgc2Vjb25kLXN0ZXAgZHluYW1pYyBmb3JtYXR0aW5nIHdoZW4gZXhlY3V0aW5nIHRoZSBxdWVyeS5cclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBub1dhcm5pbmdzPWZhbHNlXHJcbiAqIFN1cHByZXNzZXMgYWxsIHdhcm5pbmdzIHByb2R1Y2VkIGJ5IHRoZSBjbGFzcy4gSXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciBnZW5lcmFsIHVzZSwgb25seSBpbiBzcGVjaWZpYyB0ZXN0c1xyXG4gKiB0aGF0IG1heSByZXF1aXJlIGl0LlxyXG4gKlxyXG4gKi9cclxuIl0sIm5hbWVzIjpbIklubmVyU3RhdGUiLCJyZXF1aXJlIiwiUXVlcnlGaWxlRXJyb3IiLCJhc3NlcnQiLCJDb2xvckNvbnNvbGUiLCJucG0iLCJmcyIsIm9zIiwicGF0aCIsIm1pbmlmeSIsInV0aWxzIiwiZm9ybWF0dGluZyIsImZpbGUkcXVlcnkiLCJTeW1ib2wiLCJRdWVyeUZpbGUiLCJjb25zdHJ1Y3RvciIsImZpbGUiLCJvcHRpb25zIiwiZmlsZVBhdGgiLCJkZWJ1ZyIsImlzRGV2IiwiY29tcHJlc3MiLCJ1bmRlZmluZWQiLCJwYXJhbXMiLCJub1dhcm5pbmdzIiwiaXNUZXh0IiwiaXNBYnNvbHV0ZSIsImpvaW4iLCJzdGFydERpciIsInVzZWRQYXRoIiwiaW5zdGFuY2UiLCJ3YXJuIiwiZ2V0TG9jYWxTdGFjayIsIl9pbm5lciIsInNxbCIsImVycm9yIiwicmVhZHkiLCJtb2RUaW1lIiwicHJlcGFyZSIsInMiLCJmb3IiLCJzY29wZSIsImdsb2JhbCIsInRocm93RXJyb3JzIiwiaSIsImxhc3RNb2QiLCJzdGF0U3luYyIsIm10aW1lIiwiZ2V0VGltZSIsImUiLCJyZWFkRmlsZVN5bmMiLCJhcyIsImZvcm1hdCIsInBhcnRpYWwiLCIkcXVlcnkiLCJwcm90b3R5cGUiLCJjdGYiLCJ0b1Bvc3RncmVzIiwic2VsZiIsInJhd1R5cGUiLCJ0b1N0cmluZyIsImxldmVsIiwicGFyc2VJbnQiLCJnYXAiLCJtZXNzYWdlR2FwIiwibGluZXMiLCJwdXNoIiwidG9Kc29uIiwiRU9MIiwiYWRkSW5zcGVjdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/query-file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/query-result.js":
/*!*****************************************************!*\
  !*** ./node_modules/pg-promise/lib/query-result.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ /**\r\n * @enum {number}\r\n * @alias queryResult\r\n * @readonly\r\n * @description\r\n * **Query Result Mask**\r\n *\r\n * Binary mask that represents the number of rows expected from a query method,\r\n * used by generic {@link Database#query query} method, plus {@link Database#func func}.\r\n *\r\n * The mask is always the last optional parameter, which defaults to `queryResult.any`.\r\n *\r\n * Any combination of flags is supported, except for `one + many`.\r\n *\r\n * The type is available from the library's root: `pgp.queryResult`.\r\n *\r\n * @see {@link Database#query Database.query}, {@link Database#func Database.func}\r\n */ \nconst queryResult = {\n    /** Single row is expected, to be resolved as a single row-object. */ one: 1,\n    /** One or more rows expected, to be resolved as an array, with at least 1 row-object. */ many: 2,\n    /** Expecting no rows, to be resolved with `null`. */ none: 4,\n    /** `many|none` - any result is expected, to be resolved with an array of rows-objects. */ any: 6\n};\nmodule.exports = {\n    queryResult\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcXVlcnktcmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkM7QUFDRCxNQUFNQSxjQUFjO0lBQ2hCLG1FQUFtRSxHQUNuRUMsS0FBSztJQUNMLHVGQUF1RixHQUN2RkMsTUFBTTtJQUNOLG1EQUFtRCxHQUNuREMsTUFBTTtJQUNOLHdGQUF3RixHQUN4RkMsS0FBSztBQUNUO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUFDTjtBQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcXVlcnktcmVzdWx0LmpzPzYwMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKiBAYWxpYXMgcXVlcnlSZXN1bHRcclxuICogQHJlYWRvbmx5XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAqKlF1ZXJ5IFJlc3VsdCBNYXNrKipcclxuICpcclxuICogQmluYXJ5IG1hc2sgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2Ygcm93cyBleHBlY3RlZCBmcm9tIGEgcXVlcnkgbWV0aG9kLFxyXG4gKiB1c2VkIGJ5IGdlbmVyaWMge0BsaW5rIERhdGFiYXNlI3F1ZXJ5IHF1ZXJ5fSBtZXRob2QsIHBsdXMge0BsaW5rIERhdGFiYXNlI2Z1bmMgZnVuY30uXHJcbiAqXHJcbiAqIFRoZSBtYXNrIGlzIGFsd2F5cyB0aGUgbGFzdCBvcHRpb25hbCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIGBxdWVyeVJlc3VsdC5hbnlgLlxyXG4gKlxyXG4gKiBBbnkgY29tYmluYXRpb24gb2YgZmxhZ3MgaXMgc3VwcG9ydGVkLCBleGNlcHQgZm9yIGBvbmUgKyBtYW55YC5cclxuICpcclxuICogVGhlIHR5cGUgaXMgYXZhaWxhYmxlIGZyb20gdGhlIGxpYnJhcnkncyByb290OiBgcGdwLnF1ZXJ5UmVzdWx0YC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgRGF0YWJhc2UjcXVlcnkgRGF0YWJhc2UucXVlcnl9LCB7QGxpbmsgRGF0YWJhc2UjZnVuYyBEYXRhYmFzZS5mdW5jfVxyXG4gKi9cclxuY29uc3QgcXVlcnlSZXN1bHQgPSB7XHJcbiAgICAvKiogU2luZ2xlIHJvdyBpcyBleHBlY3RlZCwgdG8gYmUgcmVzb2x2ZWQgYXMgYSBzaW5nbGUgcm93LW9iamVjdC4gKi9cclxuICAgIG9uZTogMSxcclxuICAgIC8qKiBPbmUgb3IgbW9yZSByb3dzIGV4cGVjdGVkLCB0byBiZSByZXNvbHZlZCBhcyBhbiBhcnJheSwgd2l0aCBhdCBsZWFzdCAxIHJvdy1vYmplY3QuICovXHJcbiAgICBtYW55OiAyLFxyXG4gICAgLyoqIEV4cGVjdGluZyBubyByb3dzLCB0byBiZSByZXNvbHZlZCB3aXRoIGBudWxsYC4gKi9cclxuICAgIG5vbmU6IDQsXHJcbiAgICAvKiogYG1hbnl8bm9uZWAgLSBhbnkgcmVzdWx0IGlzIGV4cGVjdGVkLCB0byBiZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIHJvd3Mtb2JqZWN0cy4gKi9cclxuICAgIGFueTogNlxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7cXVlcnlSZXN1bHR9O1xyXG4iXSwibmFtZXMiOlsicXVlcnlSZXN1bHQiLCJvbmUiLCJtYW55Iiwibm9uZSIsImFueSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/query-result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/query.js":
/*!**********************************************!*\
  !*** ./node_modules/pg-promise/lib/query.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Events } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/pg-promise/lib/events.js\");\nconst { QueryFile } = __webpack_require__(/*! ./query-file */ \"(rsc)/./node_modules/pg-promise/lib/query-file.js\");\nconst { ServerFormatting, PreparedStatement, ParameterizedQuery } = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/pg-promise/lib/types/index.js\");\nconst { SpecialQuery } = __webpack_require__(/*! ./special-query */ \"(rsc)/./node_modules/pg-promise/lib/special-query.js\");\nconst { queryResult } = __webpack_require__(/*! ./query-result */ \"(rsc)/./node_modules/pg-promise/lib/query-result.js\");\nconst npm = {\n    util: __webpack_require__(/*! util */ \"util\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    formatting: __webpack_require__(/*! ./formatting */ \"(rsc)/./node_modules/pg-promise/lib/formatting.js\"),\n    errors: __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/pg-promise/lib/errors/index.js\"),\n    stream: __webpack_require__(/*! ./stream */ \"(rsc)/./node_modules/pg-promise/lib/stream.js\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\nconst QueryResultError = npm.errors.QueryResultError, InternalError = npm.utils.InternalError, qrec = npm.errors.queryResultErrorCode;\nconst badMask = queryResult.one | queryResult.many; // unsupported combination bit-mask;\n//////////////////////////////\n// Generic query method;\nfunction $query(ctx, query, values, qrm, config) {\n    const special = qrm instanceof SpecialQuery && qrm;\n    const $p = config.promise;\n    if (special && special.isStream) {\n        return npm.stream.call(this, ctx, query, values, config);\n    }\n    const opt = ctx.options, capSQL = opt.capSQL;\n    let error, entityType, pgFormatting = opt.pgFormatting, params = pgFormatting ? values : undefined;\n    if (typeof query === \"function\") {\n        try {\n            query = npm.formatting.resolveFunc(query, values);\n        } catch (e) {\n            error = e;\n            params = values;\n            query = npm.util.inspect(query);\n        }\n    }\n    if (!error && !query) {\n        error = new TypeError(npm.text.invalidQuery);\n    }\n    if (!error && typeof query === \"object\") {\n        if (query instanceof QueryFile) {\n            query.prepare();\n            if (query.error) {\n                error = query.error;\n                query = query.file;\n            } else {\n                query = query[QueryFile.$query];\n            }\n        } else {\n            if (\"entity\" in query) {\n                entityType = query.type;\n                query = query.entity; // query is a function name;\n            } else {\n                if (query instanceof ServerFormatting) {\n                    pgFormatting = true;\n                } else {\n                    if (\"name\" in query) {\n                        query = new PreparedStatement(query);\n                        pgFormatting = true;\n                    } else {\n                        if (\"text\" in query) {\n                            query = new ParameterizedQuery(query);\n                            pgFormatting = true;\n                        }\n                    }\n                }\n                if (query instanceof ServerFormatting && !npm.utils.isNull(values)) {\n                    query.values = values;\n                }\n            }\n        }\n    }\n    if (!error) {\n        if (!pgFormatting && !npm.utils.isText(query)) {\n            const errTxt = entityType ? entityType === \"func\" ? npm.text.invalidFunction : npm.text.invalidProc : npm.text.invalidQuery;\n            error = new TypeError(errTxt);\n        }\n        if (query instanceof ServerFormatting) {\n            const qp = query.parse();\n            if (qp instanceof Error) {\n                error = qp;\n            } else {\n                query = qp;\n            }\n        }\n    }\n    if (!error && !special) {\n        if (npm.utils.isNull(qrm)) {\n            qrm = queryResult.any; // default query result;\n        } else {\n            if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\n                error = new TypeError(npm.text.invalidMask);\n            }\n        }\n    }\n    if (!error && (!pgFormatting || entityType)) {\n        try {\n            // use 'pg-promise' implementation of values formatting;\n            if (entityType) {\n                params = undefined;\n                query = npm.formatting.formatEntity(query, values, {\n                    capSQL,\n                    type: entityType\n                });\n            } else {\n                query = npm.formatting.formatQuery(query, values);\n            }\n        } catch (e) {\n            if (entityType) {\n                let prefix = entityType === \"func\" ? \"select * from\" : \"call\";\n                if (capSQL) {\n                    prefix = prefix.toUpperCase();\n                }\n                query = prefix + \" \" + query + \"(...)\";\n            } else {\n                params = values;\n            }\n            error = e instanceof Error ? e : new npm.utils.InternalError(e);\n        }\n    }\n    return $p((resolve, reject)=>{\n        if (notifyReject()) {\n            return;\n        }\n        error = Events.query(opt, getContext());\n        if (notifyReject()) {\n            return;\n        }\n        try {\n            const start = Date.now();\n            ctx.db.client.query(query, params, (err, result)=>{\n                let data, multiResult, lastResult = result;\n                if (err) {\n                    // istanbul ignore if (auto-testing connectivity issues is too problematic)\n                    if (npm.utils.isConnectivityError(err)) {\n                        ctx.db.client.$connectionError = err;\n                    }\n                    err.query = err.query || query;\n                    err.params = err.params || params;\n                    error = err;\n                } else {\n                    multiResult = Array.isArray(result);\n                    if (multiResult) {\n                        lastResult = result[result.length - 1];\n                        for(let i = 0; i < result.length; i++){\n                            const r = result[i];\n                            makeIterable(r);\n                            error = Events.receive(opt, r.rows, r, getContext());\n                            if (error) {\n                                break;\n                            }\n                        }\n                    } else {\n                        makeIterable(result);\n                        result.duration = Date.now() - start;\n                        error = Events.receive(opt, result.rows, result, getContext());\n                    }\n                }\n                if (!error) {\n                    data = lastResult;\n                    if (special) {\n                        if (special.isMultiResult) {\n                            data = multiResult ? result : [\n                                result\n                            ]; // method .multiResult() is called\n                        }\n                    // else, method .result() is called\n                    } else {\n                        data = data.rows;\n                        const len = data.length;\n                        if (len) {\n                            if (len > 1 && qrm & queryResult.one) {\n                                // one row was expected, but returned multiple;\n                                error = new QueryResultError(qrec.multiple, lastResult, query, params);\n                            } else {\n                                if (!(qrm & (queryResult.one | queryResult.many))) {\n                                    // no data should have been returned;\n                                    error = new QueryResultError(qrec.notEmpty, lastResult, query, params);\n                                } else {\n                                    if (!(qrm & queryResult.many)) {\n                                        data = data[0];\n                                    }\n                                }\n                            }\n                        } else {\n                            // no data returned;\n                            if (qrm & queryResult.none) {\n                                if (qrm & queryResult.one) {\n                                    data = null;\n                                } else {\n                                    data = qrm & queryResult.many ? data : null;\n                                }\n                            } else {\n                                error = new QueryResultError(qrec.noData, lastResult, query, params);\n                            }\n                        }\n                    }\n                }\n                if (!notifyReject()) {\n                    resolve(data);\n                }\n            });\n        } catch (e) {\n            // this can only happen as a result of an internal failure within node-postgres,\n            // like during a sudden loss of communications, which is impossible to reproduce\n            // automatically, so removing it from the test coverage:\n            // istanbul ignore next\n            error = e;\n        }\n        function getContext() {\n            let client;\n            if (ctx.db) {\n                client = ctx.db.client;\n            } else {\n                error = new Error(npm.text.looseQuery);\n            }\n            return {\n                client,\n                query,\n                params,\n                dc: ctx.dc,\n                ctx: ctx.ctx\n            };\n        }\n        notifyReject();\n        function notifyReject() {\n            const context = getContext();\n            if (error) {\n                if (error instanceof InternalError) {\n                    error = error.error;\n                }\n                Events.error(opt, error, context);\n                reject(error);\n                return true;\n            }\n        }\n    });\n}\n// Extends Result to provide iterable for the rows;\n//\n// To be removed once the following PR is merged amd released:\n// https://github.com/brianc/node-postgres/pull/2861\nfunction makeIterable(r) {\n    r[Symbol.iterator] = function() {\n        return this.rows.values();\n    };\n}\nmodule.exports = (config)=>{\n    return function(ctx, query, values, qrm) {\n        return $query.call(this, ctx, query, values, qrm, config);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsTUFBTSxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBQ0MsU0FBUyxFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBQ0UsZ0JBQWdCLEVBQUVDLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBQyxHQUFHSixtQkFBT0EsQ0FBQztBQUMxRSxNQUFNLEVBQUNLLFlBQVksRUFBQyxHQUFHTCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUNNLFdBQVcsRUFBQyxHQUFHTixtQkFBT0EsQ0FBQztBQUU5QixNQUFNTyxNQUFNO0lBQ1JDLE1BQU1SLG1CQUFPQSxDQUFDO0lBQ2RTLE9BQU9ULG1CQUFPQSxDQUFDO0lBQ2ZVLFlBQVlWLG1CQUFPQSxDQUFDO0lBQ3BCVyxRQUFRWCxtQkFBT0EsQ0FBQztJQUNoQlksUUFBUVosbUJBQU9BLENBQUM7SUFDaEJhLE1BQU1iLG1CQUFPQSxDQUFDO0FBQ2xCO0FBRUEsTUFBTWMsbUJBQW1CUCxJQUFJSSxNQUFNLENBQUNHLGdCQUFnQixFQUNoREMsZ0JBQWdCUixJQUFJRSxLQUFLLENBQUNNLGFBQWEsRUFDdkNDLE9BQU9ULElBQUlJLE1BQU0sQ0FBQ00sb0JBQW9CO0FBRTFDLE1BQU1DLFVBQVVaLFlBQVlhLEdBQUcsR0FBR2IsWUFBWWMsSUFBSSxFQUFFLG9DQUFvQztBQUV4Riw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLFNBQVNDLE9BQU9DLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsTUFBTTtJQUUzQyxNQUFNQyxVQUFVRixlQUFlcEIsZ0JBQWdCb0I7SUFDL0MsTUFBTUcsS0FBS0YsT0FBT0csT0FBTztJQUV6QixJQUFJRixXQUFXQSxRQUFRRyxRQUFRLEVBQUU7UUFDN0IsT0FBT3ZCLElBQUlL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S0EsSUFBSUEsR0FBRztZQUNoQjtRQUNKO1FBRUE0QztRQUVBLFNBQVNBO1lBQ0wsTUFBTStCLFVBQVU5QjtZQUNoQixJQUFJaEMsT0FBTztnQkFDUCxJQUFJQSxpQkFBaUJwQixlQUFlO29CQUNoQ29CLFFBQVFBLE1BQU1BLEtBQUs7Z0JBQ3ZCO2dCQUNBcEMsT0FBT29DLEtBQUssQ0FBQ0gsS0FBS0csT0FBTzhEO2dCQUN6QmhDLE9BQU85QjtnQkFDUCxPQUFPO1lBQ1g7UUFDSjtJQUNKO0FBQ0o7QUFFQSxtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLDhEQUE4RDtBQUM5RCxvREFBb0Q7QUFDcEQsU0FBU2tELGFBQWFELENBQUM7SUFDbkJBLENBQUMsQ0FBQ2MsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDakIsT0FBTyxJQUFJLENBQUNaLElBQUksQ0FBQy9ELE1BQU07SUFDM0I7QUFDSjtBQUVBNEUsT0FBT0MsT0FBTyxHQUFHM0UsQ0FBQUE7SUFDYixPQUFPLFNBQVVKLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUc7UUFDcEMsT0FBT0osT0FBT1UsSUFBSSxDQUFDLElBQUksRUFBRVQsS0FBS0MsT0FBT0MsUUFBUUMsS0FBS0M7SUFDdEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3F1ZXJ5LmpzPzE0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtFdmVudHN9ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuY29uc3Qge1F1ZXJ5RmlsZX0gPSByZXF1aXJlKCcuL3F1ZXJ5LWZpbGUnKTtcclxuY29uc3Qge1NlcnZlckZvcm1hdHRpbmcsIFByZXBhcmVkU3RhdGVtZW50LCBQYXJhbWV0ZXJpemVkUXVlcnl9ID0gcmVxdWlyZSgnLi90eXBlcycpO1xyXG5jb25zdCB7U3BlY2lhbFF1ZXJ5fSA9IHJlcXVpcmUoJy4vc3BlY2lhbC1xdWVyeScpO1xyXG5jb25zdCB7cXVlcnlSZXN1bHR9ID0gcmVxdWlyZSgnLi9xdWVyeS1yZXN1bHQnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIHV0aWw6IHJlcXVpcmUoJ3V0aWwnKSxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJyksXHJcbiAgICBmb3JtYXR0aW5nOiByZXF1aXJlKCcuL2Zvcm1hdHRpbmcnKSxcclxuICAgIGVycm9yczogcmVxdWlyZSgnLi9lcnJvcnMnKSxcclxuICAgIHN0cmVhbTogcmVxdWlyZSgnLi9zdHJlYW0nKSxcclxuICAgIHRleHQ6IHJlcXVpcmUoJy4vdGV4dCcpXHJcbn07XHJcblxyXG5jb25zdCBRdWVyeVJlc3VsdEVycm9yID0gbnBtLmVycm9ycy5RdWVyeVJlc3VsdEVycm9yLFxyXG4gICAgSW50ZXJuYWxFcnJvciA9IG5wbS51dGlscy5JbnRlcm5hbEVycm9yLFxyXG4gICAgcXJlYyA9IG5wbS5lcnJvcnMucXVlcnlSZXN1bHRFcnJvckNvZGU7XHJcblxyXG5jb25zdCBiYWRNYXNrID0gcXVlcnlSZXN1bHQub25lIHwgcXVlcnlSZXN1bHQubWFueTsgLy8gdW5zdXBwb3J0ZWQgY29tYmluYXRpb24gYml0LW1hc2s7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gR2VuZXJpYyBxdWVyeSBtZXRob2Q7XHJcbmZ1bmN0aW9uICRxdWVyeShjdHgsIHF1ZXJ5LCB2YWx1ZXMsIHFybSwgY29uZmlnKSB7XHJcblxyXG4gICAgY29uc3Qgc3BlY2lhbCA9IHFybSBpbnN0YW5jZW9mIFNwZWNpYWxRdWVyeSAmJiBxcm07XHJcbiAgICBjb25zdCAkcCA9IGNvbmZpZy5wcm9taXNlO1xyXG5cclxuICAgIGlmIChzcGVjaWFsICYmIHNwZWNpYWwuaXNTdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gbnBtLnN0cmVhbS5jYWxsKHRoaXMsIGN0eCwgcXVlcnksIHZhbHVlcywgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcHQgPSBjdHgub3B0aW9ucyxcclxuICAgICAgICBjYXBTUUwgPSBvcHQuY2FwU1FMO1xyXG5cclxuICAgIGxldCBlcnJvciwgZW50aXR5VHlwZSxcclxuICAgICAgICBwZ0Zvcm1hdHRpbmcgPSBvcHQucGdGb3JtYXR0aW5nLFxyXG4gICAgICAgIHBhcmFtcyA9IHBnRm9ybWF0dGluZyA/IHZhbHVlcyA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcXVlcnkgPSBucG0uZm9ybWF0dGluZy5yZXNvbHZlRnVuYyhxdWVyeSwgdmFsdWVzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgcGFyYW1zID0gdmFsdWVzO1xyXG4gICAgICAgICAgICBxdWVyeSA9IG5wbS51dGlsLmluc3BlY3QocXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVycm9yICYmICFxdWVyeSkge1xyXG4gICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihucG0udGV4dC5pbnZhbGlkUXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXJyb3IgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFF1ZXJ5RmlsZSkge1xyXG4gICAgICAgICAgICBxdWVyeS5wcmVwYXJlKCk7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBxdWVyeS5lcnJvcjtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZmlsZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlbUXVlcnlGaWxlLiRxdWVyeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoJ2VudGl0eScgaW4gcXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eVR5cGUgPSBxdWVyeS50eXBlO1xyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lbnRpdHk7IC8vIHF1ZXJ5IGlzIGEgZnVuY3Rpb24gbmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFNlcnZlckZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBwZ0Zvcm1hdHRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJ25hbWUnIGluIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gbmV3IFByZXBhcmVkU3RhdGVtZW50KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGdGb3JtYXR0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3RleHQnIGluIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IG5ldyBQYXJhbWV0ZXJpemVkUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGdGb3JtYXR0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFNlcnZlckZvcm1hdHRpbmcgJiYgIW5wbS51dGlscy5pc051bGwodmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgaWYgKCFwZ0Zvcm1hdHRpbmcgJiYgIW5wbS51dGlscy5pc1RleHQocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyclR4dCA9IGVudGl0eVR5cGUgPyAoZW50aXR5VHlwZSA9PT0gJ2Z1bmMnID8gbnBtLnRleHQuaW52YWxpZEZ1bmN0aW9uIDogbnBtLnRleHQuaW52YWxpZFByb2MpIDogbnBtLnRleHQuaW52YWxpZFF1ZXJ5O1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoZXJyVHh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgU2VydmVyRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICBjb25zdCBxcCA9IHF1ZXJ5LnBhcnNlKCk7XHJcbiAgICAgICAgICAgIGlmIChxcCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IHFwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVycm9yICYmICFzcGVjaWFsKSB7XHJcbiAgICAgICAgaWYgKG5wbS51dGlscy5pc051bGwocXJtKSkge1xyXG4gICAgICAgICAgICBxcm0gPSBxdWVyeVJlc3VsdC5hbnk7IC8vIGRlZmF1bHQgcXVlcnkgcmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChxcm0gIT09IHBhcnNlSW50KHFybSkgfHwgKHFybSAmIGJhZE1hc2spID09PSBiYWRNYXNrIHx8IHFybSA8IDEgfHwgcXJtID4gNikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG5wbS50ZXh0LmludmFsaWRNYXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVycm9yICYmICghcGdGb3JtYXR0aW5nIHx8IGVudGl0eVR5cGUpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gdXNlICdwZy1wcm9taXNlJyBpbXBsZW1lbnRhdGlvbiBvZiB2YWx1ZXMgZm9ybWF0dGluZztcclxuICAgICAgICAgICAgaWYgKGVudGl0eVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gbnBtLmZvcm1hdHRpbmcuZm9ybWF0RW50aXR5KHF1ZXJ5LCB2YWx1ZXMsIHtjYXBTUUwsIHR5cGU6IGVudGl0eVR5cGV9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gbnBtLmZvcm1hdHRpbmcuZm9ybWF0UXVlcnkocXVlcnksIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJlZml4ID0gZW50aXR5VHlwZSA9PT0gJ2Z1bmMnID8gJ3NlbGVjdCAqIGZyb20nIDogJ2NhbGwnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhcFNRTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBwcmVmaXggKyAnICcgKyBxdWVyeSArICcoLi4uKSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXJyb3IgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IG5wbS51dGlscy5JbnRlcm5hbEVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJHAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgICBpZiAobm90aWZ5UmVqZWN0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcnJvciA9IEV2ZW50cy5xdWVyeShvcHQsIGdldENvbnRleHQoKSk7XHJcbiAgICAgICAgaWYgKG5vdGlmeVJlamVjdCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjdHguZGIuY2xpZW50LnF1ZXJ5KHF1ZXJ5LCBwYXJhbXMsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEsIG11bHRpUmVzdWx0LCBsYXN0UmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZiAoYXV0by10ZXN0aW5nIGNvbm5lY3Rpdml0eSBpc3N1ZXMgaXMgdG9vIHByb2JsZW1hdGljKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChucG0udXRpbHMuaXNDb25uZWN0aXZpdHlFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kYi5jbGllbnQuJGNvbm5lY3Rpb25FcnJvciA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnF1ZXJ5ID0gZXJyLnF1ZXJ5IHx8IHF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5wYXJhbXMgPSBlcnIucGFyYW1zIHx8IHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlSZXN1bHQgPSBBcnJheS5pc0FycmF5KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHJlc3VsdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VJdGVyYWJsZShyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXZlbnRzLnJlY2VpdmUob3B0LCByLnJvd3MsIHIsIGdldENvbnRleHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VJdGVyYWJsZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gRXZlbnRzLnJlY2VpdmUob3B0LCByZXN1bHQucm93cywgcmVzdWx0LCBnZXRDb250ZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbGFzdFJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbC5pc011bHRpUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbXVsdGlSZXN1bHQgPyByZXN1bHQgOiBbcmVzdWx0XTsgLy8gbWV0aG9kIC5tdWx0aVJlc3VsdCgpIGlzIGNhbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UsIG1ldGhvZCAucmVzdWx0KCkgaXMgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEucm93cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxICYmIHFybSAmIHF1ZXJ5UmVzdWx0Lm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSByb3cgd2FzIGV4cGVjdGVkLCBidXQgcmV0dXJuZWQgbXVsdGlwbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgUXVlcnlSZXN1bHRFcnJvcihxcmVjLm11bHRpcGxlLCBsYXN0UmVzdWx0LCBxdWVyeSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocXJtICYgKHF1ZXJ5UmVzdWx0Lm9uZSB8IHF1ZXJ5UmVzdWx0Lm1hbnkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBkYXRhIHNob3VsZCBoYXZlIGJlZW4gcmV0dXJuZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IFF1ZXJ5UmVzdWx0RXJyb3IocXJlYy5ub3RFbXB0eSwgbGFzdFJlc3VsdCwgcXVlcnksIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocXJtICYgcXVlcnlSZXN1bHQubWFueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZGF0YSByZXR1cm5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxcm0gJiBxdWVyeVJlc3VsdC5ub25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHFybSAmIHF1ZXJ5UmVzdWx0Lm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcXJtICYgcXVlcnlSZXN1bHQubWFueSA/IGRhdGEgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgUXVlcnlSZXN1bHRFcnJvcihxcmVjLm5vRGF0YSwgbGFzdFJlc3VsdCwgcXVlcnksIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFub3RpZnlSZWplY3QoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBjYW4gb25seSBoYXBwZW4gYXMgYSByZXN1bHQgb2YgYW4gaW50ZXJuYWwgZmFpbHVyZSB3aXRoaW4gbm9kZS1wb3N0Z3JlcyxcclxuICAgICAgICAgICAgLy8gbGlrZSBkdXJpbmcgYSBzdWRkZW4gbG9zcyBvZiBjb21tdW5pY2F0aW9ucywgd2hpY2ggaXMgaW1wb3NzaWJsZSB0byByZXByb2R1Y2VcclxuICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSwgc28gcmVtb3ZpbmcgaXQgZnJvbSB0aGUgdGVzdCBjb3ZlcmFnZTpcclxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcclxuICAgICAgICAgICAgZXJyb3IgPSBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgICAgICAgICAgbGV0IGNsaWVudDtcclxuICAgICAgICAgICAgaWYgKGN0eC5kYikge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50ID0gY3R4LmRiLmNsaWVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG5wbS50ZXh0Lmxvb3NlUXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQsIHF1ZXJ5LCBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBkYzogY3R4LmRjLFxyXG4gICAgICAgICAgICAgICAgY3R4OiBjdHguY3R4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub3RpZnlSZWplY3QoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbm90aWZ5UmVqZWN0KCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0Q29udGV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEludGVybmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRXZlbnRzLmVycm9yKG9wdCwgZXJyb3IsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIEV4dGVuZHMgUmVzdWx0IHRvIHByb3ZpZGUgaXRlcmFibGUgZm9yIHRoZSByb3dzO1xyXG4vL1xyXG4vLyBUbyBiZSByZW1vdmVkIG9uY2UgdGhlIGZvbGxvd2luZyBQUiBpcyBtZXJnZWQgYW1kIHJlbGVhc2VkOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYnJpYW5jL25vZGUtcG9zdGdyZXMvcHVsbC8yODYxXHJcbmZ1bmN0aW9uIG1ha2VJdGVyYWJsZShyKSB7XHJcbiAgICByW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy52YWx1ZXMoKTtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29uZmlnID0+IHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY3R4LCBxdWVyeSwgdmFsdWVzLCBxcm0pIHtcclxuICAgICAgICByZXR1cm4gJHF1ZXJ5LmNhbGwodGhpcywgY3R4LCBxdWVyeSwgdmFsdWVzLCBxcm0sIGNvbmZpZyk7XHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiRXZlbnRzIiwicmVxdWlyZSIsIlF1ZXJ5RmlsZSIsIlNlcnZlckZvcm1hdHRpbmciLCJQcmVwYXJlZFN0YXRlbWVudCIsIlBhcmFtZXRlcml6ZWRRdWVyeSIsIlNwZWNpYWxRdWVyeSIsInF1ZXJ5UmVzdWx0IiwibnBtIiwidXRpbCIsInV0aWxzIiwiZm9ybWF0dGluZyIsImVycm9ycyIsInN0cmVhbSIsInRleHQiLCJRdWVyeVJlc3VsdEVycm9yIiwiSW50ZXJuYWxFcnJvciIsInFyZWMiLCJxdWVyeVJlc3VsdEVycm9yQ29kZSIsImJhZE1hc2siLCJvbmUiLCJtYW55IiwiJHF1ZXJ5IiwiY3R4IiwicXVlcnkiLCJ2YWx1ZXMiLCJxcm0iLCJjb25maWciLCJzcGVjaWFsIiwiJHAiLCJwcm9taXNlIiwiaXNTdHJlYW0iLCJjYWxsIiwib3B0Iiwib3B0aW9ucyIsImNhcFNRTCIsImVycm9yIiwiZW50aXR5VHlwZSIsInBnRm9ybWF0dGluZyIsInBhcmFtcyIsInVuZGVmaW5lZCIsInJlc29sdmVGdW5jIiwiZSIsImluc3BlY3QiLCJUeXBlRXJyb3IiLCJpbnZhbGlkUXVlcnkiLCJwcmVwYXJlIiwiZmlsZSIsInR5cGUiLCJlbnRpdHkiLCJpc051bGwiLCJpc1RleHQiLCJlcnJUeHQiLCJpbnZhbGlkRnVuY3Rpb24iLCJpbnZhbGlkUHJvYyIsInFwIiwicGFyc2UiLCJFcnJvciIsImFueSIsInBhcnNlSW50IiwiaW52YWxpZE1hc2siLCJmb3JtYXRFbnRpdHkiLCJmb3JtYXRRdWVyeSIsInByZWZpeCIsInRvVXBwZXJDYXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5vdGlmeVJlamVjdCIsImdldENvbnRleHQiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJkYiIsImNsaWVudCIsImVyciIsInJlc3VsdCIsImRhdGEiLCJtdWx0aVJlc3VsdCIsImxhc3RSZXN1bHQiLCJpc0Nvbm5lY3Rpdml0eUVycm9yIiwiJGNvbm5lY3Rpb25FcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImkiLCJyIiwibWFrZUl0ZXJhYmxlIiwicmVjZWl2ZSIsInJvd3MiLCJkdXJhdGlvbiIsImlzTXVsdGlSZXN1bHQiLCJsZW4iLCJtdWx0aXBsZSIsIm5vdEVtcHR5Iiwibm9uZSIsIm5vRGF0YSIsImxvb3NlUXVlcnkiLCJkYyIsImNvbnRleHQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/special-query.js":
/*!******************************************************!*\
  !*** ./node_modules/pg-promise/lib/special-query.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst specialQueryType = {\n    result: 0,\n    multiResult: 1,\n    stream: 2\n};\nclass SpecialQuery {\n    constructor(type){\n        this.isResult = type === specialQueryType.result; // type used implicitly\n        this.isStream = type === specialQueryType.stream;\n        this.isMultiResult = type === specialQueryType.multiResult;\n    }\n}\nconst cache = {\n    resultQuery: new SpecialQuery(specialQueryType.result),\n    multiResultQuery: new SpecialQuery(specialQueryType.multiResult),\n    streamQuery: new SpecialQuery(specialQueryType.stream)\n};\nmodule.exports = Object.assign({\n    SpecialQuery\n}, cache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvc3BlY2lhbC1xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTUEsbUJBQW1CO0lBQ3JCQyxRQUFRO0lBQ1JDLGFBQWE7SUFDYkMsUUFBUTtBQUNaO0FBRUEsTUFBTUM7SUFDRkMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdELFNBQVNOLGlCQUFpQkMsTUFBTSxFQUFFLHVCQUF1QjtRQUN6RSxJQUFJLENBQUNPLFFBQVEsR0FBR0YsU0FBU04saUJBQWlCRyxNQUFNO1FBQ2hELElBQUksQ0FBQ00sYUFBYSxHQUFHSCxTQUFTTixpQkFBaUJFLFdBQVc7SUFDOUQ7QUFDSjtBQUVBLE1BQU1RLFFBQVE7SUFDVkMsYUFBYSxJQUFJUCxhQUFhSixpQkFBaUJDLE1BQU07SUFDckRXLGtCQUFrQixJQUFJUixhQUFhSixpQkFBaUJFLFdBQVc7SUFDL0RXLGFBQWEsSUFBSVQsYUFBYUosaUJBQWlCRyxNQUFNO0FBQ3pEO0FBRUFXLE9BQU9DLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBQUNiO0FBQVksR0FBR00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi9zcGVjaWFsLXF1ZXJ5LmpzPzk4MTQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHNwZWNpYWxRdWVyeVR5cGUgPSB7XHJcbiAgICByZXN1bHQ6IDAsXHJcbiAgICBtdWx0aVJlc3VsdDogMSxcclxuICAgIHN0cmVhbTogMlxyXG59O1xyXG5cclxuY2xhc3MgU3BlY2lhbFF1ZXJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcclxuICAgICAgICB0aGlzLmlzUmVzdWx0ID0gdHlwZSA9PT0gc3BlY2lhbFF1ZXJ5VHlwZS5yZXN1bHQ7IC8vIHR5cGUgdXNlZCBpbXBsaWNpdGx5XHJcbiAgICAgICAgdGhpcy5pc1N0cmVhbSA9IHR5cGUgPT09IHNwZWNpYWxRdWVyeVR5cGUuc3RyZWFtO1xyXG4gICAgICAgIHRoaXMuaXNNdWx0aVJlc3VsdCA9IHR5cGUgPT09IHNwZWNpYWxRdWVyeVR5cGUubXVsdGlSZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGNhY2hlID0ge1xyXG4gICAgcmVzdWx0UXVlcnk6IG5ldyBTcGVjaWFsUXVlcnkoc3BlY2lhbFF1ZXJ5VHlwZS5yZXN1bHQpLFxyXG4gICAgbXVsdGlSZXN1bHRRdWVyeTogbmV3IFNwZWNpYWxRdWVyeShzcGVjaWFsUXVlcnlUeXBlLm11bHRpUmVzdWx0KSxcclxuICAgIHN0cmVhbVF1ZXJ5OiBuZXcgU3BlY2lhbFF1ZXJ5KHNwZWNpYWxRdWVyeVR5cGUuc3RyZWFtKVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKHtTcGVjaWFsUXVlcnl9LCBjYWNoZSk7XHJcbiJdLCJuYW1lcyI6WyJzcGVjaWFsUXVlcnlUeXBlIiwicmVzdWx0IiwibXVsdGlSZXN1bHQiLCJzdHJlYW0iLCJTcGVjaWFsUXVlcnkiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJpc1Jlc3VsdCIsImlzU3RyZWFtIiwiaXNNdWx0aVJlc3VsdCIsImNhY2hlIiwicmVzdWx0UXVlcnkiLCJtdWx0aVJlc3VsdFF1ZXJ5Iiwic3RyZWFtUXVlcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiT2JqZWN0IiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/special-query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/stream.js":
/*!***********************************************!*\
  !*** ./node_modules/pg-promise/lib/stream.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Events } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/pg-promise/lib/events.js\");\nconst npm = {\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\n////////////////////////////////////////////\n// Streams query data into any destination,\n// with the help of pg-query-stream library.\nfunction $stream(ctx, qs, initCB, config) {\n    const $p = config.promise;\n    // istanbul ignore next:\n    // we do not provide code coverage for the Native Bindings specifics\n    if (ctx.options.pgNative) {\n        return $p.reject(new Error(npm.text.nativeStreaming));\n    }\n    // Stream class was renamed again, see the following issue:\n    // https://github.com/brianc/node-postgres/issues/2412\n    if (!qs || !qs.constructor || qs.constructor.name !== \"QueryStream\") {\n        // invalid or missing stream object;\n        return $p.reject(new TypeError(npm.text.invalidStream));\n    }\n    if (qs._reading || qs._closed) {\n        // stream object is in the wrong state;\n        return $p.reject(new Error(npm.text.invalidStreamState));\n    }\n    if (typeof initCB !== \"function\") {\n        // parameter `initCB` must be passed as the initialization callback;\n        return $p.reject(new TypeError(npm.text.invalidStreamCB));\n    }\n    let error = Events.query(ctx.options, getContext());\n    if (error) {\n        error = getError(error);\n        Events.error(ctx.options, error, getContext());\n        return $p.reject(error);\n    }\n    const stream = ctx.db.client.query(qs);\n    stream.on(\"data\", onData);\n    stream.on(\"error\", onError);\n    stream.on(\"end\", onEnd);\n    try {\n        initCB.call(this, stream); // the stream must be initialized during the call;\n    } catch (e) {\n        release();\n        error = getError(e);\n        Events.error(ctx.options, error, getContext());\n        return $p.reject(error);\n    }\n    const start = Date.now();\n    let resolve, reject, nRows = 0;\n    function onData(data) {\n        nRows++;\n        error = Events.receive(ctx.options, [\n            data\n        ], undefined, getContext());\n        if (error) {\n            onError(error);\n        }\n    }\n    function onError(e) {\n        release();\n        stream.destroy();\n        e = getError(e);\n        Events.error(ctx.options, e, getContext());\n        reject(e);\n    }\n    function onEnd() {\n        release();\n        resolve({\n            processed: nRows,\n            duration: Date.now() - start // duration, in milliseconds;\n        });\n    }\n    function release() {\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"error\", onError);\n        stream.removeListener(\"end\", onEnd);\n    }\n    function getError(e) {\n        return e instanceof npm.utils.InternalError ? e.error : e;\n    }\n    function getContext() {\n        let client;\n        if (ctx.db) {\n            client = ctx.db.client;\n        } else {\n            error = new Error(npm.text.looseQuery);\n        }\n        return {\n            client,\n            dc: ctx.dc,\n            query: qs.cursor.text,\n            params: qs.cursor.values,\n            ctx: ctx.ctx\n        };\n    }\n    return $p((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n}\nmodule.exports = $stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLE1BQU0sRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUV6QixNQUFNQyxNQUFNO0lBQ1JDLE9BQU9GLG1CQUFPQSxDQUFDO0lBQ2ZHLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ2xCO0FBRUEsNENBQTRDO0FBQzVDLDJDQUEyQztBQUMzQyw0Q0FBNEM7QUFDNUMsU0FBU0ksUUFBUUMsR0FBRyxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUVwQyxNQUFNQyxLQUFLRCxPQUFPRSxPQUFPO0lBRXpCLHdCQUF3QjtJQUN4QixvRUFBb0U7SUFDcEUsSUFBSUwsSUFBSU0sT0FBTyxDQUFDQyxRQUFRLEVBQUU7UUFDdEIsT0FBT0gsR0FBR0ksTUFBTSxDQUFDLElBQUlDLE1BQU1iLElBQUlFLElBQUksQ0FBQ1ksZUFBZTtJQUN2RDtJQUNBLDJEQUEyRDtJQUMzRCxzREFBc0Q7SUFDdEQsSUFBSSxDQUFDVCxNQUFNLENBQUNBLEdBQUdVLFdBQVcsSUFBSVYsR0FBR1UsV0FBVyxDQUFDQyxJQUFJLEtBQUssZUFBZTtRQUNqRSxvQ0FBb0M7UUFDcEMsT0FBT1IsR0FBR0ksTUFBTSxDQUFDLElBQUlLLFVBQVVqQixJQUFJRSxJQUFJLENBQUNnQixhQUFhO0lBQ3pEO0lBQ0EsSUFBSWIsR0FBR2MsUUFBUSxJQUFJZCxHQUFHZSxPQUFPLEVBQUU7UUFDM0IsdUNBQXVDO1FBQ3ZDLE9BQU9aLEdBQUdJLE1BQU0sQ0FBQyxJQUFJQyxNQUFNYixJQUFJRSxJQUFJLENBQUNtQixrQkFBa0I7SUFDMUQ7SUFDQSxJQUFJLE9BQU9mLFdBQVcsWUFBWTtRQUM5QixvRUFBb0U7UUFDcEUsT0FBT0UsR0FBR0ksTUFBTSxDQUFDLElBQUlLLFVBQVVqQixJQUFJRSxJQUFJLENBQUNvQixlQUFlO0lBQzNEO0lBRUEsSUFBSUMsUUFBUXpCLE9BQU8wQixLQUFLLENBQUNwQixJQUFJTSxPQUFPLEVBQUVlO0lBRXRDLElBQUlGLE9BQU87UUFDUEEsUUFBUUcsU0FBU0g7UUFDakJ6QixPQUFPeUIsS0FBSyxDQUFDbkIsSUFBSU0sT0FBTyxFQUFFYSxPQUFPRTtRQUNqQyxPQUFPakIsR0FBR0ksTUFBTSxDQUFDVztJQUNyQjtJQUVBLE1BQU1JLFNBQVN2QixJQUFJd0IsRUFBRSxDQUFDQyxNQUFNLENBQUNMLEtBQUssQ0FBQ25CO0lBRW5Dc0IsT0FBT0csRUFBRSxDQUFDLFFBQVFDO0lBQ2xCSixPQUFPRyxFQUFFLENBQUMsU0FBU0U7SUFDbkJMLE9BQU9HLEVBQUUsQ0FBQyxPQUFPRztJQUVqQixJQUFJO1FBQ0EzQixPQUFPNEIsSUFBSSxDQUFDLElBQUksRUFBRVAsU0FBUyxrREFBa0Q7SUFDakYsRUFBRSxPQUFPUSxHQUFHO1FBQ1JDO1FBQ0FiLFFBQVFHLFNBQVNTO1FBQ2pCckMsT0FBT3lCLEtBQUssQ0FBQ25CLElBQUlNLE9BQU8sRUFBRWEsT0FBT0U7UUFDakMsT0FBT2pCLEdBQUdJLE1BQU0sQ0FBQ1c7SUFDckI7SUFFQSxNQUFNYyxRQUFRQyxLQUFLQyxHQUFHO0lBQ3RCLElBQUlDLFNBQVM1QixRQUFRNkIsUUFBUTtJQUU3QixTQUFTVixPQUFPVyxJQUFJO1FBQ2hCRDtRQUNBbEIsUUFBUXpCLE9BQU82QyxPQUFPLENBQUN2QyxJQUFJTSxPQUFPLEVBQUU7WUFBQ2dDO1NBQUssRUFBRUUsV0FBV25CO1FBQ3ZELElBQUlGLE9BQU87WUFDUFMsUUFBUVQ7UUFDWjtJQUNKO0lBRUEsU0FBU1MsUUFBUUcsQ0FBQztRQUNkQztRQUNBVCxPQUFPa0IsT0FBTztRQUNkVixJQUFJVCxTQUFTUztRQUNickMsT0FBT3lCLEtBQUssQ0FBQ25CLElBQUlNLE9BQU8sRUFBRXlCLEdBQUdWO1FBQzdCYixPQUFPdUI7SUFDWDtJQUVBLFNBQVNGO1FBQ0xHO1FBQ0FJLFFBQVE7WUFDSk0sV0FBV0w7WUFDWE0sVUFBVVQsS0FBS0MsR0FBRyxLQUFLRixNQUFNLDZCQUE2QjtRQUM5RDtJQUNKO0lBRUEsU0FBU0Q7UUFDTFQsT0FBT3FCLGNBQWMsQ0FBQyxRQUFRakI7UUFDOUJKLE9BQU9xQixjQUFjLENBQUMsU0FBU2hCO1FBQy9CTCxPQUFPcUIsY0FBYyxDQUFDLE9BQU9mO0lBQ2pDO0lBRUEsU0FBU1AsU0FBU1MsQ0FBQztRQUNmLE9BQU9BLGFBQWFuQyxJQUFJQyxLQUFLLENBQUNnRCxhQUFhLEdBQUdkLEVBQUVaLEtBQUssR0FBR1k7SUFDNUQ7SUFFQSxTQUFTVjtRQUNMLElBQUlJO1FBQ0osSUFBSXpCLElBQUl3QixFQUFFLEVBQUU7WUFDUkMsU0FBU3pCLElBQUl3QixFQUFFLENBQUNDLE1BQU07UUFDMUIsT0FBTztZQUNITixRQUFRLElBQUlWLE1BQU1iLElBQUlFLElBQUksQ0FBQ2dELFVBQVU7UUFDekM7UUFDQSxPQUFPO1lBQ0hyQjtZQUNBc0IsSUFBSS9DLElBQUkrQyxFQUFFO1lBQ1YzQixPQUFPbkIsR0FBRytDLE1BQU0sQ0FBQ2xELElBQUk7WUFDckJtRCxRQUFRaEQsR0FBRytDLE1BQU0sQ0FBQ0UsTUFBTTtZQUN4QmxELEtBQUtBLElBQUlBLEdBQUc7UUFDaEI7SUFDSjtJQUVBLE9BQU9JLEdBQUcsQ0FBQytDLEtBQUtDO1FBQ1poQixVQUFVZTtRQUNWM0MsU0FBUzRDO0lBQ2I7QUFFSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUd2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3N0cmVhbS5qcz9lZmU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7RXZlbnRzfSA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XHJcblxyXG5jb25zdCBucG0gPSB7XHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpLFxyXG4gICAgdGV4dDogcmVxdWlyZSgnLi90ZXh0JylcclxufTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFN0cmVhbXMgcXVlcnkgZGF0YSBpbnRvIGFueSBkZXN0aW5hdGlvbixcclxuLy8gd2l0aCB0aGUgaGVscCBvZiBwZy1xdWVyeS1zdHJlYW0gbGlicmFyeS5cclxuZnVuY3Rpb24gJHN0cmVhbShjdHgsIHFzLCBpbml0Q0IsIGNvbmZpZykge1xyXG5cclxuICAgIGNvbnN0ICRwID0gY29uZmlnLnByb21pc2U7XHJcblxyXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6XHJcbiAgICAvLyB3ZSBkbyBub3QgcHJvdmlkZSBjb2RlIGNvdmVyYWdlIGZvciB0aGUgTmF0aXZlIEJpbmRpbmdzIHNwZWNpZmljc1xyXG4gICAgaWYgKGN0eC5vcHRpb25zLnBnTmF0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuICRwLnJlamVjdChuZXcgRXJyb3IobnBtLnRleHQubmF0aXZlU3RyZWFtaW5nKSk7XHJcbiAgICB9XHJcbiAgICAvLyBTdHJlYW0gY2xhc3Mgd2FzIHJlbmFtZWQgYWdhaW4sIHNlZSB0aGUgZm9sbG93aW5nIGlzc3VlOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyaWFuYy9ub2RlLXBvc3RncmVzL2lzc3Vlcy8yNDEyXHJcbiAgICBpZiAoIXFzIHx8ICFxcy5jb25zdHJ1Y3RvciB8fCBxcy5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUXVlcnlTdHJlYW0nKSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCBvciBtaXNzaW5nIHN0cmVhbSBvYmplY3Q7XHJcbiAgICAgICAgcmV0dXJuICRwLnJlamVjdChuZXcgVHlwZUVycm9yKG5wbS50ZXh0LmludmFsaWRTdHJlYW0pKTtcclxuICAgIH1cclxuICAgIGlmIChxcy5fcmVhZGluZyB8fCBxcy5fY2xvc2VkKSB7XHJcbiAgICAgICAgLy8gc3RyZWFtIG9iamVjdCBpcyBpbiB0aGUgd3Jvbmcgc3RhdGU7XHJcbiAgICAgICAgcmV0dXJuICRwLnJlamVjdChuZXcgRXJyb3IobnBtLnRleHQuaW52YWxpZFN0cmVhbVN0YXRlKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGluaXRDQiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIHBhcmFtZXRlciBgaW5pdENCYCBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgaW5pdGlhbGl6YXRpb24gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuICRwLnJlamVjdChuZXcgVHlwZUVycm9yKG5wbS50ZXh0LmludmFsaWRTdHJlYW1DQikpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlcnJvciA9IEV2ZW50cy5xdWVyeShjdHgub3B0aW9ucywgZ2V0Q29udGV4dCgpKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvciA9IGdldEVycm9yKGVycm9yKTtcclxuICAgICAgICBFdmVudHMuZXJyb3IoY3R4Lm9wdGlvbnMsIGVycm9yLCBnZXRDb250ZXh0KCkpO1xyXG4gICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cmVhbSA9IGN0eC5kYi5jbGllbnQucXVlcnkocXMpO1xyXG5cclxuICAgIHN0cmVhbS5vbignZGF0YScsIG9uRGF0YSk7XHJcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGluaXRDQi5jYWxsKHRoaXMsIHN0cmVhbSk7IC8vIHRoZSBzdHJlYW0gbXVzdCBiZSBpbml0aWFsaXplZCBkdXJpbmcgdGhlIGNhbGw7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmVsZWFzZSgpO1xyXG4gICAgICAgIGVycm9yID0gZ2V0RXJyb3IoZSk7XHJcbiAgICAgICAgRXZlbnRzLmVycm9yKGN0eC5vcHRpb25zLCBlcnJvciwgZ2V0Q29udGV4dCgpKTtcclxuICAgICAgICByZXR1cm4gJHAucmVqZWN0KGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0LCBuUm93cyA9IDA7XHJcblxyXG4gICAgZnVuY3Rpb24gb25EYXRhKGRhdGEpIHtcclxuICAgICAgICBuUm93cysrO1xyXG4gICAgICAgIGVycm9yID0gRXZlbnRzLnJlY2VpdmUoY3R4Lm9wdGlvbnMsIFtkYXRhXSwgdW5kZWZpbmVkLCBnZXRDb250ZXh0KCkpO1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XHJcbiAgICAgICAgcmVsZWFzZSgpO1xyXG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XHJcbiAgICAgICAgZSA9IGdldEVycm9yKGUpO1xyXG4gICAgICAgIEV2ZW50cy5lcnJvcihjdHgub3B0aW9ucywgZSwgZ2V0Q29udGV4dCgpKTtcclxuICAgICAgICByZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25FbmQoKSB7XHJcbiAgICAgICAgcmVsZWFzZSgpO1xyXG4gICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICBwcm9jZXNzZWQ6IG5Sb3dzLCAvLyB0b3RhbCBudW1iZXIgb2Ygcm93cyBwcm9jZXNzZWQ7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnQgLy8gZHVyYXRpb24sIGluIG1pbGxpc2Vjb25kcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWxlYXNlKCkge1xyXG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XHJcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVycm9yKGUpIHtcclxuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIG5wbS51dGlscy5JbnRlcm5hbEVycm9yID8gZS5lcnJvciA6IGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgICAgICBsZXQgY2xpZW50O1xyXG4gICAgICAgIGlmIChjdHguZGIpIHtcclxuICAgICAgICAgICAgY2xpZW50ID0gY3R4LmRiLmNsaWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihucG0udGV4dC5sb29zZVF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2xpZW50LFxyXG4gICAgICAgICAgICBkYzogY3R4LmRjLFxyXG4gICAgICAgICAgICBxdWVyeTogcXMuY3Vyc29yLnRleHQsXHJcbiAgICAgICAgICAgIHBhcmFtczogcXMuY3Vyc29yLnZhbHVlcyxcclxuICAgICAgICAgICAgY3R4OiBjdHguY3R4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJHAoKHJlcywgcmVqKSA9PiB7XHJcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcclxuICAgICAgICByZWplY3QgPSByZWo7XHJcbiAgICB9KTtcclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gJHN0cmVhbTtcclxuIl0sIm5hbWVzIjpbIkV2ZW50cyIsInJlcXVpcmUiLCJucG0iLCJ1dGlscyIsInRleHQiLCIkc3RyZWFtIiwiY3R4IiwicXMiLCJpbml0Q0IiLCJjb25maWciLCIkcCIsInByb21pc2UiLCJvcHRpb25zIiwicGdOYXRpdmUiLCJyZWplY3QiLCJFcnJvciIsIm5hdGl2ZVN0cmVhbWluZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIlR5cGVFcnJvciIsImludmFsaWRTdHJlYW0iLCJfcmVhZGluZyIsIl9jbG9zZWQiLCJpbnZhbGlkU3RyZWFtU3RhdGUiLCJpbnZhbGlkU3RyZWFtQ0IiLCJlcnJvciIsInF1ZXJ5IiwiZ2V0Q29udGV4dCIsImdldEVycm9yIiwic3RyZWFtIiwiZGIiLCJjbGllbnQiLCJvbiIsIm9uRGF0YSIsIm9uRXJyb3IiLCJvbkVuZCIsImNhbGwiLCJlIiwicmVsZWFzZSIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInJlc29sdmUiLCJuUm93cyIsImRhdGEiLCJyZWNlaXZlIiwidW5kZWZpbmVkIiwiZGVzdHJveSIsInByb2Nlc3NlZCIsImR1cmF0aW9uIiwicmVtb3ZlTGlzdGVuZXIiLCJJbnRlcm5hbEVycm9yIiwibG9vc2VRdWVyeSIsImRjIiwiY3Vyc29yIiwicGFyYW1zIiwidmFsdWVzIiwicmVzIiwicmVqIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/task.js":
/*!*********************************************!*\
  !*** ./node_modules/pg-promise/lib/task.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { Events } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/pg-promise/lib/events.js\");\nconst npm = {\n    spex: __webpack_require__(/*! spex */ \"(rsc)/./node_modules/spex/lib/index.js\"),\n    utils: __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    mode: __webpack_require__(/*! ./tx-mode */ \"(rsc)/./node_modules/pg-promise/lib/tx-mode.js\"),\n    query: __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/pg-promise/lib/query.js\"),\n    text: __webpack_require__(/*! ./text */ \"(rsc)/./node_modules/pg-promise/lib/text.js\")\n};\n/**\r\n * @interface Task\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n *\r\n * The type isn't available directly, it can only be created via methods {@link Database#task Database.task}, {@link Database#tx Database.tx},\r\n * or their derivations.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * Each task/transaction manages the connection automatically. When executed on the root {@link Database} object, the connection\r\n * is allocated from the pool, and once the method's callback has finished, the connection is released back to the pool.\r\n * However, when invoked inside another task or transaction, the method reuses the parent connection.\r\n *\r\n * @see\r\n * {@link Task#ctx ctx},\r\n * {@link Task#batch batch},\r\n * {@link Task#sequence sequence},\r\n * {@link Task#page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = Task Context;\r\n *       return t.one('select * from users where id=$1', 123)\r\n *           .then(user => {\r\n *               return t.any('select * from events where login=$1', user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */ function Task(ctx, tag, isTX, config) {\n    const $p = config.promise;\n    /**\r\n     * @member {TaskContext} Task#ctx\r\n     * @readonly\r\n     * @description\r\n     * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n     *\r\n     * @see event {@link event:query query}\r\n     *\r\n     * @example\r\n     *\r\n     * db.task(t => {\r\n     *     return t.ctx; // task context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Task Duration:', ctx.duration);\r\n     *     });\r\n     *\r\n     * @example\r\n     *\r\n     * db.tx(t => {\r\n     *     return t.ctx; // transaction context object\r\n     * })\r\n     *     .then(ctx => {\r\n     *         console.log('Transaction Duration:', ctx.duration);\r\n     *     });\r\n     */ this.ctx = ctx.ctx = {}; // task context object;\n    npm.utils.addReadProp(this.ctx, \"isTX\", isTX);\n    if (\"context\" in ctx) {\n        npm.utils.addReadProp(this.ctx, \"context\", ctx.context);\n    }\n    npm.utils.addReadProp(this.ctx, \"connected\", !ctx.db);\n    npm.utils.addReadProp(this.ctx, \"tag\", tag);\n    npm.utils.addReadProp(this.ctx, \"dc\", ctx.dc);\n    npm.utils.addReadProp(this.ctx, \"level\", ctx.level);\n    npm.utils.addReadProp(this.ctx, \"inTransaction\", ctx.inTransaction);\n    if (isTX) {\n        npm.utils.addReadProp(this.ctx, \"txLevel\", ctx.txLevel);\n    }\n    npm.utils.addReadProp(this.ctx, \"parent\", ctx.parentCtx);\n    // generic query method;\n    this.query = function(query, values, qrm) {\n        if (!ctx.db) {\n            return $p.reject(new Error(npm.text.looseQuery));\n        }\n        return config.$npm.query.call(this, ctx, query, values, qrm);\n    };\n    /**\r\n     * @deprecated\r\n     * Consider using <b>async/await</b> syntax instead, or if you must have\r\n     * pre-generated promises, then $[Promise.allSettled].\r\n     *\r\n     * @method Task#batch\r\n     * @description\r\n     * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n     *\r\n     * For complete method documentation see $[spex.batch].\r\n     *\r\n     * @param {array} values\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.cb]\r\n     *\r\n     * @returns {external:Promise}\r\n     */ this.batch = function(values, options) {\n        return config.$npm.spex.batch.call(this, values, options);\n    };\n    /**\r\n     * @method Task#page\r\n     * @description\r\n     * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n     *\r\n     * For complete method documentation see $[spex.page].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     *\r\n     * @returns {external:Promise}\r\n     */ this.page = function(source, options) {\n        return config.$npm.spex.page.call(this, source, options);\n    };\n    /**\r\n     * @method Task#sequence\r\n     * @description\r\n     * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n     *\r\n     * For complete method documentation see $[spex.sequence].\r\n     *\r\n     * @param {function} source\r\n     * @param {Object} [options]\r\n     * Optional Parameters.\r\n     * @param {function} [options.dest]\r\n     * @param {number} [options.limit=0]\r\n     * @param {boolean} [options.track=false]\r\n     *\r\n     * @returns {external:Promise}\r\n     */ this.sequence = function(source, options) {\n        return config.$npm.spex.sequence.call(this, source, options);\n    };\n}\n/**\r\n * @private\r\n * @method Task.callback\r\n * Callback invocation helper.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param cb\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */ const callback = (ctx, obj, cb, config)=>{\n    const $p = config.promise;\n    let result;\n    try {\n        if (cb.constructor.name === \"GeneratorFunction\") {\n            // v9.0 dropped all support for ES6 generator functions;\n            // Clients should use the new ES7 async/await syntax.\n            throw new TypeError(\"ES6 generator functions are no longer supported!\");\n        }\n        result = cb.call(obj, obj); // invoking the callback function;\n    } catch (err) {\n        Events.error(ctx.options, err, {\n            client: ctx.db && ctx.db.client,\n            dc: ctx.dc,\n            ctx: ctx.ctx\n        });\n        return $p.reject(err); // reject with the error;\n    }\n    if (result && typeof result.then === \"function\") {\n        return result; // result is a valid promise object;\n    }\n    return $p.resolve(result);\n};\n/**\r\n * @private\r\n * @method Task.execute\r\n * Executes a task.\r\n *\r\n * @param ctx\r\n * @param obj\r\n * @param isTX\r\n * @param config\r\n * @returns {Promise.<TResult>}\r\n */ const execute = (ctx, obj, isTX, config)=>{\n    const $p = config.promise;\n    // updates the task context and notifies the client;\n    function update(start, success, result) {\n        const c = ctx.ctx;\n        if (start) {\n            npm.utils.addReadProp(c, \"start\", new Date());\n        } else {\n            c.finish = new Date();\n            c.success = success;\n            c.result = result;\n            c.duration = c.finish - c.start;\n        }\n        (isTX ? Events.transact : Events.task)(ctx.options, {\n            client: ctx.db && ctx.db.client,\n            dc: ctx.dc,\n            ctx: c\n        });\n    }\n    let cbData, cbReason, success, spName; // Save-Point Name;\n    const capSQL = ctx.options.capSQL; // capitalize sql;\n    update(true);\n    if (isTX) {\n        // executing a transaction;\n        spName = `sp_${ctx.txLevel}_${ctx.nextTxCount}`;\n        return begin().then(()=>callback(ctx, obj, ctx.cb, config).then((data)=>{\n                cbData = data; // save callback data;\n                success = true;\n                return commit();\n            }, (err)=>{\n                cbReason = err; // save callback failure reason;\n                return rollback();\n            }).then(()=>{\n                if (success) {\n                    update(false, true, cbData);\n                    return cbData;\n                }\n                update(false, false, cbReason);\n                return $p.reject(cbReason);\n            }, (err)=>{\n                // either COMMIT or ROLLBACK has failed, which is impossible\n                // to replicate in a test environment, so skipping from the test;\n                // istanbul ignore next:\n                update(false, false, err);\n                // istanbul ignore next:\n                return $p.reject(err);\n            }), (err)=>{\n            // BEGIN has failed, which is impossible to replicate in a test\n            // environment, so skipping the whole block from the test;\n            // istanbul ignore next:\n            update(false, false, err);\n            // istanbul ignore next:\n            return $p.reject(err);\n        });\n    }\n    function begin() {\n        if (!ctx.txLevel && ctx.mode instanceof npm.mode.TransactionMode) {\n            return exec(ctx.mode.begin(capSQL), \"savepoint\");\n        }\n        return exec(\"begin\", \"savepoint\");\n    }\n    function commit() {\n        return exec(\"commit\", \"release savepoint\");\n    }\n    function rollback() {\n        return exec(\"rollback\", \"rollback to savepoint\");\n    }\n    function exec(top, nested) {\n        if (ctx.txLevel) {\n            return obj.none((capSQL ? nested.toUpperCase() : nested) + \" \" + spName);\n        }\n        return obj.none(capSQL ? top.toUpperCase() : top);\n    }\n    // executing a task;\n    return callback(ctx, obj, ctx.cb, config).then((data)=>{\n        update(false, true, data);\n        return data;\n    }).catch((error)=>{\n        update(false, false, error);\n        return $p.reject(error);\n    });\n};\nmodule.exports = (config)=>{\n    const npmLocal = config.$npm;\n    // istanbul ignore next:\n    // we keep 'npm.query' initialization here, even though it is always\n    // pre-initialized by the 'database' module, for integrity purpose.\n    npmLocal.query = npmLocal.query || npm.query(config);\n    npmLocal.spex = npmLocal.spex || npm.spex(config.promiseLib);\n    return {\n        Task,\n        execute,\n        callback\n    };\n}; /**\r\n * @typedef TaskContext\r\n * @description\r\n * Task/Transaction Context used via property {@link Task#ctx ctx} inside tasks (methods {@link Database#task Database.task} and {@link Database#taskIf Database.taskIf})\r\n * and transactions (methods {@link Database#tx Database.tx} and {@link Database#txIf Database.txIf}).\r\n *\r\n * Properties `context`, `connected`, `parent`, `level`, `dc`, `isTX`, `tag`, `start`, `useCount` and `serverVersion` are set just before the operation has started,\r\n * while properties `finish`, `duration`, `success` and `result` are set immediately after the operation has finished.\r\n *\r\n * @property {*} context\r\n * If the operation was invoked with a calling context - `task.call(context,...)` or `tx.call(context,...)`,\r\n * this property is set with the context that was passed in. Otherwise, the property doesn't exist.\r\n *\r\n * @property {*} dc\r\n * _Database Context_ that was passed into the {@link Database} object during construction.\r\n *\r\n * @property {boolean} isTX\r\n * Indicates whether this operation is a transaction (as opposed to a regular task).\r\n *\r\n * @property {number} duration\r\n * Number of milliseconds consumed by the operation.\r\n *\r\n * Set after the operation has finished, it is simply a shortcut for `finish - start`.\r\n *\r\n * @property {number} level\r\n * Task nesting level, starting from 0, counting both regular tasks and transactions.\r\n *\r\n * @property {number} txLevel\r\n * Transaction nesting level, starting from 0. Transactions on level 0 use `BEGIN/COMMIT/ROLLBACK`,\r\n * while transactions on nested levels use the corresponding `SAVEPOINT` commands.\r\n *\r\n * This property exists only within the context of a transaction (`isTX = true`).\r\n *\r\n * @property {boolean} inTransaction\r\n * Available in both tasks and transactions, it simplifies checking when there is a transaction\r\n * going on either on this level or above.\r\n *\r\n * For example, when you want to check for a containing transaction while inside a task, and\r\n * only start a transaction when there is none yet.\r\n *\r\n * @property {TaskContext} parent\r\n * Parent task/transaction context, or `null` when it is top-level.\r\n *\r\n * @property {boolean} connected\r\n * Indicates when the task/transaction acquired the connection on its own (`connected = true`), and will release it once\r\n * the operation has finished. When the value is `false`, the operation is reusing an existing connection.\r\n *\r\n * @property {*} tag\r\n * Tag value as it was passed into the task. See methods {@link Database#task task} and {@link Database#tx tx}.\r\n *\r\n * @property {Date} start\r\n * Date/Time of when this operation started the execution.\r\n *\r\n * @property {number} useCount\r\n * Number of times the connection has been previously used, starting with 0 for a freshly\r\n * allocated physical connection.\r\n *\r\n * @property {string} serverVersion\r\n * Version of the PostgreSQL server to which we are connected.\r\n * Not available with $[Native Bindings].\r\n *\r\n * @property {Date} finish\r\n * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n *\r\n * @property {boolean} success\r\n * Once the operation has finished, this property indicates whether it was successful.\r\n *\r\n * @property {*} result\r\n * Once the operation has finished, this property contains the result, depending on property `success`:\r\n * - data resolved by the operation, if `success = true`\r\n * - error / rejection reason, if `success = false`\r\n *\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdGFzay5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxNQUFNLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFFekIsTUFBTUMsTUFBTTtJQUNSQyxNQUFNRixtQkFBT0EsQ0FBQztJQUNkRyxPQUFPSCxtQkFBT0EsQ0FBQztJQUNmSSxNQUFNSixtQkFBT0EsQ0FBQztJQUNkSyxPQUFPTCxtQkFBT0EsQ0FBQztJQUNmTSxNQUFNTixtQkFBT0EsQ0FBQztBQUNsQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlDQyxHQUNELFNBQVNPLEtBQUtDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07SUFFaEMsTUFBTUMsS0FBS0QsT0FBT0UsT0FBTztJQUV6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXlCQyxHQUNELElBQUksQ0FBQ0wsR0FBRyxHQUFHQSxJQUFJQSxHQUFHLEdBQUcsQ0FBQyxHQUFHLHVCQUF1QjtJQUVoRFAsSUFBSUUsS0FBSyxDQUFDVyxXQUFXLENBQUMsSUFBSSxDQUFDTixHQUFHLEVBQUUsUUFBUUU7SUFFeEMsSUFBSSxhQUFhRixLQUFLO1FBQ2xCUCxJQUFJRSxLQUFLLENBQUNXLFdBQVcsQ0FBQyxJQUFJLENBQUNOLEdBQUcsRUFBRSxXQUFXQSxJQUFJTyxPQUFPO0lBQzFEO0lBRUFkLElBQUlFLEtBQUssQ0FBQ1csV0FBVyxDQUFDLElBQUksQ0FBQ04sR0FBRyxFQUFFLGFBQWEsQ0FBQ0EsSUFBSVEsRUFBRTtJQUNwRGYsSUFBSUUsS0FBSyxDQUFDVyxXQUFXLENBQUMsSUFBSSxDQUFDTixHQUFHLEVBQUUsT0FBT0M7SUFDdkNSLElBQUlFLEtBQUssQ0FBQ1csV0FBVyxDQUFDLElBQUksQ0FBQ04sR0FBRyxFQUFFLE1BQU1BLElBQUlTLEVBQUU7SUFDNUNoQixJQUFJRSxLQUFL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QUFNZTtRQUNwQixPQUFPQTtJQUNYLEdBQ0NTLEtBQUssQ0FBQzdCLENBQUFBO1FBQ0hLLE9BQU8sT0FBTyxPQUFPTDtRQUNyQixPQUFPOUIsR0FBR1ksTUFBTSxDQUFDa0I7SUFDckI7QUFDUjtBQUVBOEIsT0FBT0MsT0FBTyxHQUFHOUQsQ0FBQUE7SUFDYixNQUFNK0QsV0FBVy9ELE9BQU9nQixJQUFJO0lBRTVCLHdCQUF3QjtJQUN4QixvRUFBb0U7SUFDcEUsbUVBQW1FO0lBQ25FK0MsU0FBU3JFLEtBQUssR0FBR3FFLFNBQVNyRSxLQUFLLElBQUlKLElBQUlJLEtBQUssQ0FBQ007SUFDN0MrRCxTQUFTeEUsSUFBSSxHQUFHd0UsU0FBU3hFLElBQUksSUFBSUQsSUFBSUMsSUFBSSxDQUFDUyxPQUFPZ0UsVUFBVTtJQUUzRCxPQUFPO1FBQ0hwRTtRQUFNdUM7UUFBU1o7SUFDbkI7QUFDSixHQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3RUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi90YXNrLmpzPzQ4NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtFdmVudHN9ID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcclxuXHJcbmNvbnN0IG5wbSA9IHtcclxuICAgIHNwZXg6IHJlcXVpcmUoJ3NwZXgnKSxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxzJyksXHJcbiAgICBtb2RlOiByZXF1aXJlKCcuL3R4LW1vZGUnKSxcclxuICAgIHF1ZXJ5OiByZXF1aXJlKCcuL3F1ZXJ5JyksXHJcbiAgICB0ZXh0OiByZXF1aXJlKCcuL3RleHQnKVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgVGFza1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRXh0ZW5kcyB7QGxpbmsgRGF0YWJhc2V9IGZvciBhbiBhdXRvbWF0aWMgY29ubmVjdGlvbiBzZXNzaW9uLCB3aXRoIG1ldGhvZHMgZm9yIGV4ZWN1dGluZyBtdWx0aXBsZSBkYXRhYmFzZSBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgdHlwZSBpc24ndCBhdmFpbGFibGUgZGlyZWN0bHksIGl0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgdmlhIG1ldGhvZHMge0BsaW5rIERhdGFiYXNlI3Rhc2sgRGF0YWJhc2UudGFza30sIHtAbGluayBEYXRhYmFzZSN0eCBEYXRhYmFzZS50eH0sXHJcbiAqIG9yIHRoZWlyIGRlcml2YXRpb25zLlxyXG4gKlxyXG4gKiBXaGVuIGV4ZWN1dGluZyBtb3JlIHRoYW4gb25lIHJlcXVlc3QgYXQgYSB0aW1lLCBvbmUgc2hvdWxkIGFsbG9jYXRlIGFuZCByZWxlYXNlIHRoZSBjb25uZWN0aW9uIG9ubHkgb25jZSxcclxuICogd2hpbGUgZXhlY3V0aW5nIGFsbCB0aGUgcmVxdWlyZWQgcXVlcmllcyB3aXRoaW4gdGhlIHNhbWUgY29ubmVjdGlvbiBzZXNzaW9uLiBNb3JlIGltcG9ydGFudGx5LCBhIHRyYW5zYWN0aW9uXHJcbiAqIGNhbiBvbmx5IHdvcmsgd2l0aGluIGEgc2luZ2xlIGNvbm5lY3Rpb24uXHJcbiAqXHJcbiAqIFRoaXMgaXMgYW4gaW50ZXJmYWNlIGZvciB0YXNrcy90cmFuc2FjdGlvbnMgdG8gaW1wbGVtZW50IGEgY29ubmVjdGlvbiBzZXNzaW9uLCBkdXJpbmcgd2hpY2ggeW91IGNhblxyXG4gKiBleGVjdXRlIG11bHRpcGxlIHF1ZXJpZXMgYWdhaW5zdCB0aGUgc2FtZSBjb25uZWN0aW9uIHRoYXQncyByZWxlYXNlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHRhc2svdHJhbnNhY3Rpb24gaXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEVhY2ggdGFzay90cmFuc2FjdGlvbiBtYW5hZ2VzIHRoZSBjb25uZWN0aW9uIGF1dG9tYXRpY2FsbHkuIFdoZW4gZXhlY3V0ZWQgb24gdGhlIHJvb3Qge0BsaW5rIERhdGFiYXNlfSBvYmplY3QsIHRoZSBjb25uZWN0aW9uXHJcbiAqIGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBwb29sLCBhbmQgb25jZSB0aGUgbWV0aG9kJ3MgY2FsbGJhY2sgaGFzIGZpbmlzaGVkLCB0aGUgY29ubmVjdGlvbiBpcyByZWxlYXNlZCBiYWNrIHRvIHRoZSBwb29sLlxyXG4gKiBIb3dldmVyLCB3aGVuIGludm9rZWQgaW5zaWRlIGFub3RoZXIgdGFzayBvciB0cmFuc2FjdGlvbiwgdGhlIG1ldGhvZCByZXVzZXMgdGhlIHBhcmVudCBjb25uZWN0aW9uLlxyXG4gKlxyXG4gKiBAc2VlXHJcbiAqIHtAbGluayBUYXNrI2N0eCBjdHh9LFxyXG4gKiB7QGxpbmsgVGFzayNiYXRjaCBiYXRjaH0sXHJcbiAqIHtAbGluayBUYXNrI3NlcXVlbmNlIHNlcXVlbmNlfSxcclxuICoge0BsaW5rIFRhc2sjcGFnZSBwYWdlfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBkYi50YXNrKHQgPT4ge1xyXG4gKiAgICAgICAvLyB0ID0gdGFzayBwcm90b2NvbCBjb250ZXh0O1xyXG4gKiAgICAgICAvLyB0LmN0eCA9IFRhc2sgQ29udGV4dDtcclxuICogICAgICAgcmV0dXJuIHQub25lKCdzZWxlY3QgKiBmcm9tIHVzZXJzIHdoZXJlIGlkPSQxJywgMTIzKVxyXG4gKiAgICAgICAgICAgLnRoZW4odXNlciA9PiB7XHJcbiAqICAgICAgICAgICAgICAgcmV0dXJuIHQuYW55KCdzZWxlY3QgKiBmcm9tIGV2ZW50cyB3aGVyZSBsb2dpbj0kMScsIHVzZXIubmFtZSk7XHJcbiAqICAgICAgICAgICB9KTtcclxuICogICB9KVxyXG4gKiAudGhlbihldmVudHMgPT4ge1xyXG4gKiAgICAgICAvLyBzdWNjZXNzO1xyXG4gKiAgIH0pXHJcbiAqIC5jYXRjaChlcnJvciA9PiB7XHJcbiAqICAgICAgIC8vIGVycm9yO1xyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gVGFzayhjdHgsIHRhZywgaXNUWCwgY29uZmlnKSB7XHJcblxyXG4gICAgY29uc3QgJHAgPSBjb25maWcucHJvbWlzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge1Rhc2tDb250ZXh0fSBUYXNrI2N0eFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFRhc2svVHJhbnNhY3Rpb24gQ29udGV4dCBvYmplY3QgLSBjb250YWlucyBpbmRpdmlkdWFsIHByb3BlcnRpZXMgZm9yIGVhY2ggdGFzay90cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIGV2ZW50IHtAbGluayBldmVudDpxdWVyeSBxdWVyeX1cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGRiLnRhc2sodCA9PiB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHQuY3R4OyAvLyB0YXNrIGNvbnRleHQgb2JqZWN0XHJcbiAgICAgKiB9KVxyXG4gICAgICogICAgIC50aGVuKGN0eCA9PiB7XHJcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdUYXNrIER1cmF0aW9uOicsIGN0eC5kdXJhdGlvbik7XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBkYi50eCh0ID0+IHtcclxuICAgICAqICAgICByZXR1cm4gdC5jdHg7IC8vIHRyYW5zYWN0aW9uIGNvbnRleHQgb2JqZWN0XHJcbiAgICAgKiB9KVxyXG4gICAgICogICAgIC50aGVuKGN0eCA9PiB7XHJcbiAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBEdXJhdGlvbjonLCBjdHguZHVyYXRpb24pO1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmN0eCA9IGN0eC5jdHggPSB7fTsgLy8gdGFzayBjb250ZXh0IG9iamVjdDtcclxuXHJcbiAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcy5jdHgsICdpc1RYJywgaXNUWCk7XHJcblxyXG4gICAgaWYgKCdjb250ZXh0JyBpbiBjdHgpIHtcclxuICAgICAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcy5jdHgsICdjb250ZXh0JywgY3R4LmNvbnRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcCh0aGlzLmN0eCwgJ2Nvbm5lY3RlZCcsICFjdHguZGIpO1xyXG4gICAgbnBtLnV0aWxzLmFkZFJlYWRQcm9wKHRoaXMuY3R4LCAndGFnJywgdGFnKTtcclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcCh0aGlzLmN0eCwgJ2RjJywgY3R4LmRjKTtcclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcCh0aGlzLmN0eCwgJ2xldmVsJywgY3R4LmxldmVsKTtcclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcCh0aGlzLmN0eCwgJ2luVHJhbnNhY3Rpb24nLCBjdHguaW5UcmFuc2FjdGlvbik7XHJcblxyXG4gICAgaWYgKGlzVFgpIHtcclxuICAgICAgICBucG0udXRpbHMuYWRkUmVhZFByb3AodGhpcy5jdHgsICd0eExldmVsJywgY3R4LnR4TGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcCh0aGlzLmN0eCwgJ3BhcmVudCcsIGN0eC5wYXJlbnRDdHgpO1xyXG5cclxuICAgIC8vIGdlbmVyaWMgcXVlcnkgbWV0aG9kO1xyXG4gICAgdGhpcy5xdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSwgdmFsdWVzLCBxcm0pIHtcclxuICAgICAgICBpZiAoIWN0eC5kYikge1xyXG4gICAgICAgICAgICByZXR1cm4gJHAucmVqZWN0KG5ldyBFcnJvcihucG0udGV4dC5sb29zZVF1ZXJ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25maWcuJG5wbS5xdWVyeS5jYWxsKHRoaXMsIGN0eCwgcXVlcnksIHZhbHVlcywgcXJtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQ29uc2lkZXIgdXNpbmcgPGI+YXN5bmMvYXdhaXQ8L2I+IHN5bnRheCBpbnN0ZWFkLCBvciBpZiB5b3UgbXVzdCBoYXZlXHJcbiAgICAgKiBwcmUtZ2VuZXJhdGVkIHByb21pc2VzLCB0aGVuICRbUHJvbWlzZS5hbGxTZXR0bGVkXS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIFRhc2sjYmF0Y2hcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2V0dGxlcyBhIHByZWRlZmluZWQgYXJyYXkgb2YgbWl4ZWQgdmFsdWVzIGJ5IHJlZGlyZWN0aW5nIHRvIG1ldGhvZCAkW3NwZXguYmF0Y2hdLlxyXG4gICAgICpcclxuICAgICAqIEZvciBjb21wbGV0ZSBtZXRob2QgZG9jdW1lbnRhdGlvbiBzZWUgJFtzcGV4LmJhdGNoXS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIE9wdGlvbmFsIFBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jYl1cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5iYXRjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnLiRucG0uc3BleC5iYXRjaC5jYWxsKHRoaXMsIHZhbHVlcywgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBUYXNrI3BhZ2VcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogUmVzb2x2ZXMgYSBkeW5hbWljIHNlcXVlbmNlIG9mIGFycmF5cy9wYWdlcyB3aXRoIG1peGVkIHZhbHVlcywgYnkgcmVkaXJlY3RpbmcgdG8gbWV0aG9kICRbc3BleC5wYWdlXS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29tcGxldGUgbWV0aG9kIGRvY3VtZW50YXRpb24gc2VlICRbc3BleC5wYWdlXS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIE9wdGlvbmFsIFBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5kZXN0XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbWl0PTBdXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2V4dGVybmFsOlByb21pc2V9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFnZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnLiRucG0uc3BleC5wYWdlLmNhbGwodGhpcywgc291cmNlLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIFRhc2sjc2VxdWVuY2VcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogUmVzb2x2ZXMgYSBkeW5hbWljIHNlcXVlbmNlIG9mIG1peGVkIHZhbHVlcyBieSByZWRpcmVjdGluZyB0byBtZXRob2QgJFtzcGV4LnNlcXVlbmNlXS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29tcGxldGUgbWV0aG9kIGRvY3VtZW50YXRpb24gc2VlICRbc3BleC5zZXF1ZW5jZV0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBPcHRpb25hbCBQYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZGVzdF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdD0wXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFjaz1mYWxzZV1cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7ZXh0ZXJuYWw6UHJvbWlzZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXF1ZW5jZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gY29uZmlnLiRucG0uc3BleC5zZXF1ZW5jZS5jYWxsKHRoaXMsIHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgVGFzay5jYWxsYmFja1xyXG4gKiBDYWxsYmFjayBpbnZvY2F0aW9uIGhlbHBlci5cclxuICpcclxuICogQHBhcmFtIGN0eFxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqIEBwYXJhbSBjYlxyXG4gKiBAcGFyYW0gY29uZmlnXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUUmVzdWx0Pn1cclxuICovXHJcbmNvbnN0IGNhbGxiYWNrID0gKGN0eCwgb2JqLCBjYiwgY29uZmlnKSA9PiB7XHJcblxyXG4gICAgY29uc3QgJHAgPSBjb25maWcucHJvbWlzZTtcclxuICAgIGxldCByZXN1bHQ7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoY2IuY29uc3RydWN0b3IubmFtZSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyB2OS4wIGRyb3BwZWQgYWxsIHN1cHBvcnQgZm9yIEVTNiBnZW5lcmF0b3IgZnVuY3Rpb25zO1xyXG4gICAgICAgICAgICAvLyBDbGllbnRzIHNob3VsZCB1c2UgdGhlIG5ldyBFUzcgYXN5bmMvYXdhaXQgc3ludGF4LlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFUzYgZ2VuZXJhdG9yIGZ1bmN0aW9ucyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gY2IuY2FsbChvYmosIG9iaik7IC8vIGludm9raW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbjtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIEV2ZW50cy5lcnJvcihjdHgub3B0aW9ucywgZXJyLCB7XHJcbiAgICAgICAgICAgIGNsaWVudDogY3R4LmRiICYmIGN0eC5kYi5jbGllbnQsIC8vIHRoZSBlcnJvciBjYW4gYmUgZHVlIHRvIGxvc3Mgb2YgY29ubmVjdGl2aXR5XHJcbiAgICAgICAgICAgIGRjOiBjdHguZGMsXHJcbiAgICAgICAgICAgIGN0eDogY3R4LmN0eFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyKTsgLy8gcmVqZWN0IHdpdGggdGhlIGVycm9yO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvLyByZXN1bHQgaXMgYSB2YWxpZCBwcm9taXNlIG9iamVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiAkcC5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBUYXNrLmV4ZWN1dGVcclxuICogRXhlY3V0ZXMgYSB0YXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4XHJcbiAqIEBwYXJhbSBvYmpcclxuICogQHBhcmFtIGlzVFhcclxuICogQHBhcmFtIGNvbmZpZ1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VFJlc3VsdD59XHJcbiAqL1xyXG5jb25zdCBleGVjdXRlID0gKGN0eCwgb2JqLCBpc1RYLCBjb25maWcpID0+IHtcclxuXHJcbiAgICBjb25zdCAkcCA9IGNvbmZpZy5wcm9taXNlO1xyXG5cclxuICAgIC8vIHVwZGF0ZXMgdGhlIHRhc2sgY29udGV4dCBhbmQgbm90aWZpZXMgdGhlIGNsaWVudDtcclxuICAgIGZ1bmN0aW9uIHVwZGF0ZShzdGFydCwgc3VjY2VzcywgcmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3QgYyA9IGN0eC5jdHg7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIG5wbS51dGlscy5hZGRSZWFkUHJvcChjLCAnc3RhcnQnLCBuZXcgRGF0ZSgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjLmZpbmlzaCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGMuc3VjY2VzcyA9IHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIGMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjLmR1cmF0aW9uID0gYy5maW5pc2ggLSBjLnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAoaXNUWCA/IEV2ZW50cy50cmFuc2FjdCA6IEV2ZW50cy50YXNrKShjdHgub3B0aW9ucywge1xyXG4gICAgICAgICAgICBjbGllbnQ6IGN0eC5kYiAmJiBjdHguZGIuY2xpZW50LCAvLyBsb3NzIG9mIGNvbm5lY3Rpdml0eSBpcyBwb3NzaWJsZSBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgICAgIGRjOiBjdHguZGMsXHJcbiAgICAgICAgICAgIGN0eDogY1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYkRhdGEsIGNiUmVhc29uLCBzdWNjZXNzLFxyXG4gICAgICAgIHNwTmFtZTsgLy8gU2F2ZS1Qb2ludCBOYW1lO1xyXG5cclxuICAgIGNvbnN0IGNhcFNRTCA9IGN0eC5vcHRpb25zLmNhcFNRTDsgLy8gY2FwaXRhbGl6ZSBzcWw7XHJcblxyXG4gICAgdXBkYXRlKHRydWUpO1xyXG5cclxuICAgIGlmIChpc1RYKSB7XHJcbiAgICAgICAgLy8gZXhlY3V0aW5nIGEgdHJhbnNhY3Rpb247XHJcbiAgICAgICAgc3BOYW1lID0gYHNwXyR7Y3R4LnR4TGV2ZWx9XyR7Y3R4Lm5leHRUeENvdW50fWA7XHJcbiAgICAgICAgcmV0dXJuIGJlZ2luKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gY2FsbGJhY2soY3R4LCBvYmosIGN0eC5jYiwgY29uZmlnKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JEYXRhID0gZGF0YTsgLy8gc2F2ZSBjYWxsYmFjayBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21taXQoKTtcclxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2JSZWFzb24gPSBlcnI7IC8vIHNhdmUgY2FsbGJhY2sgZmFpbHVyZSByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZShmYWxzZSwgdHJ1ZSwgY2JEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKGZhbHNlLCBmYWxzZSwgY2JSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoY2JSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIENPTU1JVCBvciBST0xMQkFDSyBoYXMgZmFpbGVkLCB3aGljaCBpcyBpbXBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVwbGljYXRlIGluIGEgdGVzdCBlbnZpcm9ubWVudCwgc28gc2tpcHBpbmcgZnJvbSB0aGUgdGVzdDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDpcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoZmFsc2UsIGZhbHNlLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQkVHSU4gaGFzIGZhaWxlZCwgd2hpY2ggaXMgaW1wb3NzaWJsZSB0byByZXBsaWNhdGUgaW4gYSB0ZXN0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCwgc28gc2tpcHBpbmcgdGhlIHdob2xlIGJsb2NrIGZyb20gdGhlIHRlc3Q7XHJcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDpcclxuICAgICAgICAgICAgICAgIHVwZGF0ZShmYWxzZSwgZmFsc2UsIGVycik7XHJcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYmVnaW4oKSB7XHJcbiAgICAgICAgaWYgKCFjdHgudHhMZXZlbCAmJiBjdHgubW9kZSBpbnN0YW5jZW9mIG5wbS5tb2RlLlRyYW5zYWN0aW9uTW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhlYyhjdHgubW9kZS5iZWdpbihjYXBTUUwpLCAnc2F2ZXBvaW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleGVjKCdiZWdpbicsICdzYXZlcG9pbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21taXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWMoJ2NvbW1pdCcsICdyZWxlYXNlIHNhdmVwb2ludCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiBleGVjKCdyb2xsYmFjaycsICdyb2xsYmFjayB0byBzYXZlcG9pbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBleGVjKHRvcCwgbmVzdGVkKSB7XHJcbiAgICAgICAgaWYgKGN0eC50eExldmVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoubm9uZSgoY2FwU1FMID8gbmVzdGVkLnRvVXBwZXJDYXNlKCkgOiBuZXN0ZWQpICsgJyAnICsgc3BOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iai5ub25lKGNhcFNRTCA/IHRvcC50b1VwcGVyQ2FzZSgpIDogdG9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBleGVjdXRpbmcgYSB0YXNrO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrKGN0eCwgb2JqLCBjdHguY2IsIGNvbmZpZylcclxuICAgICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgICAgdXBkYXRlKGZhbHNlLCB0cnVlLCBkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGUoZmFsc2UsIGZhbHNlLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiAkcC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25maWcgPT4ge1xyXG4gICAgY29uc3QgbnBtTG9jYWwgPSBjb25maWcuJG5wbTtcclxuXHJcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDpcclxuICAgIC8vIHdlIGtlZXAgJ25wbS5xdWVyeScgaW5pdGlhbGl6YXRpb24gaGVyZSwgZXZlbiB0aG91Z2ggaXQgaXMgYWx3YXlzXHJcbiAgICAvLyBwcmUtaW5pdGlhbGl6ZWQgYnkgdGhlICdkYXRhYmFzZScgbW9kdWxlLCBmb3IgaW50ZWdyaXR5IHB1cnBvc2UuXHJcbiAgICBucG1Mb2NhbC5xdWVyeSA9IG5wbUxvY2FsLnF1ZXJ5IHx8IG5wbS5xdWVyeShjb25maWcpO1xyXG4gICAgbnBtTG9jYWwuc3BleCA9IG5wbUxvY2FsLnNwZXggfHwgbnBtLnNwZXgoY29uZmlnLnByb21pc2VMaWIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgVGFzaywgZXhlY3V0ZSwgY2FsbGJhY2tcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYgVGFza0NvbnRleHRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRhc2svVHJhbnNhY3Rpb24gQ29udGV4dCB1c2VkIHZpYSBwcm9wZXJ0eSB7QGxpbmsgVGFzayNjdHggY3R4fSBpbnNpZGUgdGFza3MgKG1ldGhvZHMge0BsaW5rIERhdGFiYXNlI3Rhc2sgRGF0YWJhc2UudGFza30gYW5kIHtAbGluayBEYXRhYmFzZSN0YXNrSWYgRGF0YWJhc2UudGFza0lmfSlcclxuICogYW5kIHRyYW5zYWN0aW9ucyAobWV0aG9kcyB7QGxpbmsgRGF0YWJhc2UjdHggRGF0YWJhc2UudHh9IGFuZCB7QGxpbmsgRGF0YWJhc2UjdHhJZiBEYXRhYmFzZS50eElmfSkuXHJcbiAqXHJcbiAqIFByb3BlcnRpZXMgYGNvbnRleHRgLCBgY29ubmVjdGVkYCwgYHBhcmVudGAsIGBsZXZlbGAsIGBkY2AsIGBpc1RYYCwgYHRhZ2AsIGBzdGFydGAsIGB1c2VDb3VudGAgYW5kIGBzZXJ2ZXJWZXJzaW9uYCBhcmUgc2V0IGp1c3QgYmVmb3JlIHRoZSBvcGVyYXRpb24gaGFzIHN0YXJ0ZWQsXHJcbiAqIHdoaWxlIHByb3BlcnRpZXMgYGZpbmlzaGAsIGBkdXJhdGlvbmAsIGBzdWNjZXNzYCBhbmQgYHJlc3VsdGAgYXJlIHNldCBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQHByb3BlcnR5IHsqfSBjb250ZXh0XHJcbiAqIElmIHRoZSBvcGVyYXRpb24gd2FzIGludm9rZWQgd2l0aCBhIGNhbGxpbmcgY29udGV4dCAtIGB0YXNrLmNhbGwoY29udGV4dCwuLi4pYCBvciBgdHguY2FsbChjb250ZXh0LC4uLilgLFxyXG4gKiB0aGlzIHByb3BlcnR5IGlzIHNldCB3aXRoIHRoZSBjb250ZXh0IHRoYXQgd2FzIHBhc3NlZCBpbi4gT3RoZXJ3aXNlLCB0aGUgcHJvcGVydHkgZG9lc24ndCBleGlzdC5cclxuICpcclxuICogQHByb3BlcnR5IHsqfSBkY1xyXG4gKiBfRGF0YWJhc2UgQ29udGV4dF8gdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIHtAbGluayBEYXRhYmFzZX0gb2JqZWN0IGR1cmluZyBjb25zdHJ1Y3Rpb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNUWFxyXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG9wZXJhdGlvbiBpcyBhIHRyYW5zYWN0aW9uIChhcyBvcHBvc2VkIHRvIGEgcmVndWxhciB0YXNrKS5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAqIE51bWJlciBvZiBtaWxsaXNlY29uZHMgY29uc3VtZWQgYnkgdGhlIG9wZXJhdGlvbi5cclxuICpcclxuICogU2V0IGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGZpbmlzaGVkLCBpdCBpcyBzaW1wbHkgYSBzaG9ydGN1dCBmb3IgYGZpbmlzaCAtIHN0YXJ0YC5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsXHJcbiAqIFRhc2sgbmVzdGluZyBsZXZlbCwgc3RhcnRpbmcgZnJvbSAwLCBjb3VudGluZyBib3RoIHJlZ3VsYXIgdGFza3MgYW5kIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHR4TGV2ZWxcclxuICogVHJhbnNhY3Rpb24gbmVzdGluZyBsZXZlbCwgc3RhcnRpbmcgZnJvbSAwLiBUcmFuc2FjdGlvbnMgb24gbGV2ZWwgMCB1c2UgYEJFR0lOL0NPTU1JVC9ST0xMQkFDS2AsXHJcbiAqIHdoaWxlIHRyYW5zYWN0aW9ucyBvbiBuZXN0ZWQgbGV2ZWxzIHVzZSB0aGUgY29ycmVzcG9uZGluZyBgU0FWRVBPSU5UYCBjb21tYW5kcy5cclxuICpcclxuICogVGhpcyBwcm9wZXJ0eSBleGlzdHMgb25seSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYSB0cmFuc2FjdGlvbiAoYGlzVFggPSB0cnVlYCkuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW5UcmFuc2FjdGlvblxyXG4gKiBBdmFpbGFibGUgaW4gYm90aCB0YXNrcyBhbmQgdHJhbnNhY3Rpb25zLCBpdCBzaW1wbGlmaWVzIGNoZWNraW5nIHdoZW4gdGhlcmUgaXMgYSB0cmFuc2FjdGlvblxyXG4gKiBnb2luZyBvbiBlaXRoZXIgb24gdGhpcyBsZXZlbCBvciBhYm92ZS5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIHdoZW4geW91IHdhbnQgdG8gY2hlY2sgZm9yIGEgY29udGFpbmluZyB0cmFuc2FjdGlvbiB3aGlsZSBpbnNpZGUgYSB0YXNrLCBhbmRcclxuICogb25seSBzdGFydCBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgbm9uZSB5ZXQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7VGFza0NvbnRleHR9IHBhcmVudFxyXG4gKiBQYXJlbnQgdGFzay90cmFuc2FjdGlvbiBjb250ZXh0LCBvciBgbnVsbGAgd2hlbiBpdCBpcyB0b3AtbGV2ZWwuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29ubmVjdGVkXHJcbiAqIEluZGljYXRlcyB3aGVuIHRoZSB0YXNrL3RyYW5zYWN0aW9uIGFjcXVpcmVkIHRoZSBjb25uZWN0aW9uIG9uIGl0cyBvd24gKGBjb25uZWN0ZWQgPSB0cnVlYCksIGFuZCB3aWxsIHJlbGVhc2UgaXQgb25jZVxyXG4gKiB0aGUgb3BlcmF0aW9uIGhhcyBmaW5pc2hlZC4gV2hlbiB0aGUgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIG9wZXJhdGlvbiBpcyByZXVzaW5nIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gdGFnXHJcbiAqIFRhZyB2YWx1ZSBhcyBpdCB3YXMgcGFzc2VkIGludG8gdGhlIHRhc2suIFNlZSBtZXRob2RzIHtAbGluayBEYXRhYmFzZSN0YXNrIHRhc2t9IGFuZCB7QGxpbmsgRGF0YWJhc2UjdHggdHh9LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge0RhdGV9IHN0YXJ0XHJcbiAqIERhdGUvVGltZSBvZiB3aGVuIHRoaXMgb3BlcmF0aW9uIHN0YXJ0ZWQgdGhlIGV4ZWN1dGlvbi5cclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVzZUNvdW50XHJcbiAqIE51bWJlciBvZiB0aW1lcyB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBwcmV2aW91c2x5IHVzZWQsIHN0YXJ0aW5nIHdpdGggMCBmb3IgYSBmcmVzaGx5XHJcbiAqIGFsbG9jYXRlZCBwaHlzaWNhbCBjb25uZWN0aW9uLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2VydmVyVmVyc2lvblxyXG4gKiBWZXJzaW9uIG9mIHRoZSBQb3N0Z3JlU1FMIHNlcnZlciB0byB3aGljaCB3ZSBhcmUgY29ubmVjdGVkLlxyXG4gKiBOb3QgYXZhaWxhYmxlIHdpdGggJFtOYXRpdmUgQmluZGluZ3NdLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge0RhdGV9IGZpbmlzaFxyXG4gKiBPbmNlIHRoZSBvcGVyYXRpb24gaGFzIGZpbmlzaGVkLCB0aGlzIHByb3BlcnR5IGlzIHNldCB0byB0aGUgRGF0YS9UaW1lIG9mIHdoZW4gaXQgaGFwcGVuZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3VjY2Vzc1xyXG4gKiBPbmNlIHRoZSBvcGVyYXRpb24gaGFzIGZpbmlzaGVkLCB0aGlzIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIGl0IHdhcyBzdWNjZXNzZnVsLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkgeyp9IHJlc3VsdFxyXG4gKiBPbmNlIHRoZSBvcGVyYXRpb24gaGFzIGZpbmlzaGVkLCB0aGlzIHByb3BlcnR5IGNvbnRhaW5zIHRoZSByZXN1bHQsIGRlcGVuZGluZyBvbiBwcm9wZXJ0eSBgc3VjY2Vzc2A6XHJcbiAqIC0gZGF0YSByZXNvbHZlZCBieSB0aGUgb3BlcmF0aW9uLCBpZiBgc3VjY2VzcyA9IHRydWVgXHJcbiAqIC0gZXJyb3IgLyByZWplY3Rpb24gcmVhc29uLCBpZiBgc3VjY2VzcyA9IGZhbHNlYFxyXG4gKlxyXG4gKi9cclxuIl0sIm5hbWVzIjpbIkV2ZW50cyIsInJlcXVpcmUiLCJucG0iLCJzcGV4IiwidXRpbHMiLCJtb2RlIiwicXVlcnkiLCJ0ZXh0IiwiVGFzayIsImN0eCIsInRhZyIsImlzVFgiLCJjb25maWciLCIkcCIsInByb21pc2UiLCJhZGRSZWFkUHJvcCIsImNvbnRleHQiLCJkYiIsImRjIiwibGV2ZWwiLCJpblRyYW5zYWN0aW9uIiwidHhMZXZlbCIsInBhcmVudEN0eCIsInZhbHVlcyIsInFybSIsInJlamVjdCIsIkVycm9yIiwibG9vc2VRdWVyeSIsIiRucG0iLCJjYWxsIiwiYmF0Y2giLCJvcHRpb25zIiwicGFnZSIsInNvdXJjZSIsInNlcXVlbmNlIiwiY2FsbGJhY2siLCJvYmoiLCJjYiIsInJlc3VsdCIsImNvbnN0cnVjdG9yIiwibmFtZSIsIlR5cGVFcnJvciIsImVyciIsImVycm9yIiwiY2xpZW50IiwidGhlbiIsInJlc29sdmUiLCJleGVjdXRlIiwidXBkYXRlIiwic3RhcnQiLCJzdWNjZXNzIiwiYyIsIkRhdGUiLCJmaW5pc2giLCJkdXJhdGlvbiIsInRyYW5zYWN0IiwidGFzayIsImNiRGF0YSIsImNiUmVhc29uIiwic3BOYW1lIiwiY2FwU1FMIiwibmV4dFR4Q291bnQiLCJiZWdpbiIsImRhdGEiLCJjb21taXQiLCJyb2xsYmFjayIsIlRyYW5zYWN0aW9uTW9kZSIsImV4ZWMiLCJ0b3AiLCJuZXN0ZWQiLCJub25lIiwidG9VcHBlckNhc2UiLCJjYXRjaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJucG1Mb2NhbCIsInByb21pc2VMaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/task.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/text.js":
/*!*********************************************!*\
  !*** ./node_modules/pg-promise/lib/text.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ /* All error messages used in the module */ \nconst streamVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/pg-promise/package.json\").devDependencies[\"pg-query-stream\"]);\nmodule.exports = {\n    nativeError: \"Failed to initialize Native Bindings.\",\n    /* Database errors */ queryDisconnected: \"Cannot execute a query on a disconnected client.\",\n    invalidQuery: \"Invalid query format.\",\n    invalidFunction: \"Invalid function name.\",\n    invalidProc: \"Invalid procedure name.\",\n    invalidMask: \"Invalid Query Result Mask specified.\",\n    looseQuery: \"Querying against a released or lost connection.\",\n    /* result errors */ notEmpty: \"No return data was expected.\",\n    noData: \"No data returned from the query.\",\n    multiple: \"Multiple rows were not expected.\",\n    /* streaming support */ nativeStreaming: \"Streaming doesn't work with Native Bindings.\",\n    invalidStream: `Invalid or missing stream object: pg-query-stream >= v${streamVersion} was expected`,\n    invalidStreamState: \"Invalid stream state.\",\n    invalidStreamCB: \"Invalid or missing stream initialization callback.\",\n    /* connection errors */ poolDestroyed: \"Connection pool of the database object has been destroyed.\",\n    clientEnd: \"Abnormal client.end() call, due to invalid code or failed server connection.\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DLEdBRUQseUNBQXlDO0FBRXpDLE1BQU1BLGdCQUFnQkMsK0hBQ2lCO0FBRXZDRSxPQUFPQyxPQUFPLEdBQUc7SUFDYkMsYUFBYTtJQUViLG1CQUFtQixHQUNuQkMsbUJBQW1CO0lBQ25CQyxjQUFjO0lBQ2RDLGlCQUFpQjtJQUNqQkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLFlBQVk7SUFFWixpQkFBaUIsR0FDakJDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxVQUFVO0lBRVYscUJBQXFCLEdBQ3JCQyxpQkFBaUI7SUFDakJDLGVBQWUsQ0FBQyxzREFBc0QsRUFBRWhCLGNBQWMsYUFBYSxDQUFDO0lBQ3BHaUIsb0JBQW9CO0lBQ3BCQyxpQkFBaUI7SUFFakIscUJBQXFCLEdBQ3JCQyxlQUFlO0lBQ2ZDLFdBQVc7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3RleHQuanM/ZjE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuLyogQWxsIGVycm9yIG1lc3NhZ2VzIHVzZWQgaW4gdGhlIG1vZHVsZSAqL1xyXG5cclxuY29uc3Qgc3RyZWFtVmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXHJcbiAgICAuZGV2RGVwZW5kZW5jaWVzWydwZy1xdWVyeS1zdHJlYW0nXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgbmF0aXZlRXJyb3I6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBOYXRpdmUgQmluZGluZ3MuJyxcclxuXHJcbiAgICAvKiBEYXRhYmFzZSBlcnJvcnMgKi9cclxuICAgIHF1ZXJ5RGlzY29ubmVjdGVkOiAnQ2Fubm90IGV4ZWN1dGUgYSBxdWVyeSBvbiBhIGRpc2Nvbm5lY3RlZCBjbGllbnQuJyxcclxuICAgIGludmFsaWRRdWVyeTogJ0ludmFsaWQgcXVlcnkgZm9ybWF0LicsXHJcbiAgICBpbnZhbGlkRnVuY3Rpb246ICdJbnZhbGlkIGZ1bmN0aW9uIG5hbWUuJyxcclxuICAgIGludmFsaWRQcm9jOiAnSW52YWxpZCBwcm9jZWR1cmUgbmFtZS4nLFxyXG4gICAgaW52YWxpZE1hc2s6ICdJbnZhbGlkIFF1ZXJ5IFJlc3VsdCBNYXNrIHNwZWNpZmllZC4nLFxyXG4gICAgbG9vc2VRdWVyeTogJ1F1ZXJ5aW5nIGFnYWluc3QgYSByZWxlYXNlZCBvciBsb3N0IGNvbm5lY3Rpb24uJyxcclxuXHJcbiAgICAvKiByZXN1bHQgZXJyb3JzICovXHJcbiAgICBub3RFbXB0eTogJ05vIHJldHVybiBkYXRhIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgbm9EYXRhOiAnTm8gZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeS4nLFxyXG4gICAgbXVsdGlwbGU6ICdNdWx0aXBsZSByb3dzIHdlcmUgbm90IGV4cGVjdGVkLicsXHJcblxyXG4gICAgLyogc3RyZWFtaW5nIHN1cHBvcnQgKi9cclxuICAgIG5hdGl2ZVN0cmVhbWluZzogJ1N0cmVhbWluZyBkb2VzblxcJ3Qgd29yayB3aXRoIE5hdGl2ZSBCaW5kaW5ncy4nLFxyXG4gICAgaW52YWxpZFN0cmVhbTogYEludmFsaWQgb3IgbWlzc2luZyBzdHJlYW0gb2JqZWN0OiBwZy1xdWVyeS1zdHJlYW0gPj0gdiR7c3RyZWFtVmVyc2lvbn0gd2FzIGV4cGVjdGVkYCxcclxuICAgIGludmFsaWRTdHJlYW1TdGF0ZTogJ0ludmFsaWQgc3RyZWFtIHN0YXRlLicsXHJcbiAgICBpbnZhbGlkU3RyZWFtQ0I6ICdJbnZhbGlkIG9yIG1pc3Npbmcgc3RyZWFtIGluaXRpYWxpemF0aW9uIGNhbGxiYWNrLicsXHJcblxyXG4gICAgLyogY29ubmVjdGlvbiBlcnJvcnMgKi9cclxuICAgIHBvb2xEZXN0cm95ZWQ6ICdDb25uZWN0aW9uIHBvb2wgb2YgdGhlIGRhdGFiYXNlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQuJyxcclxuICAgIGNsaWVudEVuZDogJ0Fibm9ybWFsIGNsaWVudC5lbmQoKSBjYWxsLCBkdWUgdG8gaW52YWxpZCBjb2RlIG9yIGZhaWxlZCBzZXJ2ZXIgY29ubmVjdGlvbi4nXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJzdHJlYW1WZXJzaW9uIiwicmVxdWlyZSIsImRldkRlcGVuZGVuY2llcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJuYXRpdmVFcnJvciIsInF1ZXJ5RGlzY29ubmVjdGVkIiwiaW52YWxpZFF1ZXJ5IiwiaW52YWxpZEZ1bmN0aW9uIiwiaW52YWxpZFByb2MiLCJpbnZhbGlkTWFzayIsImxvb3NlUXVlcnkiLCJub3RFbXB0eSIsIm5vRGF0YSIsIm11bHRpcGxlIiwibmF0aXZlU3RyZWFtaW5nIiwiaW52YWxpZFN0cmVhbSIsImludmFsaWRTdHJlYW1TdGF0ZSIsImludmFsaWRTdHJlYW1DQiIsInBvb2xEZXN0cm95ZWQiLCJjbGllbnRFbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/text.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/tx-mode.js":
/*!************************************************!*\
  !*** ./node_modules/pg-promise/lib/tx-mode.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { InnerState } = __webpack_require__(/*! ./inner-state */ \"(rsc)/./node_modules/pg-promise/lib/inner-state.js\");\nconst { addInspection } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\");\nconst { assert } = __webpack_require__(/*! ./assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\n/**\r\n * @enum {number}\r\n * @alias txMode.isolationLevel\r\n * @readonly\r\n * @summary Transaction Isolation Level.\r\n * @description\r\n * The type is available from the {@link txMode} namespace.\r\n *\r\n * @see $[Transaction Isolation]\r\n */ const isolationLevel = {\n    /** Isolation level not specified. */ none: 0,\n    /** ISOLATION LEVEL SERIALIZABLE */ serializable: 1,\n    /** ISOLATION LEVEL REPEATABLE READ */ repeatableRead: 2,\n    /** ISOLATION LEVEL READ COMMITTED */ readCommitted: 3\n};\n/**\r\n * @class txMode.TransactionMode\r\n * @description\r\n * Constructs a complete transaction-opening `BEGIN` command, from these options:\r\n *  - isolation level\r\n *  - access mode\r\n *  - deferrable mode\r\n *\r\n * The type is available from the {@link txMode} namespace.\r\n *\r\n * @param {} [options]\r\n * Transaction Mode options.\r\n *\r\n * @param {txMode.isolationLevel} [options.tiLevel]\r\n * Transaction Isolation Level.\r\n *\r\n * @param {boolean} [options.readOnly]\r\n * Sets transaction access mode based on the read-only flag:\r\n *  - `undefined` - access mode not specified (default)\r\n *  - `true` - access mode is set to `READ ONLY`\r\n *  - `false` - access mode is set to `READ WRITE`\r\n *\r\n * @param {boolean} [options.deferrable]\r\n * Sets transaction deferrable mode based on the boolean value:\r\n *  - `undefined` - deferrable mode not specified (default)\r\n *  - `true` - mode is set to `DEFERRABLE`\r\n *  - `false` - mode is set to `NOT DEFERRABLE`\r\n *\r\n * It is used only when `tiLevel`=`isolationLevel.serializable`\r\n * and `readOnly`=`true`, or else it is ignored.\r\n *\r\n * @returns {txMode.TransactionMode}\r\n *\r\n * @see $[BEGIN], {@link txMode.isolationLevel}\r\n *\r\n * @example\r\n *\r\n * const {TransactionMode, isolationLevel} = pgp.txMode;\r\n *\r\n * // Create a reusable transaction mode (serializable + read-only + deferrable):\r\n * const mode = new TransactionMode({\r\n *     tiLevel: isolationLevel.serializable,\r\n *     readOnly: true,\r\n *     deferrable: true\r\n * });\r\n *\r\n * db.tx({mode}, t => {\r\n *     return t.any('SELECT * FROM table');\r\n * })\r\n *     .then(data => {\r\n *         // success;\r\n *     })\r\n *     .catch(error => {\r\n *         // error\r\n *     });\r\n *\r\n * // Instead of the default BEGIN, such transaction will start with:\r\n *\r\n * // BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE\r\n *\r\n */ class TransactionMode extends InnerState {\n    constructor(options){\n        options = assert(options, [\n            \"tiLevel\",\n            \"deferrable\",\n            \"readOnly\"\n        ]);\n        const { readOnly, deferrable } = options;\n        let { tiLevel } = options;\n        let level, accessMode, deferrableMode, begin = \"begin\";\n        tiLevel = tiLevel > 0 ? parseInt(tiLevel) : 0;\n        if (tiLevel > 0 && tiLevel < 4) {\n            const values = [\n                \"serializable\",\n                \"repeatable read\",\n                \"read committed\"\n            ];\n            level = \"isolation level \" + values[tiLevel - 1];\n        }\n        if (readOnly) {\n            accessMode = \"read only\";\n        } else {\n            if (readOnly !== undefined) {\n                accessMode = \"read write\";\n            }\n        }\n        // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html\n        // The DEFERRABLE transaction property has no effect unless the transaction is also SERIALIZABLE and READ ONLY\n        if (tiLevel === isolationLevel.serializable && readOnly) {\n            if (deferrable) {\n                deferrableMode = \"deferrable\";\n            } else {\n                if (deferrable !== undefined) {\n                    deferrableMode = \"not deferrable\";\n                }\n            }\n        }\n        if (level) {\n            begin += \" \" + level;\n        }\n        if (accessMode) {\n            begin += \" \" + accessMode;\n        }\n        if (deferrableMode) {\n            begin += \" \" + deferrableMode;\n        }\n        super({\n            begin,\n            capBegin: begin.toUpperCase()\n        });\n    }\n    /**\r\n     * @method txMode.TransactionMode#begin\r\n     * @description\r\n     * Returns a complete BEGIN statement, according to all the parameters passed into the class.\r\n     *\r\n     * This method is primarily for internal use by the library.\r\n     *\r\n     * @param {boolean} [cap=false]\r\n     * Indicates whether the returned SQL must be capitalized.\r\n     *\r\n     * @returns {string}\r\n     */ begin(cap) {\n        return cap ? this._inner.capBegin : this._inner.begin;\n    }\n}\naddInspection(TransactionMode, function() {\n    return this.begin(true);\n});\n/**\r\n * @namespace txMode\r\n * @description\r\n * Transaction Mode namespace, available as `pgp.txMode`, before and after initializing the library.\r\n *\r\n * Extends the default `BEGIN` with Transaction Mode parameters:\r\n *  - isolation level\r\n *  - access mode\r\n *  - deferrable mode\r\n *\r\n * @property {function} TransactionMode\r\n * {@link txMode.TransactionMode TransactionMode} class constructor.\r\n *\r\n * @property {txMode.isolationLevel} isolationLevel\r\n * Transaction Isolation Level enumerator\r\n *\r\n * @see $[BEGIN]\r\n */ module.exports = {\n    isolationLevel,\n    TransactionMode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHgtbW9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxVQUFVLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFDQyxhQUFhLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUFDRSxNQUFNLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFFekI7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUcsaUJBQWlCO0lBQ25CLG1DQUFtQyxHQUNuQ0MsTUFBTTtJQUVOLGlDQUFpQyxHQUNqQ0MsY0FBYztJQUVkLG9DQUFvQyxHQUNwQ0MsZ0JBQWdCO0lBRWhCLG1DQUFtQyxHQUNuQ0MsZUFBZTtBQUtuQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0REMsR0FDRCxNQUFNQyx3QkFBd0JUO0lBRTFCVSxZQUFZQyxPQUFPLENBQUU7UUFDakJBLFVBQVVSLE9BQU9RLFNBQVM7WUFBQztZQUFXO1lBQWM7U0FBVztRQUMvRCxNQUFNLEVBQUNDLFFBQVEsRUFBRUMsVUFBVSxFQUFDLEdBQUdGO1FBQy9CLElBQUksRUFBQ0csT0FBTyxFQUFDLEdBQUdIO1FBQ2hCLElBQUlJLE9BQU9DLFlBQVlDLGdCQUFnQkMsUUFBUTtRQUMvQ0osVUFBVSxVQUFXLElBQUtLLFNBQVNMLFdBQVc7UUFFOUMsSUFBSUEsVUFBVSxLQUFLQSxVQUFVLEdBQUc7WUFDNUIsTUFBTU0sU0FBUztnQkFBQztnQkFBZ0I7Z0JBQW1CO2FBQWlCO1lBQ3BFTCxRQUFRLHFCQUFxQkssTUFBTSxDQUFDTixVQUFVLEVBQUU7UUFDcEQ7UUFDQSxJQUFJRixVQUFVO1lBQ1ZJLGFBQWE7UUFDakIsT0FBTztZQUNILElBQUlKLGFBQWFTLFdBQVc7Z0JBQ3hCTCxhQUFhO1lBQ2pCO1FBQ0o7UUFDQSxzR0FBc0c7UUFDdEcsOEdBQThHO1FBQzlHLElBQUlGLFlBQVlWLGVBQWVFLFlBQVksSUFBSU0sVUFBVTtZQUNyRCxJQUFJQyxZQUFZO2dCQUNaSSxpQkFBaUI7WUFDckIsT0FBTztnQkFDSCxJQUFJSixlQUFlUSxXQUFXO29CQUMxQkosaUJBQWlCO2dCQUNyQjtZQUNKO1FBQ0o7UUFDQSxJQUFJRixPQUFPO1lBQ1BHLFNBQVMsTUFBTUg7UUFDbkI7UUFDQSxJQUFJQyxZQUFZO1lBQ1pFLFNBQVMsTUFBTUY7UUFDbkI7UUFDQSxJQUFJQyxnQkFBZ0I7WUFDaEJDLFNBQVMsTUFBTUQ7UUFDbkI7UUFFQSxLQUFLLENBQUM7WUFBQ0M7WUFBT0ksVUFBVUosTUFBTUssV0FBVztRQUFFO0lBQy9DO0lBRUE7Ozs7Ozs7Ozs7O0tBV0MsR0FDREwsTUFBTU0sR0FBRyxFQUFFO1FBQ1AsT0FBT0EsTUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxHQUFHLElBQUksQ0FBQ0csTUFBTSxDQUFDUCxLQUFLO0lBQ3pEO0FBQ0o7QUFFQWhCLGNBQWNPLGlCQUFpQjtJQUMzQixPQUFPLElBQUksQ0FBQ1MsS0FBSyxDQUFDO0FBQ3RCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0RRLE9BQU9DLE9BQU8sR0FBRztJQUNidkI7SUFDQUs7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3R4LW1vZGUuanM/NDlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge0lubmVyU3RhdGV9ID0gcmVxdWlyZSgnLi9pbm5lci1zdGF0ZScpO1xyXG5jb25zdCB7YWRkSW5zcGVjdGlvbn0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbmNvbnN0IHthc3NlcnR9ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKiBAYWxpYXMgdHhNb2RlLmlzb2xhdGlvbkxldmVsXHJcbiAqIEByZWFkb25seVxyXG4gKiBAc3VtbWFyeSBUcmFuc2FjdGlvbiBJc29sYXRpb24gTGV2ZWwuXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgdHlwZSBpcyBhdmFpbGFibGUgZnJvbSB0aGUge0BsaW5rIHR4TW9kZX0gbmFtZXNwYWNlLlxyXG4gKlxyXG4gKiBAc2VlICRbVHJhbnNhY3Rpb24gSXNvbGF0aW9uXVxyXG4gKi9cclxuY29uc3QgaXNvbGF0aW9uTGV2ZWwgPSB7XHJcbiAgICAvKiogSXNvbGF0aW9uIGxldmVsIG5vdCBzcGVjaWZpZWQuICovXHJcbiAgICBub25lOiAwLFxyXG5cclxuICAgIC8qKiBJU09MQVRJT04gTEVWRUwgU0VSSUFMSVpBQkxFICovXHJcbiAgICBzZXJpYWxpemFibGU6IDEsXHJcblxyXG4gICAgLyoqIElTT0xBVElPTiBMRVZFTCBSRVBFQVRBQkxFIFJFQUQgKi9cclxuICAgIHJlcGVhdGFibGVSZWFkOiAyLFxyXG5cclxuICAgIC8qKiBJU09MQVRJT04gTEVWRUwgUkVBRCBDT01NSVRURUQgKi9cclxuICAgIHJlYWRDb21taXR0ZWQ6IDNcclxuXHJcbiAgICAvLyBGcm9tIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS41L3N0YXRpYy9zcWwtc2V0LXRyYW5zYWN0aW9uLmh0bWxcclxuICAgIC8vIFRoZSBTUUwgc3RhbmRhcmQgZGVmaW5lcyBvbmUgYWRkaXRpb25hbCBsZXZlbCwgUkVBRCBVTkNPTU1JVFRFRC4gSW4gUG9zdGdyZVNRTCBSRUFEIFVOQ09NTUlUVEVEIGlzIHRyZWF0ZWQgYXMgUkVBRCBDT01NSVRURUQuXHJcbiAgICAvLyA9PiBza2lwcGluZyBgUkVBRCBVTkNPTU1JVFRFRGAuXHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIHR4TW9kZS5UcmFuc2FjdGlvbk1vZGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENvbnN0cnVjdHMgYSBjb21wbGV0ZSB0cmFuc2FjdGlvbi1vcGVuaW5nIGBCRUdJTmAgY29tbWFuZCwgZnJvbSB0aGVzZSBvcHRpb25zOlxyXG4gKiAgLSBpc29sYXRpb24gbGV2ZWxcclxuICogIC0gYWNjZXNzIG1vZGVcclxuICogIC0gZGVmZXJyYWJsZSBtb2RlXHJcbiAqXHJcbiAqIFRoZSB0eXBlIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSB7QGxpbmsgdHhNb2RlfSBuYW1lc3BhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7fSBbb3B0aW9uc11cclxuICogVHJhbnNhY3Rpb24gTW9kZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3R4TW9kZS5pc29sYXRpb25MZXZlbH0gW29wdGlvbnMudGlMZXZlbF1cclxuICogVHJhbnNhY3Rpb24gSXNvbGF0aW9uIExldmVsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5XVxyXG4gKiBTZXRzIHRyYW5zYWN0aW9uIGFjY2VzcyBtb2RlIGJhc2VkIG9uIHRoZSByZWFkLW9ubHkgZmxhZzpcclxuICogIC0gYHVuZGVmaW5lZGAgLSBhY2Nlc3MgbW9kZSBub3Qgc3BlY2lmaWVkIChkZWZhdWx0KVxyXG4gKiAgLSBgdHJ1ZWAgLSBhY2Nlc3MgbW9kZSBpcyBzZXQgdG8gYFJFQUQgT05MWWBcclxuICogIC0gYGZhbHNlYCAtIGFjY2VzcyBtb2RlIGlzIHNldCB0byBgUkVBRCBXUklURWBcclxuICpcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWZlcnJhYmxlXVxyXG4gKiBTZXRzIHRyYW5zYWN0aW9uIGRlZmVycmFibGUgbW9kZSBiYXNlZCBvbiB0aGUgYm9vbGVhbiB2YWx1ZTpcclxuICogIC0gYHVuZGVmaW5lZGAgLSBkZWZlcnJhYmxlIG1vZGUgbm90IHNwZWNpZmllZCAoZGVmYXVsdClcclxuICogIC0gYHRydWVgIC0gbW9kZSBpcyBzZXQgdG8gYERFRkVSUkFCTEVgXHJcbiAqICAtIGBmYWxzZWAgLSBtb2RlIGlzIHNldCB0byBgTk9UIERFRkVSUkFCTEVgXHJcbiAqXHJcbiAqIEl0IGlzIHVzZWQgb25seSB3aGVuIGB0aUxldmVsYD1gaXNvbGF0aW9uTGV2ZWwuc2VyaWFsaXphYmxlYFxyXG4gKiBhbmQgYHJlYWRPbmx5YD1gdHJ1ZWAsIG9yIGVsc2UgaXQgaXMgaWdub3JlZC5cclxuICpcclxuICogQHJldHVybnMge3R4TW9kZS5UcmFuc2FjdGlvbk1vZGV9XHJcbiAqXHJcbiAqIEBzZWUgJFtCRUdJTl0sIHtAbGluayB0eE1vZGUuaXNvbGF0aW9uTGV2ZWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHtUcmFuc2FjdGlvbk1vZGUsIGlzb2xhdGlvbkxldmVsfSA9IHBncC50eE1vZGU7XHJcbiAqXHJcbiAqIC8vIENyZWF0ZSBhIHJldXNhYmxlIHRyYW5zYWN0aW9uIG1vZGUgKHNlcmlhbGl6YWJsZSArIHJlYWQtb25seSArIGRlZmVycmFibGUpOlxyXG4gKiBjb25zdCBtb2RlID0gbmV3IFRyYW5zYWN0aW9uTW9kZSh7XHJcbiAqICAgICB0aUxldmVsOiBpc29sYXRpb25MZXZlbC5zZXJpYWxpemFibGUsXHJcbiAqICAgICByZWFkT25seTogdHJ1ZSxcclxuICogICAgIGRlZmVycmFibGU6IHRydWVcclxuICogfSk7XHJcbiAqXHJcbiAqIGRiLnR4KHttb2RlfSwgdCA9PiB7XHJcbiAqICAgICByZXR1cm4gdC5hbnkoJ1NFTEVDVCAqIEZST00gdGFibGUnKTtcclxuICogfSlcclxuICogICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gKiAgICAgICAgIC8vIHN1Y2Nlc3M7XHJcbiAqICAgICB9KVxyXG4gKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICogICAgICAgICAvLyBlcnJvclxyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqIC8vIEluc3RlYWQgb2YgdGhlIGRlZmF1bHQgQkVHSU4sIHN1Y2ggdHJhbnNhY3Rpb24gd2lsbCBzdGFydCB3aXRoOlxyXG4gKlxyXG4gKiAvLyBCRUdJTiBJU09MQVRJT04gTEVWRUwgU0VSSUFMSVpBQkxFIFJFQUQgT05MWSBERUZFUlJBQkxFXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbk1vZGUgZXh0ZW5kcyBJbm5lclN0YXRlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFzc2VydChvcHRpb25zLCBbJ3RpTGV2ZWwnLCAnZGVmZXJyYWJsZScsICdyZWFkT25seSddKTtcclxuICAgICAgICBjb25zdCB7cmVhZE9ubHksIGRlZmVycmFibGV9ID0gb3B0aW9ucztcclxuICAgICAgICBsZXQge3RpTGV2ZWx9ID0gb3B0aW9ucztcclxuICAgICAgICBsZXQgbGV2ZWwsIGFjY2Vzc01vZGUsIGRlZmVycmFibGVNb2RlLCBiZWdpbiA9ICdiZWdpbic7XHJcbiAgICAgICAgdGlMZXZlbCA9ICh0aUxldmVsID4gMCkgPyBwYXJzZUludCh0aUxldmVsKSA6IDA7XHJcblxyXG4gICAgICAgIGlmICh0aUxldmVsID4gMCAmJiB0aUxldmVsIDwgNCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbJ3NlcmlhbGl6YWJsZScsICdyZXBlYXRhYmxlIHJlYWQnLCAncmVhZCBjb21taXR0ZWQnXTtcclxuICAgICAgICAgICAgbGV2ZWwgPSAnaXNvbGF0aW9uIGxldmVsICcgKyB2YWx1ZXNbdGlMZXZlbCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgYWNjZXNzTW9kZSA9ICdyZWFkIG9ubHknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyZWFkT25seSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NNb2RlID0gJ3JlYWQgd3JpdGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZyb20gdGhlIG9mZmljaWFsIGRvY3VtZW50YXRpb246IGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjUvc3RhdGljL3NxbC1zZXQtdHJhbnNhY3Rpb24uaHRtbFxyXG4gICAgICAgIC8vIFRoZSBERUZFUlJBQkxFIHRyYW5zYWN0aW9uIHByb3BlcnR5IGhhcyBubyBlZmZlY3QgdW5sZXNzIHRoZSB0cmFuc2FjdGlvbiBpcyBhbHNvIFNFUklBTElaQUJMRSBhbmQgUkVBRCBPTkxZXHJcbiAgICAgICAgaWYgKHRpTGV2ZWwgPT09IGlzb2xhdGlvbkxldmVsLnNlcmlhbGl6YWJsZSAmJiByZWFkT25seSkge1xyXG4gICAgICAgICAgICBpZiAoZGVmZXJyYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyYWJsZU1vZGUgPSAnZGVmZXJyYWJsZSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmZXJyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyYWJsZU1vZGUgPSAnbm90IGRlZmVycmFibGUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZXZlbCkge1xyXG4gICAgICAgICAgICBiZWdpbiArPSAnICcgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjY2Vzc01vZGUpIHtcclxuICAgICAgICAgICAgYmVnaW4gKz0gJyAnICsgYWNjZXNzTW9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZmVycmFibGVNb2RlKSB7XHJcbiAgICAgICAgICAgIGJlZ2luICs9ICcgJyArIGRlZmVycmFibGVNb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3VwZXIoe2JlZ2luLCBjYXBCZWdpbjogYmVnaW4udG9VcHBlckNhc2UoKX0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB0eE1vZGUuVHJhbnNhY3Rpb25Nb2RlI2JlZ2luXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgYSBjb21wbGV0ZSBCRUdJTiBzdGF0ZW1lbnQsIGFjY29yZGluZyB0byBhbGwgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIGludG8gdGhlIGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSBsaWJyYXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhcD1mYWxzZV1cclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZXR1cm5lZCBTUUwgbXVzdCBiZSBjYXBpdGFsaXplZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBiZWdpbihjYXApIHtcclxuICAgICAgICByZXR1cm4gY2FwID8gdGhpcy5faW5uZXIuY2FwQmVnaW4gOiB0aGlzLl9pbm5lci5iZWdpbjtcclxuICAgIH1cclxufVxyXG5cclxuYWRkSW5zcGVjdGlvbihUcmFuc2FjdGlvbk1vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmJlZ2luKHRydWUpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIHR4TW9kZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVHJhbnNhY3Rpb24gTW9kZSBuYW1lc3BhY2UsIGF2YWlsYWJsZSBhcyBgcGdwLnR4TW9kZWAsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBFeHRlbmRzIHRoZSBkZWZhdWx0IGBCRUdJTmAgd2l0aCBUcmFuc2FjdGlvbiBNb2RlIHBhcmFtZXRlcnM6XHJcbiAqICAtIGlzb2xhdGlvbiBsZXZlbFxyXG4gKiAgLSBhY2Nlc3MgbW9kZVxyXG4gKiAgLSBkZWZlcnJhYmxlIG1vZGVcclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gVHJhbnNhY3Rpb25Nb2RlXHJcbiAqIHtAbGluayB0eE1vZGUuVHJhbnNhY3Rpb25Nb2RlIFRyYW5zYWN0aW9uTW9kZX0gY2xhc3MgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7dHhNb2RlLmlzb2xhdGlvbkxldmVsfSBpc29sYXRpb25MZXZlbFxyXG4gKiBUcmFuc2FjdGlvbiBJc29sYXRpb24gTGV2ZWwgZW51bWVyYXRvclxyXG4gKlxyXG4gKiBAc2VlICRbQkVHSU5dXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGlzb2xhdGlvbkxldmVsLFxyXG4gICAgVHJhbnNhY3Rpb25Nb2RlXHJcbn07XHJcblxyXG4iXSwibmFtZXMiOlsiSW5uZXJTdGF0ZSIsInJlcXVpcmUiLCJhZGRJbnNwZWN0aW9uIiwiYXNzZXJ0IiwiaXNvbGF0aW9uTGV2ZWwiLCJub25lIiwic2VyaWFsaXphYmxlIiwicmVwZWF0YWJsZVJlYWQiLCJyZWFkQ29tbWl0dGVkIiwiVHJhbnNhY3Rpb25Nb2RlIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwicmVhZE9ubHkiLCJkZWZlcnJhYmxlIiwidGlMZXZlbCIsImxldmVsIiwiYWNjZXNzTW9kZSIsImRlZmVycmFibGVNb2RlIiwiYmVnaW4iLCJwYXJzZUludCIsInZhbHVlcyIsInVuZGVmaW5lZCIsImNhcEJlZ2luIiwidG9VcHBlckNhc2UiLCJjYXAiLCJfaW5uZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/tx-mode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/types/index.js":
/*!****************************************************!*\
  !*** ./node_modules/pg-promise/lib/types/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ServerFormatting } = __webpack_require__(/*! ./server-formatting */ \"(rsc)/./node_modules/pg-promise/lib/types/server-formatting.js\");\nconst { PreparedStatement } = __webpack_require__(/*! ./prepared-statement */ \"(rsc)/./node_modules/pg-promise/lib/types/prepared-statement.js\");\nconst { ParameterizedQuery } = __webpack_require__(/*! ./parameterized-query */ \"(rsc)/./node_modules/pg-promise/lib/types/parameterized-query.js\");\nmodule.exports = {\n    ServerFormatting,\n    PreparedStatement,\n    ParameterizedQuery\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU0sRUFBQ0EsZ0JBQWdCLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFDQyxpQkFBaUIsRUFBQyxHQUFHRCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUNFLGtCQUFrQixFQUFDLEdBQUdGLG1CQUFPQSxDQUFDO0FBRXJDRyxPQUFPQyxPQUFPLEdBQUc7SUFDYkw7SUFDQUU7SUFDQUM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3R5cGVzL2luZGV4LmpzP2E5NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtTZXJ2ZXJGb3JtYXR0aW5nfSA9IHJlcXVpcmUoJy4vc2VydmVyLWZvcm1hdHRpbmcnKTtcclxuY29uc3Qge1ByZXBhcmVkU3RhdGVtZW50fSA9IHJlcXVpcmUoJy4vcHJlcGFyZWQtc3RhdGVtZW50Jyk7XHJcbmNvbnN0IHtQYXJhbWV0ZXJpemVkUXVlcnl9ID0gcmVxdWlyZSgnLi9wYXJhbWV0ZXJpemVkLXF1ZXJ5Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFNlcnZlckZvcm1hdHRpbmcsXHJcbiAgICBQcmVwYXJlZFN0YXRlbWVudCxcclxuICAgIFBhcmFtZXRlcml6ZWRRdWVyeVxyXG59O1xyXG4iXSwibmFtZXMiOlsiU2VydmVyRm9ybWF0dGluZyIsInJlcXVpcmUiLCJQcmVwYXJlZFN0YXRlbWVudCIsIlBhcmFtZXRlcml6ZWRRdWVyeSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/types/parameterized-query.js":
/*!******************************************************************!*\
  !*** ./node_modules/pg-promise/lib/types/parameterized-query.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ServerFormatting } = __webpack_require__(/*! ./server-formatting */ \"(rsc)/./node_modules/pg-promise/lib/types/server-formatting.js\");\nconst { ParameterizedQueryError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/pg-promise/lib/errors/index.js\");\nconst { QueryFile } = __webpack_require__(/*! ../query-file */ \"(rsc)/./node_modules/pg-promise/lib/query-file.js\");\nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    EOL: (__webpack_require__(/*! os */ \"os\").EOL),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @class ParameterizedQuery\r\n * @description\r\n * Constructs a new {@link ParameterizedQuery} object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{text, values}` object, i.e. when the basic object is used with a query method,\r\n * a new {@link ParameterizedQuery} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.ParameterizedQuery`.\r\n *\r\n * @param {string|QueryFile|Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string|QueryFile} [options.text] - See property {@link ParameterizedQuery#text text}.\r\n * @param {array} [options.values] - See property {@link ParameterizedQuery#values values}.\r\n * @param {boolean} [options.binary] - See property {@link ParameterizedQuery#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link ParameterizedQuery#rowMode rowMode}.\r\n *\r\n * @returns {ParameterizedQuery}\r\n *\r\n * @see\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError}\r\n *\r\n * @example\r\n *\r\n * const {ParameterizedQuery: PQ} = require('pg-promise');\r\n *\r\n * // Creating a complete Parameterized Query with parameters:\r\n * const findUser = new PQ({text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const {ParameterizedQuery: PQ} = require('pg-promise');\r\n *\r\n * // Creating a reusable Parameterized Query without values:\r\n * const addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n */ class ParameterizedQuery extends ServerFormatting {\n    constructor(options){\n        if (typeof options === \"string\" || options instanceof QueryFile) {\n            options = {\n                text: options\n            };\n        } else {\n            options = assert(options, [\n                \"text\",\n                \"values\",\n                \"binary\",\n                \"rowMode\"\n            ]);\n        }\n        super(options);\n    }\n}\n/**\r\n * @method ParameterizedQuery#parse\r\n * @description\r\n * Parses the current object and returns a simple `{text, values}`, if successful,\r\n * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{text, values}|errors.ParameterizedQueryError}\r\n */ ParameterizedQuery.prototype.parse = function() {\n    const _i = this._inner, options = _i.options;\n    const qf = options.text instanceof QueryFile ? options.text : null;\n    if (!_i.changed && !qf) {\n        return _i.target;\n    }\n    const errors = [], values = _i.target.values;\n    _i.target = {\n        text: options.text\n    };\n    _i.changed = true;\n    _i.currentError = undefined;\n    if (qf) {\n        qf.prepare();\n        if (qf.error) {\n            errors.push(qf.error);\n        } else {\n            _i.target.text = qf[QueryFile.$query];\n        }\n    }\n    if (!npm.utils.isText(_i.target.text)) {\n        errors.push(\"Property 'text' must be a non-empty text string.\");\n    }\n    if (!npm.utils.isNull(values)) {\n        _i.target.values = values;\n    }\n    if (options.binary !== undefined) {\n        _i.target.binary = !!options.binary;\n    }\n    if (options.rowMode !== undefined) {\n        _i.target.rowMode = options.rowMode;\n    }\n    if (errors.length) {\n        return _i.currentError = new ParameterizedQueryError(errors[0], _i.target);\n    }\n    _i.changed = false;\n    return _i.target;\n};\n/**\r\n * @method ParameterizedQuery#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ ParameterizedQuery.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap = npm.utils.messageGap(level + 1);\n    const pq = this.parse();\n    const lines = [\n        \"ParameterizedQuery {\"\n    ];\n    if (npm.utils.isText(pq.text)) {\n        lines.push(gap + 'text: \"' + pq.text + '\"');\n    }\n    if (this.values !== undefined) {\n        lines.push(gap + \"values: \" + npm.utils.toJson(this.values));\n    }\n    if (this.binary !== undefined) {\n        lines.push(gap + \"binary: \" + npm.utils.toJson(this.binary));\n    }\n    if (this.rowMode !== undefined) {\n        lines.push(gap + \"rowMode: \" + npm.utils.toJson(this.rowMode));\n    }\n    if (this.error !== undefined) {\n        lines.push(gap + \"error: \" + this.error.toString(level + 1));\n    }\n    lines.push(npm.utils.messageGap(level) + \"}\");\n    return lines.join(npm.EOL);\n};\nmodule.exports = {\n    ParameterizedQuery\n}; /**\r\n * @name ParameterizedQuery#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_\r\n * are formatted on the server side.\r\n */  /**\r\n * @name ParameterizedQuery#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */  /**\r\n * @name ParameterizedQuery#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */  /**\r\n * @name ParameterizedQuery#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */  /**\r\n * @name ParameterizedQuery#error\r\n * @type {errors.ParameterizedQueryError}\r\n * @default undefined\r\n * @readonly\r\n * @description\r\n * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHlwZXMvcGFyYW1ldGVyaXplZC1xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DO0FBRUQsTUFBTSxFQUFDQSxnQkFBZ0IsRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUNuQyxNQUFNLEVBQUNDLHVCQUF1QixFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBQzFDLE1BQU0sRUFBQ0UsU0FBUyxFQUFDLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBQ0csTUFBTSxFQUFDLEdBQUdILG1CQUFPQSxDQUFDO0FBRXpCLE1BQU1JLE1BQU07SUFDUkMsS0FBS0wseUNBQWlCO0lBQ3RCTSxPQUFPTixtQkFBT0EsQ0FBQztBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUMsR0FDRCxNQUFNTywyQkFBMkJSO0lBQzdCUyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxPQUFPQSxZQUFZLFlBQVlBLG1CQUFtQlAsV0FBVztZQUM3RE8sVUFBVTtnQkFDTkMsTUFBTUQ7WUFDVjtRQUNKLE9BQU87WUFDSEEsVUFBVU4sT0FBT00sU0FBUztnQkFBQztnQkFBUTtnQkFBVTtnQkFBVTthQUFVO1FBQ3JFO1FBQ0EsS0FBSyxDQUFDQTtJQUNWO0FBQ0o7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDREYsbUJBQW1CSSxTQUFTLENBQUNDLEtBQUssR0FBRztJQUVqQyxNQUFNQyxLQUFLLElBQUksQ0FBQ0MsTUFBTSxFQUFFTCxVQUFVSSxHQUFHSixPQUFPO0lBQzVDLE1BQU1NLEtBQUtOLFFBQVFDLElBQUksWUFBWVIsWUFBWU8sUUFBUUMsSUFBSSxHQUFHO0lBRTlELElBQUksQ0FBQ0csR0FBR0csT0FBTyxJQUFJLENBQUNELElBQUk7UUFDcEIsT0FBT0YsR0FBR0ksTUFBTTtJQUNwQjtJQUVBLE1BQU1DLFNB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QUFPLEdBQUc7SUFBQ2xDO0FBQWtCLEdBRXBDOzs7Ozs7OztDQVFDLElBRUQ7Ozs7Ozs7Ozs7Q0FVQyxJQUVEOzs7Ozs7OztDQVFDLElBRUQ7Ozs7Ozs7Q0FPQyxJQUVEOzs7Ozs7Ozs7Q0FTQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3R5cGVzL3BhcmFtZXRlcml6ZWQtcXVlcnkuanM/Y2MzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3Qge1NlcnZlckZvcm1hdHRpbmd9ID0gcmVxdWlyZSgnLi9zZXJ2ZXItZm9ybWF0dGluZycpO1xyXG5jb25zdCB7UGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3J9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbmNvbnN0IHtRdWVyeUZpbGV9ID0gcmVxdWlyZSgnLi4vcXVlcnktZmlsZScpO1xyXG5jb25zdCB7YXNzZXJ0fSA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgRU9MOiByZXF1aXJlKCdvcycpLkVPTCxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuLi91dGlscycpXHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIFBhcmFtZXRlcml6ZWRRdWVyeVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5fSBvYmplY3QuIEFsbCBwcm9wZXJ0aWVzIGNhbiBhbHNvIGJlIHNldCBhZnRlciB0aGUgb2JqZWN0J3MgY29uc3RydWN0aW9uLlxyXG4gKlxyXG4gKiBUaGlzIHR5cGUgZXh0ZW5kcyB0aGUgYmFzaWMgYHt0ZXh0LCB2YWx1ZXN9YCBvYmplY3QsIGkuZS4gd2hlbiB0aGUgYmFzaWMgb2JqZWN0IGlzIHVzZWQgd2l0aCBhIHF1ZXJ5IG1ldGhvZCxcclxuICogYSBuZXcge0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeX0gb2JqZWN0IGlzIGNyZWF0ZWQgaW4gaXRzIHBsYWNlLlxyXG4gKlxyXG4gKiBUaGUgdHlwZSBjYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgYHF1ZXJ5YCBwYXJhbWV0ZXIsIHdpdGggYW55IHF1ZXJ5IG1ldGhvZCBkaXJlY3RseS5cclxuICpcclxuICogVGhlIHR5cGUgaXMgYXZhaWxhYmxlIGZyb20gdGhlIGxpYnJhcnkncyByb290OiBgcGdwLlBhcmFtZXRlcml6ZWRRdWVyeWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfFF1ZXJ5RmlsZXxPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBPYmplY3QgY29uZmlndXJhdGlvbiBvcHRpb25zIC8gcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8UXVlcnlGaWxlfSBbb3B0aW9ucy50ZXh0XSAtIFNlZSBwcm9wZXJ0eSB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5I3RleHQgdGV4dH0uXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnZhbHVlc10gLSBTZWUgcHJvcGVydHkge0BsaW5rIFBhcmFtZXRlcml6ZWRRdWVyeSN2YWx1ZXMgdmFsdWVzfS5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iaW5hcnldIC0gU2VlIHByb3BlcnR5IHtAbGluayBQYXJhbWV0ZXJpemVkUXVlcnkjYmluYXJ5IGJpbmFyeX0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yb3dNb2RlXSAtIFNlZSBwcm9wZXJ0eSB7QGxpbmsgUGFyYW1ldGVyaXplZFF1ZXJ5I3Jvd01vZGUgcm93TW9kZX0uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtQYXJhbWV0ZXJpemVkUXVlcnl9XHJcbiAqXHJcbiAqIEBzZWVcclxuICoge0BsaW5rIGVycm9ycy5QYXJhbWV0ZXJpemVkUXVlcnlFcnJvciBQYXJhbWV0ZXJpemVkUXVlcnlFcnJvcn1cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3Qge1BhcmFtZXRlcml6ZWRRdWVyeTogUFF9ID0gcmVxdWlyZSgncGctcHJvbWlzZScpO1xyXG4gKlxyXG4gKiAvLyBDcmVhdGluZyBhIGNvbXBsZXRlIFBhcmFtZXRlcml6ZWQgUXVlcnkgd2l0aCBwYXJhbWV0ZXJzOlxyXG4gKiBjb25zdCBmaW5kVXNlciA9IG5ldyBQUSh7dGV4dDogJ1NFTEVDVCAqIEZST00gVXNlcnMgV0hFUkUgaWQgPSAkMScsIHZhbHVlczogWzEyM119KTtcclxuICpcclxuICogZGIub25lKGZpbmRVc2VyKVxyXG4gKiAgICAgLnRoZW4odXNlciA9PiB7XHJcbiAqICAgICAgICAgLy8gdXNlciBmb3VuZDtcclxuICogICAgIH0pXHJcbiAqICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gKiAgICAgICAgIC8vIGVycm9yO1xyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGNvbnN0IHtQYXJhbWV0ZXJpemVkUXVlcnk6IFBRfSA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKTtcclxuICpcclxuICogLy8gQ3JlYXRpbmcgYSByZXVzYWJsZSBQYXJhbWV0ZXJpemVkIFF1ZXJ5IHdpdGhvdXQgdmFsdWVzOlxyXG4gKiBjb25zdCBhZGRVc2VyID0gbmV3IFBRKCdJTlNFUlQgSU5UTyBVc2VycyhuYW1lLCBhZ2UpIFZBTFVFUygkMSwgJDIpJyk7XHJcbiAqXHJcbiAqIC8vIHNldHRpbmcgdmFsdWVzIGV4cGxpY2l0bHk6XHJcbiAqIGFkZFVzZXIudmFsdWVzID0gWydKb2huJywgMzBdO1xyXG4gKlxyXG4gKiBkYi5ub25lKGFkZFVzZXIpXHJcbiAqICAgICAudGhlbigoKSA9PiB7XHJcbiAqICAgICAgICAgLy8gdXNlciBhZGRlZDtcclxuICogICAgIH0pXHJcbiAqICAgICAuY2F0Y2goZXJyb3I9PiB7XHJcbiAqICAgICAgICAgLy8gZXJyb3I7XHJcbiAqICAgICB9KTtcclxuICpcclxuICogLy8gc2V0dGluZyB2YWx1ZXMgaW1wbGljaXRseSwgYnkgcGFzc2luZyB0aGVtIGludG8gdGhlIHF1ZXJ5IG1ldGhvZDpcclxuICogZGIubm9uZShhZGRVc2VyLCBbJ01pa2UnLCAyNV0pXHJcbiAqICAgICAudGhlbigoKSA9PiB7XHJcbiAqICAgICAgICAgLy8gdXNlciBhZGRlZDtcclxuICogICAgIH0pXHJcbiAqICAgICAuY2F0Y2goZXJyb3I9PiB7XHJcbiAqICAgICAgICAgLy8gZXJyb3I7XHJcbiAqICAgICB9KTtcclxuICovXHJcbmNsYXNzIFBhcmFtZXRlcml6ZWRRdWVyeSBleHRlbmRzIFNlcnZlckZvcm1hdHRpbmcge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIFF1ZXJ5RmlsZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogb3B0aW9uc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhc3NlcnQob3B0aW9ucywgWyd0ZXh0JywgJ3ZhbHVlcycsICdiaW5hcnknLCAncm93TW9kZSddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIFBhcmFtZXRlcml6ZWRRdWVyeSNwYXJzZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUGFyc2VzIHRoZSBjdXJyZW50IG9iamVjdCBhbmQgcmV0dXJucyBhIHNpbXBsZSBge3RleHQsIHZhbHVlc31gLCBpZiBzdWNjZXNzZnVsLFxyXG4gKiBvciBlbHNlIGl0IHJldHVybnMgYSB7QGxpbmsgZXJyb3JzLlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIFBhcmFtZXRlcml6ZWRRdWVyeUVycm9yfSBvYmplY3QuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7e3RleHQsIHZhbHVlc318ZXJyb3JzLlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yfVxyXG4gKi9cclxuUGFyYW1ldGVyaXplZFF1ZXJ5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyLCBvcHRpb25zID0gX2kub3B0aW9ucztcclxuICAgIGNvbnN0IHFmID0gb3B0aW9ucy50ZXh0IGluc3RhbmNlb2YgUXVlcnlGaWxlID8gb3B0aW9ucy50ZXh0IDogbnVsbDtcclxuXHJcbiAgICBpZiAoIV9pLmNoYW5nZWQgJiYgIXFmKSB7XHJcbiAgICAgICAgcmV0dXJuIF9pLnRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlcnJvcnMgPSBbXSwgdmFsdWVzID0gX2kudGFyZ2V0LnZhbHVlcztcclxuICAgIF9pLnRhcmdldCA9IHtcclxuICAgICAgICB0ZXh0OiBvcHRpb25zLnRleHRcclxuICAgIH07XHJcbiAgICBfaS5jaGFuZ2VkID0gdHJ1ZTtcclxuICAgIF9pLmN1cnJlbnRFcnJvciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAocWYpIHtcclxuICAgICAgICBxZi5wcmVwYXJlKCk7XHJcbiAgICAgICAgaWYgKHFmLmVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHFmLmVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfaS50YXJnZXQudGV4dCA9IHFmW1F1ZXJ5RmlsZS4kcXVlcnldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW5wbS51dGlscy5pc1RleHQoX2kudGFyZ2V0LnRleHQpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goJ1Byb3BlcnR5IFxcJ3RleHRcXCcgbXVzdCBiZSBhIG5vbi1lbXB0eSB0ZXh0IHN0cmluZy4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW5wbS51dGlscy5pc051bGwodmFsdWVzKSkge1xyXG4gICAgICAgIF9pLnRhcmdldC52YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuYmluYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBfaS50YXJnZXQuYmluYXJ5ID0gISFvcHRpb25zLmJpbmFyeTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5yb3dNb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBfaS50YXJnZXQucm93TW9kZSA9IG9wdGlvbnMucm93TW9kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBfaS5jdXJyZW50RXJyb3IgPSBuZXcgUGFyYW1ldGVyaXplZFF1ZXJ5RXJyb3IoZXJyb3JzWzBdLCBfaS50YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pLmNoYW5nZWQgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gX2kudGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgUGFyYW1ldGVyaXplZFF1ZXJ5I3RvU3RyaW5nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgd2VsbC1mb3JtYXR0ZWQgbXVsdGktbGluZSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QncyBjdXJyZW50IHN0YXRlLlxyXG4gKlxyXG4gKiBJdCBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHdyaXRpbmcgdGhlIG9iamVjdCBpbnRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xldmVsPTBdXHJcbiAqIE5lc3RlZCBvdXRwdXQgbGV2ZWwsIHRvIHByb3ZpZGUgdmlzdWFsIG9mZnNldC5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblBhcmFtZXRlcml6ZWRRdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgIGxldmVsID0gbGV2ZWwgPiAwID8gcGFyc2VJbnQobGV2ZWwpIDogMDtcclxuICAgIGNvbnN0IGdhcCA9IG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsICsgMSk7XHJcbiAgICBjb25zdCBwcSA9IHRoaXMucGFyc2UoKTtcclxuICAgIGNvbnN0IGxpbmVzID0gW1xyXG4gICAgICAgICdQYXJhbWV0ZXJpemVkUXVlcnkgeydcclxuICAgIF07XHJcbiAgICBpZiAobnBtLnV0aWxzLmlzVGV4dChwcS50ZXh0KSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwICsgJ3RleHQ6IFwiJyArIHBxLnRleHQgKyAnXCInKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAgKyAndmFsdWVzOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnZhbHVlcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYmluYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdiaW5hcnk6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMuYmluYXJ5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yb3dNb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdyb3dNb2RlOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnJvd01vZGUpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmVycm9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdlcnJvcjogJyArIHRoaXMuZXJyb3IudG9TdHJpbmcobGV2ZWwgKyAxKSk7XHJcbiAgICB9XHJcbiAgICBsaW5lcy5wdXNoKG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsKSArICd9Jyk7XHJcbiAgICByZXR1cm4gbGluZXMuam9pbihucG0uRU9MKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1BhcmFtZXRlcml6ZWRRdWVyeX07XHJcblxyXG4vKipcclxuICogQG5hbWUgUGFyYW1ldGVyaXplZFF1ZXJ5I3RleHRcclxuICogQHR5cGUge3N0cmluZ3xRdWVyeUZpbGV9XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIG5vbi1lbXB0eSBxdWVyeSBzdHJpbmcgb3IgYSB7QGxpbmsgUXVlcnlGaWxlfSBvYmplY3QuXHJcbiAqXHJcbiAqIE9ubHkgdGhlIGJhc2ljIHZhcmlhYmxlcyAoYCQxYCwgYCQyYCwgZXRjKSBjYW4gYmUgdXNlZCBpbiB0aGUgcXVlcnksIGJlY2F1c2UgX1BhcmFtZXRlcml6ZWQgUXVlcmllc19cclxuICogYXJlIGZvcm1hdHRlZCBvbiB0aGUgc2VydmVyIHNpZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lIFBhcmFtZXRlcml6ZWRRdWVyeSN2YWx1ZXNcclxuICogQHR5cGUge2FycmF5fVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUXVlcnkgZm9ybWF0dGluZyBwYXJhbWV0ZXJzLCBkZXBlbmRpbmcgb24gdGhlIHR5cGU6XHJcbiAqXHJcbiAqIC0gYG51bGxgIC8gYHVuZGVmaW5lZGAgbWVhbnMgdGhlIHF1ZXJ5IGhhcyBubyBmb3JtYXR0aW5nIHBhcmFtZXRlcnNcclxuICogLSBgQXJyYXlgIC0gaXQgaXMgYW4gYXJyYXkgb2YgZm9ybWF0dGluZyBwYXJhbWV0ZXJzXHJcbiAqIC0gTm9uZSBvZiB0aGUgYWJvdmUsIG1lYW5zIGl0IGlzIGEgc2luZ2xlIGZvcm1hdHRpbmcgdmFsdWUsIHdoaWNoXHJcbiAqICAgaXMgdGhlbiBhdXRvbWF0aWNhbGx5IHdyYXBwZWQgaW50byBhbiBhcnJheVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBQYXJhbWV0ZXJpemVkUXVlcnkjYmluYXJ5XHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFjdGl2YXRlcyBiaW5hcnkgcmVzdWx0IG1vZGUuIFRoZSBkZWZhdWx0IGlzIHRoZSB0ZXh0IG1vZGUuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9kZXZlbC9zdGF0aWMvcHJvdG9jb2wtZmxvdy5odG1sI1BST1RPQ09MLUZMT1ctRVhULVFVRVJZIEV4dGVuZGVkIFF1ZXJ5fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBQYXJhbWV0ZXJpemVkUXVlcnkjcm93TW9kZVxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENoYW5nZXMgdGhlIHdheSBkYXRhIGFycml2ZXMgdG8gdGhlIGNsaWVudCwgd2l0aCBvbmx5IG9uZSB2YWx1ZSBzdXBwb3J0ZWQgYnkgJFtwZ106XHJcbiAqICAtIGBhcnJheWAgd2lsbCBtYWtlIGFsbCBkYXRhIHJvd3MgYXJyaXZlIGFzIGFycmF5cyBvZiB2YWx1ZXMuIEJ5IGRlZmF1bHQsIHJvd3MgYXJyaXZlIGFzIG9iamVjdHMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lIFBhcmFtZXRlcml6ZWRRdWVyeSNlcnJvclxyXG4gKiBAdHlwZSB7ZXJyb3JzLlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yfVxyXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICogQHJlYWRvbmx5XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBXaGVuIGluIGFuIGVycm9yIHN0YXRlLCBpdCBpcyBzZXQgdG8gYSB7QGxpbmsgZXJyb3JzLlBhcmFtZXRlcml6ZWRRdWVyeUVycm9yIFBhcmFtZXRlcml6ZWRRdWVyeUVycm9yfSBvYmplY3QuIE90aGVyd2lzZSwgaXQgaXMgYHVuZGVmaW5lZGAuXHJcbiAqXHJcbiAqIFRoaXMgcHJvcGVydHkgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkuXHJcbiAqL1xyXG4iXSwibmFtZXMiOlsiU2VydmVyRm9ybWF0dGluZyIsInJlcXVpcmUiLCJQYXJhbWV0ZXJpemVkUXVlcnlFcnJvciIsIlF1ZXJ5RmlsZSIsImFzc2VydCIsIm5wbSIsIkVPTCIsInV0aWxzIiwiUGFyYW1ldGVyaXplZFF1ZXJ5IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidGV4dCIsInByb3RvdHlwZSIsInBhcnNlIiwiX2kiLCJfaW5uZXIiLCJxZiIsImNoYW5nZWQiLCJ0YXJnZXQiLCJlcnJvcnMiLCJ2YWx1ZXMiLCJjdXJyZW50RXJyb3IiLCJ1bmRlZmluZWQiLCJwcmVwYXJlIiwiZXJyb3IiLCJwdXNoIiwiJHF1ZXJ5IiwiaXNUZXh0IiwiaXNOdWxsIiwiYmluYXJ5Iiwicm93TW9kZSIsImxlbmd0aCIsInRvU3RyaW5nIiwibGV2ZWwiLCJwYXJzZUludCIsImdhcCIsIm1lc3NhZ2VHYXAiLCJwcSIsImxpbmVzIiwidG9Kc29uIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/types/parameterized-query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/types/prepared-statement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pg-promise/lib/types/prepared-statement.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { ServerFormatting } = __webpack_require__(/*! ./server-formatting */ \"(rsc)/./node_modules/pg-promise/lib/types/server-formatting.js\");\nconst { PreparedStatementError } = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/pg-promise/lib/errors/index.js\");\nconst { QueryFile } = __webpack_require__(/*! ../query-file */ \"(rsc)/./node_modules/pg-promise/lib/query-file.js\");\nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    EOL: (__webpack_require__(/*! os */ \"os\").EOL),\n    utils: __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\")\n};\n/**\r\n * @class PreparedStatement\r\n * @description\r\n * Constructs a new $[Prepared Statement] object. All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {Object} [options]\r\n * Object configuration options / properties.\r\n *\r\n * @param {string} [options.name] - See property {@link PreparedStatement#name name}.\r\n * @param {string|QueryFile} [options.text] - See property {@link PreparedStatement#text text}.\r\n * @param {array} [options.values] - See property {@link PreparedStatement#values values}.\r\n * @param {boolean} [options.binary] - See property {@link PreparedStatement#binary binary}.\r\n * @param {string} [options.rowMode] - See property {@link PreparedStatement#rowMode rowMode}.\r\n * @param {number} [options.rows] - See property {@link PreparedStatement#rows rows}.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.6/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * const findUser = new PS({name: 'find-user', text: 'SELECT * FROM Users WHERE id = $1', values: [123]});\r\n *\r\n * db.one(findUser)\r\n *     .then(user => {\r\n *         // user found;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * const {PreparedStatement: PS} = require('pg-promise');\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * const addUser = new PS({name: 'add-user', text: 'INSERT INTO Users(name, age) VALUES($1, $2)'});\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(() => {\r\n *         // user added;\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */ class PreparedStatement extends ServerFormatting {\n    constructor(options){\n        options = assert(options, [\n            \"name\",\n            \"text\",\n            \"values\",\n            \"binary\",\n            \"rowMode\",\n            \"rows\"\n        ]);\n        super(options);\n    }\n    /**\r\n     * @name PreparedStatement#name\r\n     * @type {string}\r\n     * @description\r\n     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n     * subsequently used to execute or deallocate a previously prepared statement.\r\n     */ get name() {\n        return this._inner.options.name;\n    }\n    set name(value) {\n        const _i = this._inner;\n        if (value !== _i.options.name) {\n            _i.options.name = value;\n            _i.changed = true;\n        }\n    }\n    /**\r\n     * @name PreparedStatement#rows\r\n     * @type {number}\r\n     * @description\r\n     * Number of rows to return at a time from a Prepared Statement's portal.\r\n     * The default is 0, which means that all rows must be returned at once.\r\n     */ get rows() {\n        return this._inner.options.rows;\n    }\n    set rows(value) {\n        const _i = this._inner;\n        if (value !== _i.options.rows) {\n            _i.options.rows = value;\n            _i.changed = true;\n        }\n    }\n}\n/**\r\n * @method PreparedStatement#parse\r\n * @description\r\n * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n *\r\n * This method is primarily for internal use by the library.\r\n *\r\n * @returns {{name, text, values}|errors.PreparedStatementError}\r\n */ PreparedStatement.prototype.parse = function() {\n    const _i = this._inner, options = _i.options;\n    const qf = options.text instanceof QueryFile ? options.text : null;\n    if (!_i.changed && !qf) {\n        return _i.target;\n    }\n    const errors = [], values = _i.target.values;\n    _i.target = {\n        name: options.name,\n        text: options.text\n    };\n    _i.changed = true;\n    _i.currentError = undefined;\n    if (!npm.utils.isText(_i.target.name)) {\n        errors.push(\"Property 'name' must be a non-empty text string.\");\n    }\n    if (qf) {\n        qf.prepare();\n        if (qf.error) {\n            errors.push(qf.error);\n        } else {\n            _i.target.text = qf[QueryFile.$query];\n        }\n    }\n    if (!npm.utils.isText(_i.target.text)) {\n        errors.push(\"Property 'text' must be a non-empty text string.\");\n    }\n    if (!npm.utils.isNull(values)) {\n        _i.target.values = values;\n    }\n    if (options.binary !== undefined) {\n        _i.target.binary = !!options.binary;\n    }\n    if (options.rowMode !== undefined) {\n        _i.target.rowMode = options.rowMode;\n    }\n    if (options.rows !== undefined) {\n        _i.target.rows = options.rows;\n    }\n    if (errors.length) {\n        return _i.currentError = new PreparedStatementError(errors[0], _i.target);\n    }\n    _i.changed = false;\n    return _i.target;\n};\n/**\r\n * @method PreparedStatement#toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */ PreparedStatement.prototype.toString = function(level) {\n    level = level > 0 ? parseInt(level) : 0;\n    const gap = npm.utils.messageGap(level + 1);\n    const ps = this.parse();\n    const lines = [\n        \"PreparedStatement {\",\n        gap + \"name: \" + npm.utils.toJson(this.name)\n    ];\n    if (npm.utils.isText(ps.text)) {\n        lines.push(gap + 'text: \"' + ps.text + '\"');\n    }\n    if (this.values !== undefined) {\n        lines.push(gap + \"values: \" + npm.utils.toJson(this.values));\n    }\n    if (this.binary !== undefined) {\n        lines.push(gap + \"binary: \" + npm.utils.toJson(this.binary));\n    }\n    if (this.rowMode !== undefined) {\n        lines.push(gap + \"rowMode: \" + npm.utils.toJson(this.rowMode));\n    }\n    if (this.rows !== undefined) {\n        lines.push(gap + \"rows: \" + npm.utils.toJson(this.rows));\n    }\n    if (this.error) {\n        lines.push(gap + \"error: \" + this.error.toString(level + 1));\n    }\n    lines.push(npm.utils.messageGap(level) + \"}\");\n    return lines.join(npm.EOL);\n};\nmodule.exports = {\n    PreparedStatement\n}; /**\r\n * @name PreparedStatement#text\r\n * @type {string|QueryFile}\r\n * @description\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements]\r\n * are formatted on the server side.\r\n *\r\n * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n * for Prepared Statements are cached by the server, with {@link PreparedStatement#name name} being the cache key.\r\n */  /**\r\n * @name PreparedStatement#values\r\n * @type {array}\r\n * @description\r\n * Query formatting parameters, depending on the type:\r\n *\r\n * - `null` / `undefined` means the query has no formatting parameters\r\n * - `Array` - it is an array of formatting parameters\r\n * - None of the above, means it is a single formatting value, which\r\n *   is then automatically wrapped into an array\r\n */  /**\r\n * @name PreparedStatement#binary\r\n * @type {boolean}\r\n * @default undefined\r\n * @description\r\n * Activates binary result mode. The default is the text mode.\r\n *\r\n * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n */  /**\r\n * @name PreparedStatement#rowMode\r\n * @type {string}\r\n * @default undefined\r\n * @description\r\n * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n *  - `array` will make all data rows arrive as arrays of values. By default, rows arrive as objects.\r\n */  /**\r\n * @name PreparedStatement#error\r\n * @type {errors.PreparedStatementError}\r\n * @default undefined\r\n * @description\r\n * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n *\r\n * This property is primarily for internal use by the library.\r\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHlwZXMvcHJlcGFyZWQtc3RhdGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLGdCQUFnQixFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBQ0Msc0JBQXNCLEVBQUMsR0FBR0QsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFDRSxTQUFTLEVBQUMsR0FBR0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFDRyxNQUFNLEVBQUMsR0FBR0gsbUJBQU9BLENBQUM7QUFFekIsTUFBTUksTUFBTTtJQUNSQyxLQUFLTCx5Q0FBaUI7SUFDdEJNLE9BQU9OLG1CQUFPQSxDQUFDO0FBQ25CO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFFQyxHQUNELE1BQU1PLDBCQUEwQlI7SUFDNUJTLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQkEsVUFBVU4sT0FBT00sU0FBUztZQUFDO1lBQVE7WUFBUTtZQUFVO1lBQVU7WUFBVztTQUFPO1FBQ2pGLEtBQUssQ0FBQ0E7SUFDVjtJQUVBOzs7Ozs7S0FNQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDRixPQUFPLENBQUNDLElBQUk7SUFDbkM7SUFFQSxJQUFJQSxLQUFLRSxLQUFLLEVBQUU7UUFDWixNQUFNQyxLQUFLLElBQUksQ0FBQ0YsTUFBTTtRQUN0QixJQUFJQyxVQUFVQyxHQUFHSixPQUFPLENBQUNDLElBQUksRUFBRTtZQUMzQkcsR0FBR0osT0FBTyxDQUFDQyxJQUFJLEdBQUdFO1lBQ2xCQyxHQUFHQyxPQUFPLEdBQUc7UUFDakI7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDRixPQUFPLENBQUNNLElB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Ozs7Ozs7OztDQVFDLElBRUQ7Ozs7Ozs7Q0FPQyxJQUVEOzs7Ozs7OztDQVFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHlwZXMvcHJlcGFyZWQtc3RhdGVtZW50LmpzP2YxZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFZpdGFseSBUb21pbG92XHJcbiAqXHJcbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uXHJcbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxyXG4gKi9cclxuXHJcbmNvbnN0IHtTZXJ2ZXJGb3JtYXR0aW5nfSA9IHJlcXVpcmUoJy4vc2VydmVyLWZvcm1hdHRpbmcnKTtcclxuY29uc3Qge1ByZXBhcmVkU3RhdGVtZW50RXJyb3J9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XHJcbmNvbnN0IHtRdWVyeUZpbGV9ID0gcmVxdWlyZSgnLi4vcXVlcnktZmlsZScpO1xyXG5jb25zdCB7YXNzZXJ0fSA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgRU9MOiByZXF1aXJlKCdvcycpLkVPTCxcclxuICAgIHV0aWxzOiByZXF1aXJlKCcuLi91dGlscycpXHJcbn07XHJcblxyXG4vKipcclxuICogQGNsYXNzIFByZXBhcmVkU3RhdGVtZW50XHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3ICRbUHJlcGFyZWQgU3RhdGVtZW50XSBvYmplY3QuIEFsbCBwcm9wZXJ0aWVzIGNhbiBhbHNvIGJlIHNldCBhZnRlciB0aGUgb2JqZWN0J3MgY29uc3RydWN0aW9uLlxyXG4gKlxyXG4gKiBUaGlzIHR5cGUgZXh0ZW5kcyB0aGUgYmFzaWMgYHtuYW1lLCB0ZXh0LCB2YWx1ZXN9YCBvYmplY3QsIGkuZS4gd2hlbiB0aGUgYmFzaWMgb2JqZWN0IGlzIHVzZWRcclxuICogd2l0aCBhIHF1ZXJ5IG1ldGhvZCwgYSBuZXcge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50fSBvYmplY3QgaXMgY3JlYXRlZCBpbiBpdHMgcGxhY2UuXHJcbiAqXHJcbiAqIFRoZSB0eXBlIGNhbiBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZSBgcXVlcnlgIHBhcmFtZXRlciwgd2l0aCBhbnkgcXVlcnkgbWV0aG9kIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBUaGUgdHlwZSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgbGlicmFyeSdzIHJvb3Q6IGBwZ3AuUHJlcGFyZWRTdGF0ZW1lbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIE9iamVjdCBjb25maWd1cmF0aW9uIG9wdGlvbnMgLyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gLSBTZWUgcHJvcGVydHkge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I25hbWUgbmFtZX0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfFF1ZXJ5RmlsZX0gW29wdGlvbnMudGV4dF0gLSBTZWUgcHJvcGVydHkge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I3RleHQgdGV4dH0uXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnZhbHVlc10gLSBTZWUgcHJvcGVydHkge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I3ZhbHVlcyB2YWx1ZXN9LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gLSBTZWUgcHJvcGVydHkge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I2JpbmFyeSBiaW5hcnl9LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm93TW9kZV0gLSBTZWUgcHJvcGVydHkge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I3Jvd01vZGUgcm93TW9kZX0uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yb3dzXSAtIFNlZSBwcm9wZXJ0eSB7QGxpbmsgUHJlcGFyZWRTdGF0ZW1lbnQjcm93cyByb3dzfS5cclxuICpcclxuICogQHJldHVybnMge1ByZXBhcmVkU3RhdGVtZW50fVxyXG4gKlxyXG4gKiBAc2VlXHJcbiAqIHtAbGluayBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciBQcmVwYXJlZFN0YXRlbWVudEVycm9yfSxcclxuICoge0BsaW5rIGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjYvc3RhdGljL3NxbC1wcmVwYXJlLmh0bWwgUG9zdGdyZVNRTCBQcmVwYXJlZCBTdGF0ZW1lbnRzfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBjb25zdCB7UHJlcGFyZWRTdGF0ZW1lbnQ6IFBTfSA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKTtcclxuICpcclxuICogLy8gQ3JlYXRpbmcgYSBjb21wbGV0ZSBQcmVwYXJlZCBTdGF0ZW1lbnQgd2l0aCBwYXJhbWV0ZXJzOlxyXG4gKiBjb25zdCBmaW5kVXNlciA9IG5ldyBQUyh7bmFtZTogJ2ZpbmQtdXNlcicsIHRleHQ6ICdTRUxFQ1QgKiBGUk9NIFVzZXJzIFdIRVJFIGlkID0gJDEnLCB2YWx1ZXM6IFsxMjNdfSk7XHJcbiAqXHJcbiAqIGRiLm9uZShmaW5kVXNlcilcclxuICogICAgIC50aGVuKHVzZXIgPT4ge1xyXG4gKiAgICAgICAgIC8vIHVzZXIgZm91bmQ7XHJcbiAqICAgICB9KVxyXG4gKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICogICAgICAgICAvLyBlcnJvcjtcclxuICogICAgIH0pO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBjb25zdCB7UHJlcGFyZWRTdGF0ZW1lbnQ6IFBTfSA9IHJlcXVpcmUoJ3BnLXByb21pc2UnKTtcclxuICpcclxuICogLy8gQ3JlYXRpbmcgYSByZXVzYWJsZSBQcmVwYXJlZCBTdGF0ZW1lbnQgd2l0aG91dCB2YWx1ZXM6XHJcbiAqIGNvbnN0IGFkZFVzZXIgPSBuZXcgUFMoe25hbWU6ICdhZGQtdXNlcicsIHRleHQ6ICdJTlNFUlQgSU5UTyBVc2VycyhuYW1lLCBhZ2UpIFZBTFVFUygkMSwgJDIpJ30pO1xyXG4gKlxyXG4gKiAvLyBzZXR0aW5nIHZhbHVlcyBleHBsaWNpdGx5OlxyXG4gKiBhZGRVc2VyLnZhbHVlcyA9IFsnSm9obicsIDMwXTtcclxuICpcclxuICogZGIubm9uZShhZGRVc2VyKVxyXG4gKiAgICAgLnRoZW4oKCkgPT4ge1xyXG4gKiAgICAgICAgIC8vIHVzZXIgYWRkZWQ7XHJcbiAqICAgICB9KVxyXG4gKiAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICogICAgICAgICAvLyBlcnJvcjtcclxuICogICAgIH0pO1xyXG4gKlxyXG4gKiAvLyBzZXR0aW5nIHZhbHVlcyBpbXBsaWNpdGx5LCBieSBwYXNzaW5nIHRoZW0gaW50byB0aGUgcXVlcnkgbWV0aG9kOlxyXG4gKiBkYi5ub25lKGFkZFVzZXIsIFsnTWlrZScsIDI1XSlcclxuICogICAgIC50aGVuKCgpID0+IHtcclxuICogICAgICAgICAvLyB1c2VyIGFkZGVkO1xyXG4gKiAgICAgfSlcclxuICogICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAqICAgICAgICAgLy8gZXJyb3I7XHJcbiAqICAgICB9KTtcclxuICovXHJcbmNsYXNzIFByZXBhcmVkU3RhdGVtZW50IGV4dGVuZHMgU2VydmVyRm9ybWF0dGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFzc2VydChvcHRpb25zLCBbJ25hbWUnLCAndGV4dCcsICd2YWx1ZXMnLCAnYmluYXJ5JywgJ3Jvd01vZGUnLCAncm93cyddKTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFByZXBhcmVkU3RhdGVtZW50I25hbWVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEFuIGFyYml0cmFyeSBuYW1lIGdpdmVuIHRvIHRoaXMgcGFydGljdWxhciBwcmVwYXJlZCBzdGF0ZW1lbnQuIEl0IG11c3QgYmUgdW5pcXVlIHdpdGhpbiBhIHNpbmdsZSBzZXNzaW9uIGFuZCBpc1xyXG4gICAgICogc3Vic2VxdWVudGx5IHVzZWQgdG8gZXhlY3V0ZSBvciBkZWFsbG9jYXRlIGEgcHJldmlvdXNseSBwcmVwYXJlZCBzdGF0ZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lci5vcHRpb25zLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IG5hbWUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gX2kub3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgICAgICAgIF9pLm9wdGlvbnMubmFtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfaS5jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBQcmVwYXJlZFN0YXRlbWVudCNyb3dzXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBOdW1iZXIgb2Ygcm93cyB0byByZXR1cm4gYXQgYSB0aW1lIGZyb20gYSBQcmVwYXJlZCBTdGF0ZW1lbnQncyBwb3J0YWwuXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLCB3aGljaCBtZWFucyB0aGF0IGFsbCByb3dzIG11c3QgYmUgcmV0dXJuZWQgYXQgb25jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvd3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLm9wdGlvbnMucm93cztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgcm93cyh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IF9pID0gdGhpcy5faW5uZXI7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBfaS5vcHRpb25zLnJvd3MpIHtcclxuICAgICAgICAgICAgX2kub3B0aW9ucy5yb3dzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF9pLmNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgUHJlcGFyZWRTdGF0ZW1lbnQjcGFyc2VcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFBhcnNlcyB0aGUgY3VycmVudCBvYmplY3QgYW5kIHJldHVybnMgYSBzaW1wbGUgYHtuYW1lLCB0ZXh0LCB2YWx1ZXN9YCwgaWYgc3VjY2Vzc2Z1bCxcclxuICogb3IgZWxzZSBpdCByZXR1cm5zIGEge0BsaW5rIGVycm9ycy5QcmVwYXJlZFN0YXRlbWVudEVycm9yIFByZXBhcmVkU3RhdGVtZW50RXJyb3J9IG9iamVjdC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt7bmFtZSwgdGV4dCwgdmFsdWVzfXxlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvcn1cclxuICovXHJcblByZXBhcmVkU3RhdGVtZW50LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyLCBvcHRpb25zID0gX2kub3B0aW9ucztcclxuXHJcbiAgICBjb25zdCBxZiA9IG9wdGlvbnMudGV4dCBpbnN0YW5jZW9mIFF1ZXJ5RmlsZSA/IG9wdGlvbnMudGV4dCA6IG51bGw7XHJcblxyXG4gICAgaWYgKCFfaS5jaGFuZ2VkICYmICFxZikge1xyXG4gICAgICAgIHJldHVybiBfaS50YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXJyb3JzID0gW10sIHZhbHVlcyA9IF9pLnRhcmdldC52YWx1ZXM7XHJcbiAgICBfaS50YXJnZXQgPSB7XHJcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxyXG4gICAgICAgIHRleHQ6IG9wdGlvbnMudGV4dFxyXG4gICAgfTtcclxuICAgIF9pLmNoYW5nZWQgPSB0cnVlO1xyXG4gICAgX2kuY3VycmVudEVycm9yID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmICghbnBtLnV0aWxzLmlzVGV4dChfaS50YXJnZXQubmFtZSkpIHtcclxuICAgICAgICBlcnJvcnMucHVzaCgnUHJvcGVydHkgXFwnbmFtZVxcJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHRleHQgc3RyaW5nLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChxZikge1xyXG4gICAgICAgIHFmLnByZXBhcmUoKTtcclxuICAgICAgICBpZiAocWYuZXJyb3IpIHtcclxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocWYuZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9pLnRhcmdldC50ZXh0ID0gcWZbUXVlcnlGaWxlLiRxdWVyeV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFucG0udXRpbHMuaXNUZXh0KF9pLnRhcmdldC50ZXh0KSkge1xyXG4gICAgICAgIGVycm9ycy5wdXNoKCdQcm9wZXJ0eSBcXCd0ZXh0XFwnIG11c3QgYmUgYSBub24tZW1wdHkgdGV4dCBzdHJpbmcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFucG0udXRpbHMuaXNOdWxsKHZhbHVlcykpIHtcclxuICAgICAgICBfaS50YXJnZXQudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmJpbmFyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2kudGFyZ2V0LmJpbmFyeSA9ICEhb3B0aW9ucy5iaW5hcnk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMucm93TW9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2kudGFyZ2V0LnJvd01vZGUgPSBvcHRpb25zLnJvd01vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMucm93cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2kudGFyZ2V0LnJvd3MgPSBvcHRpb25zLnJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gX2kuY3VycmVudEVycm9yID0gbmV3IFByZXBhcmVkU3RhdGVtZW50RXJyb3IoZXJyb3JzWzBdLCBfaS50YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pLmNoYW5nZWQgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gX2kudGFyZ2V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgUHJlcGFyZWRTdGF0ZW1lbnQjdG9TdHJpbmdcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB3ZWxsLWZvcm1hdHRlZCBtdWx0aS1saW5lIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIG9iamVjdCdzIGN1cnJlbnQgc3RhdGUuXHJcbiAqXHJcbiAqIEl0IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gd3JpdGluZyB0aGUgb2JqZWN0IGludG8gdGhlIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWw9MF1cclxuICogTmVzdGVkIG91dHB1dCBsZXZlbCwgdG8gcHJvdmlkZSB2aXN1YWwgb2Zmc2V0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuUHJlcGFyZWRTdGF0ZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICBsZXZlbCA9IGxldmVsID4gMCA/IHBhcnNlSW50KGxldmVsKSA6IDA7XHJcbiAgICBjb25zdCBnYXAgPSBucG0udXRpbHMubWVzc2FnZUdhcChsZXZlbCArIDEpO1xyXG4gICAgY29uc3QgcHMgPSB0aGlzLnBhcnNlKCk7XHJcbiAgICBjb25zdCBsaW5lcyA9IFtcclxuICAgICAgICAnUHJlcGFyZWRTdGF0ZW1lbnQgeycsXHJcbiAgICAgICAgZ2FwICsgJ25hbWU6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMubmFtZSlcclxuICAgIF07XHJcbiAgICBpZiAobnBtLnV0aWxzLmlzVGV4dChwcy50ZXh0KSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwICsgJ3RleHQ6IFwiJyArIHBzLnRleHQgKyAnXCInKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChnYXAgKyAndmFsdWVzOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnZhbHVlcykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYmluYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdiaW5hcnk6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMuYmluYXJ5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yb3dNb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdyb3dNb2RlOiAnICsgbnBtLnV0aWxzLnRvSnNvbih0aGlzLnJvd01vZGUpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnJvd3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goZ2FwICsgJ3Jvd3M6ICcgKyBucG0udXRpbHMudG9Kc29uKHRoaXMucm93cykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGdhcCArICdlcnJvcjogJyArIHRoaXMuZXJyb3IudG9TdHJpbmcobGV2ZWwgKyAxKSk7XHJcbiAgICB9XHJcbiAgICBsaW5lcy5wdXNoKG5wbS51dGlscy5tZXNzYWdlR2FwKGxldmVsKSArICd9Jyk7XHJcbiAgICByZXR1cm4gbGluZXMuam9pbihucG0uRU9MKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1ByZXBhcmVkU3RhdGVtZW50fTtcclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBQcmVwYXJlZFN0YXRlbWVudCN0ZXh0XHJcbiAqIEB0eXBlIHtzdHJpbmd8UXVlcnlGaWxlfVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBub24tZW1wdHkgcXVlcnkgc3RyaW5nIG9yIGEge0BsaW5rIFF1ZXJ5RmlsZX0gb2JqZWN0LlxyXG4gKlxyXG4gKiBPbmx5IHRoZSBiYXNpYyB2YXJpYWJsZXMgKGAkMWAsIGAkMmAsIGV0YykgY2FuIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5LCBiZWNhdXNlICRbUHJlcGFyZWQgU3RhdGVtZW50c11cclxuICogYXJlIGZvcm1hdHRlZCBvbiB0aGUgc2VydmVyIHNpZGUuXHJcbiAqXHJcbiAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZm9yIHRoZSBzYW1lIHtAbGluayBQcmVwYXJlZFN0YXRlbWVudCNuYW1lIG5hbWV9IHdpbGwgaGF2ZSBubyBlZmZlY3QsIGJlY2F1c2UgcXVlcmllc1xyXG4gKiBmb3IgUHJlcGFyZWQgU3RhdGVtZW50cyBhcmUgY2FjaGVkIGJ5IHRoZSBzZXJ2ZXIsIHdpdGgge0BsaW5rIFByZXBhcmVkU3RhdGVtZW50I25hbWUgbmFtZX0gYmVpbmcgdGhlIGNhY2hlIGtleS5cclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWUgUHJlcGFyZWRTdGF0ZW1lbnQjdmFsdWVzXHJcbiAqIEB0eXBlIHthcnJheX1cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFF1ZXJ5IGZvcm1hdHRpbmcgcGFyYW1ldGVycywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlOlxyXG4gKlxyXG4gKiAtIGBudWxsYCAvIGB1bmRlZmluZWRgIG1lYW5zIHRoZSBxdWVyeSBoYXMgbm8gZm9ybWF0dGluZyBwYXJhbWV0ZXJzXHJcbiAqIC0gYEFycmF5YCAtIGl0IGlzIGFuIGFycmF5IG9mIGZvcm1hdHRpbmcgcGFyYW1ldGVyc1xyXG4gKiAtIE5vbmUgb2YgdGhlIGFib3ZlLCBtZWFucyBpdCBpcyBhIHNpbmdsZSBmb3JtYXR0aW5nIHZhbHVlLCB3aGljaFxyXG4gKiAgIGlzIHRoZW4gYXV0b21hdGljYWxseSB3cmFwcGVkIGludG8gYW4gYXJyYXlcclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWUgUHJlcGFyZWRTdGF0ZW1lbnQjYmluYXJ5XHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFjdGl2YXRlcyBiaW5hcnkgcmVzdWx0IG1vZGUuIFRoZSBkZWZhdWx0IGlzIHRoZSB0ZXh0IG1vZGUuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9kZXZlbC9zdGF0aWMvcHJvdG9jb2wtZmxvdy5odG1sI1BST1RPQ09MLUZMT1ctRVhULVFVRVJZIEV4dGVuZGVkIFF1ZXJ5fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBQcmVwYXJlZFN0YXRlbWVudCNyb3dNb2RlXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ2hhbmdlcyB0aGUgd2F5IGRhdGEgYXJyaXZlcyB0byB0aGUgY2xpZW50LCB3aXRoIG9ubHkgb25lIHZhbHVlIHN1cHBvcnRlZCBieSAkW3BnXTpcclxuICogIC0gYGFycmF5YCB3aWxsIG1ha2UgYWxsIGRhdGEgcm93cyBhcnJpdmUgYXMgYXJyYXlzIG9mIHZhbHVlcy4gQnkgZGVmYXVsdCwgcm93cyBhcnJpdmUgYXMgb2JqZWN0cy5cclxuICovXHJcblxyXG4vKipcclxuICogQG5hbWUgUHJlcGFyZWRTdGF0ZW1lbnQjZXJyb3JcclxuICogQHR5cGUge2Vycm9ycy5QcmVwYXJlZFN0YXRlbWVudEVycm9yfVxyXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFdoZW4gaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGlzIHNldCB0byBhIHtAbGluayBlcnJvcnMuUHJlcGFyZWRTdGF0ZW1lbnRFcnJvciBQcmVwYXJlZFN0YXRlbWVudEVycm9yfSBvYmplY3QuIE90aGVyd2lzZSwgaXQgaXMgYHVuZGVmaW5lZGAuXHJcbiAqXHJcbiAqIFRoaXMgcHJvcGVydHkgaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIGxpYnJhcnkuXHJcbiAqL1xyXG4iXSwibmFtZXMiOlsiU2VydmVyRm9ybWF0dGluZyIsInJlcXVpcmUiLCJQcmVwYXJlZFN0YXRlbWVudEVycm9yIiwiUXVlcnlGaWxlIiwiYXNzZXJ0IiwibnBtIiwiRU9MIiwidXRpbHMiLCJQcmVwYXJlZFN0YXRlbWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIm5hbWUiLCJfaW5uZXIiLCJ2YWx1ZSIsIl9pIiwiY2hhbmdlZCIsInJvd3MiLCJwcm90b3R5cGUiLCJwYXJzZSIsInFmIiwidGV4dCIsInRhcmdldCIsImVycm9ycyIsInZhbHVlcyIsImN1cnJlbnRFcnJvciIsInVuZGVmaW5lZCIsImlzVGV4dCIsInB1c2giLCJwcmVwYXJlIiwiZXJyb3IiLCIkcXVlcnkiLCJpc051bGwiLCJiaW5hcnkiLCJyb3dNb2RlIiwibGVuZ3RoIiwidG9TdHJpbmciLCJsZXZlbCIsInBhcnNlSW50IiwiZ2FwIiwibWVzc2FnZUdhcCIsInBzIiwibGluZXMiLCJ0b0pzb24iLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/types/prepared-statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/types/server-formatting.js":
/*!****************************************************************!*\
  !*** ./node_modules/pg-promise/lib/types/server-formatting.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InnerState } = __webpack_require__(/*! ../inner-state */ \"(rsc)/./node_modules/pg-promise/lib/inner-state.js\");\nconst { addInspection } = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\");\n/**\r\n * @private\r\n * @class ServerFormatting\r\n */ class ServerFormatting extends InnerState {\n    constructor(options){\n        const _inner = {\n            options,\n            changed: true,\n            currentError: undefined,\n            target: {}\n        };\n        super(_inner);\n        setValues.call(this, options.values);\n    }\n    get error() {\n        return this._inner.currentError;\n    }\n    get text() {\n        return this._inner.options.text;\n    }\n    set text(value) {\n        const _i = this._inner;\n        if (value !== _i.options.text) {\n            _i.options.text = value;\n            _i.changed = true;\n        }\n    }\n    get binary() {\n        return this._inner.options.binary;\n    }\n    set binary(value) {\n        const _i = this._inner;\n        if (value !== _i.options.binary) {\n            _i.options.binary = value;\n            _i.changed = true;\n        }\n    }\n    get rowMode() {\n        return this._inner.options.rowMode;\n    }\n    set rowMode(value) {\n        const _i = this._inner;\n        if (value !== _i.options.rowMode) {\n            _i.options.rowMode = value;\n            _i.changed = true;\n        }\n    }\n    get values() {\n        return this._inner.target.values;\n    }\n    set values(values) {\n        setValues.call(this, values);\n    }\n}\n/**\r\n * @member ServerFormatting#parse\r\n */ function setValues(v) {\n    const target = this._inner.target;\n    if (Array.isArray(v)) {\n        if (v.length) {\n            target.values = v;\n        } else {\n            delete target.values;\n        }\n    } else {\n        if (utils.isNull(v)) {\n            delete target.values;\n        } else {\n            target.values = [\n                v\n            ];\n        }\n    }\n}\naddInspection(ServerFormatting, function() {\n    return this.toString();\n});\nmodule.exports = {\n    ServerFormatting\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdHlwZXMvc2VydmVyLWZvcm1hdHRpbmcuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sRUFBQ0EsVUFBVSxFQUFDLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBQ0MsYUFBYSxFQUFDLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBRXRCOzs7Q0FHQyxHQUNELE1BQU1HLHlCQUF5Qko7SUFFM0JLLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixNQUFNQyxTQUFTO1lBQ1hEO1lBQ0FFLFNBQVM7WUFDVEMsY0FBY0M7WUFDZEMsUUFBUSxDQUFDO1FBQ2I7UUFDQSxLQUFLLENBQUNKO1FBQ05LLFVBQVVDLElBQUksQ0FBQyxJQUFJLEVBQUVQLFFBQVFRLE1BQU07SUFDdkM7SUFFQSxJQUFJQyxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUNSLE1BQU0sQ0FBQ0UsWUFBWTtJQUNuQztJQUVBLElBQUlPLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ1QsTUFBTSxDQUFDRCxPQUFPLENBQUNVLElBQUk7SUFDbkM7SUFFQSxJQUFJQSxLQUFLQyxLQUFLLEVBQUU7UUFDWixNQUFNQyxLQUFLLElBQUksQ0FBQ1gsTUFBTTtRQUN0QixJQUFJVSxVQUFVQyxHQUFHWixPQUFPLENBQUNVLElBQUksRUFBRTtZQUMzQkUsR0FBR1osT0FBTyxDQUFDVSxJQUFJLEdBQUdDO1lBQ2xCQyxHQUFHVixPQUFPLEdBQUc7UUFDakI7SUFDSjtJQUVBLElBQUlXLFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQ1osTUFBTSxDQUFDRCxPQUFPLENBQUNhLE1BQU07SUFDckM7SUFFQSxJQUFJQSxPQUFPRixLQUFLLEVBQUU7UUFDZCxNQUFNQyxLQUFLLElBQUksQ0FBQ1gsTUFBTTtRQUN0QixJQUFJVSxVQUFVQyxHQUFHWixPQUFPLENBQUNhLE1BQU0sRUFBRTtZQUM3QkQsR0FBR1osT0FBTyxDQUFDYSxNQUFNLEdBQUdGO1lBQ3BCQyxHQUFHVixPQUFPLEdBQUc7UUFDakI7SUFDSjtJQUVBLElBQUlZLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ2IsTUFBTSxDQUFDRCxPQUFPLENBQUNjLE9BQU87SUFDdEM7SUFFQSxJQUFJQSxRQUFRSCxLQUFLLEVBQUU7UUFDZixNQUFNQyxLQUFLLElBQUksQ0FBQ1gsTUFBTTtRQUN0QixJQUFJVSxVQUFVQyxHQUFHWixPQUFPLENBQUNjLE9BQU8sRUFBRTtZQUM5QkYsR0FBR1osT0FBTyxDQUFDYyxPQUFPLEdBQUdIO1lBQ3JCQyxHQUFHVixPQUFPLEdBQUc7UUFDakI7SUFDSjtJQUVBLElBQUlNLFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQ1AsTUFBTSxDQUFDSSxNQUFNLENBQUNHLE1BQU07SUFDcEM7SUFFQSxJQUFJQSxPQUFPQSxNQUFNLEVBQUU7UUFDZkYsVUFBVUMsSUFBSSxDQUFDLElBQUksRUFBRUM7SUFDekI7QUFFSjtBQUVBOztDQUVDLEdBRUQsU0FBU0YsVUFBVVMsQ0FBQztJQUNoQixNQUFNVixTQUFTLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxNQUFNO0lBQ2pDLElBQUlXLE1BQU1DLE9BQU8sQ0FBQ0YsSUFBSTtRQUNsQixJQUFJQSxFQUFFRyxNQUFNLEVBQUU7WUFDVmIsT0FBT0csTUFBTSxHQUFHTztRQUNwQixPQUFPO1lBQ0gsT0FBT1YsT0FBT0csTUFBTTtRQUN4QjtJQUNKLE9BQU87UUFDSCxJQUFJWCxNQUFNc0IsTUFBTSxDQUFDSixJQUFJO1lBQ2pCLE9BQU9WLE9BQU9HLE1BQU07UUFDeEIsT0FBTztZQUNISCxPQUFPRyxNQUFNLEdBQUc7Z0JBQUNPO2FBQUU7UUFDdkI7SUFDSjtBQUNKO0FBRUFuQixjQUFjRSxrQkFBa0I7SUFDNUIsT0FBTyxJQUFJLENBQUNzQixRQUFRO0FBQ3hCO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUFDeEI7QUFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLWNvbnZlcnRlci8uL25vZGVfbW9kdWxlcy9wZy1wcm9taXNlL2xpYi90eXBlcy9zZXJ2ZXItZm9ybWF0dGluZy5qcz9mNTRhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtJbm5lclN0YXRlfSA9IHJlcXVpcmUoJy4uL2lubmVyLXN0YXRlJyk7XHJcbmNvbnN0IHthZGRJbnNwZWN0aW9ufSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3MgU2VydmVyRm9ybWF0dGluZ1xyXG4gKi9cclxuY2xhc3MgU2VydmVyRm9ybWF0dGluZyBleHRlbmRzIElubmVyU3RhdGUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBfaW5uZXIgPSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIGNoYW5nZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGN1cnJlbnRFcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdXBlcihfaW5uZXIpO1xyXG4gICAgICAgIHNldFZhbHVlcy5jYWxsKHRoaXMsIG9wdGlvbnMudmFsdWVzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZXJyb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLmN1cnJlbnRFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIub3B0aW9ucy50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgX2kgPSB0aGlzLl9pbm5lcjtcclxuICAgICAgICBpZiAodmFsdWUgIT09IF9pLm9wdGlvbnMudGV4dCkge1xyXG4gICAgICAgICAgICBfaS5vcHRpb25zLnRleHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX2kuY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBiaW5hcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLm9wdGlvbnMuYmluYXJ5O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBiaW5hcnkodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gX2kub3B0aW9ucy5iaW5hcnkpIHtcclxuICAgICAgICAgICAgX2kub3B0aW9ucy5iaW5hcnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX2kuY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCByb3dNb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lci5vcHRpb25zLnJvd01vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHJvd01vZGUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX2lubmVyO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gX2kub3B0aW9ucy5yb3dNb2RlKSB7XHJcbiAgICAgICAgICAgIF9pLm9wdGlvbnMucm93TW9kZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfaS5jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHZhbHVlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIudGFyZ2V0LnZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgdmFsdWVzKHZhbHVlcykge1xyXG4gICAgICAgIHNldFZhbHVlcy5jYWxsKHRoaXMsIHZhbHVlcyk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBTZXJ2ZXJGb3JtYXR0aW5nI3BhcnNlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVzKHYpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2lubmVyLnRhcmdldDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC52YWx1ZXMgPSB2O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHV0aWxzLmlzTnVsbCh2KSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQudmFsdWVzID0gW3ZdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuYWRkSW5zcGVjdGlvbihTZXJ2ZXJGb3JtYXR0aW5nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1NlcnZlckZvcm1hdHRpbmd9O1xyXG4iXSwibmFtZXMiOlsiSW5uZXJTdGF0ZSIsInJlcXVpcmUiLCJhZGRJbnNwZWN0aW9uIiwidXRpbHMiLCJTZXJ2ZXJGb3JtYXR0aW5nIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2lubmVyIiwiY2hhbmdlZCIsImN1cnJlbnRFcnJvciIsInVuZGVmaW5lZCIsInRhcmdldCIsInNldFZhbHVlcyIsImNhbGwiLCJ2YWx1ZXMiLCJlcnJvciIsInRleHQiLCJ2YWx1ZSIsIl9pIiwiYmluYXJ5Iiwicm93TW9kZSIsInYiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpc051bGwiLCJ0b1N0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/types/server-formatting.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/utils/color.js":
/*!****************************************************!*\
  !*** ./node_modules/pg-promise/lib/utils/color.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nclass ColorConsole {\n    static log() {\n        ColorConsole.writeNormal([\n            ...arguments\n        ], 39); // white\n    }\n    static info() {\n        ColorConsole.writeNormal([\n            ...arguments\n        ], 36); // cyan\n    }\n    static success() {\n        ColorConsole.writeNormal([\n            ...arguments\n        ], 32); // green\n    }\n    static warn() {\n        ColorConsole.writeNormal([\n            ...arguments\n        ], 33); // yellow\n    }\n    static error() {\n        ColorConsole.writeError([\n            ...arguments\n        ], 31); // red\n    }\n    static writeNormal(params, color) {\n        // istanbul ignore else\n        if (process.stdout.isTTY) {\n            console.log.apply(null, ColorConsole.formatColor(params, color)); // eslint-disable-line no-console\n        } else {\n            console.log.apply(null, params); // eslint-disable-line no-console\n        }\n    }\n    static writeError(params, color) {\n        // istanbul ignore else\n        if (process.stderr.isTTY) {\n            console.error.apply(null, ColorConsole.formatColor(params, color)); // eslint-disable-line no-console\n        } else {\n            console.error.apply(null, params); // eslint-disable-line no-console\n        }\n    }\n    static formatColor(args, color) {\n        return args.map((a)=>`\\x1b[${color}m${util.format(a)}\\x1b[0m`);\n    }\n}\nColorConsole.log.bright = function() {\n    ColorConsole.writeNormal([\n        ...arguments\n    ], 97); // light white\n};\nColorConsole.info.bright = function() {\n    ColorConsole.writeNormal([\n        ...arguments\n    ], 93); // light cyan\n};\nColorConsole.success.bright = function() {\n    ColorConsole.writeNormal([\n        ...arguments\n    ], 92); // light green\n};\nColorConsole.warn.bright = function() {\n    ColorConsole.writeNormal([\n        ...arguments\n    ], 93); // light yellow\n};\nColorConsole.error.bright = function() {\n    ColorConsole.writeError([\n        ...arguments\n    ], 91); // light red\n};\nmodule.exports = {\n    ColorConsole\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdXRpbHMvY29sb3IuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1DO0lBRUYsT0FBT0MsTUFBTTtRQUNURCxhQUFhRSxXQUFXLENBQUM7ZUFBSUM7U0FBVSxFQUFFLEtBQUssUUFBUTtJQUMxRDtJQUVBLE9BQU9DLE9BQU87UUFDVkosYUFBYUUsV0FBVyxDQUFDO2VBQUlDO1NBQVUsRUFBRSxLQUFLLE9BQU87SUFDekQ7SUFFQSxPQUFPRSxVQUFVO1FBQ2JMLGFBQWFFLFdBQVcsQ0FBQztlQUFJQztTQUFVLEVBQUUsS0FBSyxRQUFRO0lBQzFEO0lBRUEsT0FBT0csT0FBTztRQUNWTixhQUFhRSxXQUFXLENBQUM7ZUFBSUM7U0FBVSxFQUFFLEtBQUssU0FBUztJQUMzRDtJQUVBLE9BQU9JLFFBQVE7UUFDWFAsYUFBYVEsVUFBVSxDQUFDO2VBQUlMO1NBQVUsRUFBRSxLQUFLLE1BQU07SUFDdkQ7SUFFQSxPQUFPRCxZQUFZTyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUM5Qix1QkFBdUI7UUFDdkIsSUFBSUMsUUFBUUMsTUFBTSxDQUFDQyxLQUFLLEVBQUU7WUFDdEJDLFFBQVFiLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDLE1BQU1mLGFBQWFnQixXQUFXLENBQUNQLFFBQVFDLFNBQVMsaUNBQWlDO1FBQ3ZHLE9BQU87WUFDSEksUUFBUWIsR0FBRyxDQUFDYyxLQUFLLENBQUMsTUFBTU4sU0FBUyxpQ0FBaUM7UUFDdEU7SUFDSjtJQUVBLE9BQU9ELFdBQVdDLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQzdCLHVCQUF1QjtRQUN2QixJQUFJQyxRQUFRTSxNQUFNLENBQUNKLEtBQUssRUFBRTtZQUN0QkMsUUFBUVAsS0FBSyxDQUFDUSxLQUFLLENBQUMsTUFBTWYsYUFBYWdCLFdBQVcsQ0FBQ1AsUUFBUUMsU0FBUyxpQ0FBaUM7UUFDekcsT0FBTztZQUNISSxRQUFRUCxLQUFLLENBQUNRLEtBQUssQ0FBQyxNQUFNTixTQUFTLGlDQUFpQztRQUN4RTtJQUNKO0lBRUEsT0FBT08sWUFBWUUsSUFBSSxFQUFFUixLQUFLLEVBQUU7UUFDNUIsT0FBT1EsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLENBQUMsS0FBSyxFQUFFVixNQUFNLENBQUMsRUFBRVosS0FBS3VCLE1BQU0sQ0FBQ0QsR0FBRyxPQUFPLENBQUM7SUFDakU7QUFDSjtBQUVBcEIsYUFBYUMsR0FBRyxDQUFDcUIsTUFBTSxHQUFHO0lBQ3RCdEIsYUFBYUUsV0FBVyxDQUFDO1dBQUlDO0tBQVUsRUFBRSxLQUFLLGNBQWM7QUFDaEU7QUFFQUgsYUFBYUksSUFBSSxDQUFDa0IsTUFBTSxHQUFHO0lBQ3ZCdEIsYUFBYUUsV0FBVyxDQUFDO1dBQUlDO0tBQVUsRUFBRSxLQUFLLGFBQWE7QUFDL0Q7QUFFQUgsYUFBYUssT0FBTyxDQUFDaUIsTUFBTSxHQUFHO0lBQzFCdEIsYUFBYUUsV0FBVyxDQUFDO1dBQUlDO0tBQVUsRUFBRSxLQUFLLGNBQWM7QUFDaEU7QUFFQUgsYUFBYU0sSUFBSSxDQUFDZ0IsTUFBTSxHQUFHO0lBQ3ZCdEIsYUFBYUUsV0FBVyxDQUFDO1dBQUlDO0tBQVUsRUFBRSxLQUFLLGVBQWU7QUFDakU7QUFFQUgsYUFBYU8sS0FBSyxDQUFDZSxNQUFNLEdBQUc7SUFDeEJ0QixhQUFhUSxVQUFVLENBQUM7V0FBSUw7S0FBVSxFQUFFLEtBQUssWUFBWTtBQUM3RDtBQUVBb0IsT0FBT0MsT0FBTyxHQUFHO0lBQUN4QjtBQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdXRpbHMvY29sb3IuanM/OTc5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxuY2xhc3MgQ29sb3JDb25zb2xlIHtcclxuXHJcbiAgICBzdGF0aWMgbG9nKCkge1xyXG4gICAgICAgIENvbG9yQ29uc29sZS53cml0ZU5vcm1hbChbLi4uYXJndW1lbnRzXSwgMzkpOyAvLyB3aGl0ZVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpbmZvKCkge1xyXG4gICAgICAgIENvbG9yQ29uc29sZS53cml0ZU5vcm1hbChbLi4uYXJndW1lbnRzXSwgMzYpOyAvLyBjeWFuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgQ29sb3JDb25zb2xlLndyaXRlTm9ybWFsKFsuLi5hcmd1bWVudHNdLCAzMik7IC8vIGdyZWVuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHdhcm4oKSB7XHJcbiAgICAgICAgQ29sb3JDb25zb2xlLndyaXRlTm9ybWFsKFsuLi5hcmd1bWVudHNdLCAzMyk7IC8vIHllbGxvd1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlcnJvcigpIHtcclxuICAgICAgICBDb2xvckNvbnNvbGUud3JpdGVFcnJvcihbLi4uYXJndW1lbnRzXSwgMzEpOyAvLyByZWRcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgd3JpdGVOb3JtYWwocGFyYW1zLCBjb2xvcikge1xyXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXHJcbiAgICAgICAgaWYgKHByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIENvbG9yQ29uc29sZS5mb3JtYXRDb2xvcihwYXJhbXMsIGNvbG9yKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIHBhcmFtcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgd3JpdGVFcnJvcihwYXJhbXMsIGNvbG9yKSB7XHJcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcclxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShudWxsLCBDb2xvckNvbnNvbGUuZm9ybWF0Q29sb3IocGFyYW1zLCBjb2xvcikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KG51bGwsIHBhcmFtcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZm9ybWF0Q29sb3IoYXJncywgY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gYXJncy5tYXAoYSA9PiBgXFx4MWJbJHtjb2xvcn1tJHt1dGlsLmZvcm1hdChhKX1cXHgxYlswbWApO1xyXG4gICAgfVxyXG59XHJcblxyXG5Db2xvckNvbnNvbGUubG9nLmJyaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIENvbG9yQ29uc29sZS53cml0ZU5vcm1hbChbLi4uYXJndW1lbnRzXSwgOTcpOyAvLyBsaWdodCB3aGl0ZVxyXG59O1xyXG5cclxuQ29sb3JDb25zb2xlLmluZm8uYnJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQ29sb3JDb25zb2xlLndyaXRlTm9ybWFsKFsuLi5hcmd1bWVudHNdLCA5Myk7IC8vIGxpZ2h0IGN5YW5cclxufTtcclxuXHJcbkNvbG9yQ29uc29sZS5zdWNjZXNzLmJyaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIENvbG9yQ29uc29sZS53cml0ZU5vcm1hbChbLi4uYXJndW1lbnRzXSwgOTIpOyAvLyBsaWdodCBncmVlblxyXG59O1xyXG5cclxuQ29sb3JDb25zb2xlLndhcm4uYnJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQ29sb3JDb25zb2xlLndyaXRlTm9ybWFsKFsuLi5hcmd1bWVudHNdLCA5Myk7IC8vIGxpZ2h0IHllbGxvd1xyXG59O1xyXG5cclxuQ29sb3JDb25zb2xlLmVycm9yLmJyaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIENvbG9yQ29uc29sZS53cml0ZUVycm9yKFsuLi5hcmd1bWVudHNdLCA5MSk7IC8vIGxpZ2h0IHJlZFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7Q29sb3JDb25zb2xlfTtcclxuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiQ29sb3JDb25zb2xlIiwibG9nIiwid3JpdGVOb3JtYWwiLCJhcmd1bWVudHMiLCJpbmZvIiwic3VjY2VzcyIsIndhcm4iLCJlcnJvciIsIndyaXRlRXJyb3IiLCJwYXJhbXMiLCJjb2xvciIsInByb2Nlc3MiLCJzdGRvdXQiLCJpc1RUWSIsImNvbnNvbGUiLCJhcHBseSIsImZvcm1hdENvbG9yIiwic3RkZXJyIiwiYXJncyIsIm1hcCIsImEiLCJmb3JtYXQiLCJicmlnaHQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/utils/color.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/utils/index.js":
/*!****************************************************!*\
  !*** ./node_modules/pg-promise/lib/utils/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst npm = {\n    path: __webpack_require__(/*! path */ \"path\"),\n    util: __webpack_require__(/*! util */ \"util\"),\n    patterns: __webpack_require__(/*! ../patterns */ \"(rsc)/./node_modules/pg-promise/lib/patterns.js\")\n};\n////////////////////////////////////////////\n// Simpler check for null/undefined;\nfunction isNull(value) {\n    return value === null || value === undefined;\n}\n////////////////////////////////////////////////////////\n// Verifies parameter for being a non-empty text string;\nfunction isText(txt) {\n    return txt && typeof txt === \"string\" && /\\S/.test(txt);\n}\n///////////////////////////////////////////////////////////\n// Approximates the environment as being for development.\n//\n// Proper configuration is having NODE_ENV = 'development', but this\n// method only checks for 'dev' being present, and regardless of the case.\nfunction isDev() {\n    const env = global.process.env.NODE_ENV || \"\";\n    return env.toLowerCase().indexOf(\"dev\") !== -1;\n}\n/////////////////////////////////////////////\n// Adds properties from source to the target,\n// making them read-only and enumerable.\nfunction addReadProperties(target, source) {\n    for(const p in source){\n        addReadProp(target, p, source[p]);\n    }\n}\n///////////////////////////////////////////////////////\n// Adds a read-only, non-deletable enumerable property.\nfunction addReadProp(obj, name, value, hidden) {\n    Object.defineProperty(obj, name, {\n        value,\n        configurable: false,\n        enumerable: !hidden,\n        writable: false\n    });\n}\n//////////////////////////////////////////////////////////////\n// Converts a connection string or object into its safe copy:\n// if password is present, it is masked with symbol '#'.\nfunction getSafeConnection(cn) {\n    const maskPassword = (cs)=>cs.replace(/:(?![/])([^@]+)/, (_, m)=>\":\" + new Array(m.length + 1).join(\"#\"));\n    if (typeof cn === \"object\") {\n        const copy = Object.assign({}, cn);\n        if (typeof copy.password === \"string\") {\n            copy.password = copy.password.replace(/./g, \"#\");\n        }\n        if (typeof copy.connectionString === \"string\") {\n            copy.connectionString = maskPassword(copy.connectionString);\n        }\n        return copy;\n    }\n    return maskPassword(cn);\n}\n///////////////////////////////////////////\n// Returns a space gap for console output;\nfunction messageGap(level) {\n    return \" \".repeat(level * 4);\n}\n/////////////////////////////////////////\n// Provides platform-neutral inheritance;\nfunction inherits(child, parent) {\n    child.prototype.__proto__ = parent.prototype;\n}\n// istanbul ignore next\nfunction getLocalStack(startIdx, maxLines) {\n    // from the call stack, we take up to maximum lines,\n    // starting with specified line index:\n    startIdx = startIdx || 0;\n    const endIdx = maxLines > 0 ? startIdx + maxLines : undefined;\n    return new Error().stack.split(\"\\n\").filter((line)=>line.match(/\\(.+\\)/)).slice(startIdx, endIdx).join(\"\\n\");\n}\n//////////////////////////////\n// Internal error container;\nfunction InternalError(error) {\n    this.error = error;\n}\n/////////////////////////////////////////////////////////////////\n// Parses a property name, and gets its name from the object,\n// if the property exists. Returns object {valid, has, target, value}:\n//  - valid - true/false, whether the syntax is valid\n//  - has - a flag that property exists; set when 'valid' = true\n//  - target - the target object that contains the property; set when 'has' = true\n//  - value - the value; set when 'has' = true\nfunction getIfHas(obj, prop) {\n    const result = {\n        valid: true\n    };\n    if (prop.indexOf(\".\") === -1) {\n        result.has = prop in obj;\n        result.target = obj;\n        if (result.has) {\n            result.value = obj[prop];\n        }\n    } else {\n        const names = prop.split(\".\");\n        let missing, target;\n        for(let i = 0; i < names.length; i++){\n            const n = names[i];\n            if (!n) {\n                result.valid = false;\n                return result;\n            }\n            if (!missing && hasProperty(obj, n)) {\n                target = obj;\n                obj = obj[n];\n            } else {\n                missing = true;\n            }\n        }\n        result.has = !missing;\n        if (result.has) {\n            result.target = target;\n            result.value = obj;\n        }\n    }\n    return result;\n}\n/////////////////////////////////////////////////////////////////////////\n// Checks if the property exists in the object or value or its prototype;\nfunction hasProperty(value, prop) {\n    return value && typeof value === \"object\" && prop in value || value !== null && value !== undefined && value[prop] !== undefined;\n}\n////////////////////////////////////////////////////////\n// Adds prototype inspection\nfunction addInspection(type, cb) {\n    type.prototype[npm.util.inspect.custom] = cb;\n}\n/////////////////////////////////////////////////////////////////////////////////////////\n// Identifies a general connectivity error, after which no more queries can be executed.\n// This is for detecting when to skip executing ROLLBACK for a failed transaction.\nfunction isConnectivityError(err) {\n    const code = err && typeof err.code === \"string\" && err.code;\n    const cls = code && code.substr(0, 2); // Error Class\n    // istanbul ignore next (we cannot test-cover all error cases):\n    return code === \"ECONNRESET\" || cls === \"08\" && code !== \"08P01\" || cls === \"57\" && code !== \"57014\";\n// Code 'ECONNRESET' - Connectivity issue handled by the driver.\n// Class 08 - Connection Exception (except for 08P01, for protocol violation).\n// Class 57 - Operator Intervention (except for 57014, for cancelled queries).\n//\n// ERROR CODES: https://www.postgresql.org/docs/9.6/static/errcodes-appendix.html\n}\n///////////////////////////////////////////////////////////////\n// Does JSON.stringify, with support for BigInt (irreversible)\nfunction toJson(data) {\n    if (data !== undefined) {\n        return JSON.stringify(data, (_, v)=>typeof v === \"bigint\" ? `${v}#bigint` : v).replace(/\"(-?\\d+)#bigint\"/g, (_, a)=>a);\n    }\n}\nconst exp = {\n    toJson,\n    getIfHas,\n    addInspection,\n    InternalError,\n    getLocalStack,\n    isText,\n    isNull,\n    isDev,\n    addReadProp,\n    addReadProperties,\n    getSafeConnection,\n    messageGap,\n    inherits,\n    isConnectivityError\n};\nconst mainFile = process.argv[1];\n// istanbul ignore next\nexp.startDir = mainFile ? npm.path.dirname(mainFile) : process.cwd();\nmodule.exports = exp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUVELE1BQU1BLE1BQU07SUFDUkMsTUFBTUMsbUJBQU9BLENBQUM7SUFDZEMsTUFBTUQsbUJBQU9BLENBQUM7SUFDZEUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEI7QUFFQSw0Q0FBNEM7QUFDNUMsb0NBQW9DO0FBQ3BDLFNBQVNHLE9BQU9DLEtBQUs7SUFDakIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVQztBQUN2QztBQUVBLHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsU0FBU0MsT0FBT0MsR0FBRztJQUNmLE9BQU9BLE9BQU8sT0FBT0EsUUFBUSxZQUFZLEtBQUtDLElBQUksQ0FBQ0Q7QUFDdkQ7QUFFQSwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsMEVBQTBFO0FBQzFFLFNBQVNFO0lBQ0wsTUFBTUMsTUFBTUMsT0FBT0MsT0FBTyxDQUFDRixHQUFHLENBQUNHLFFBQVEsSUFBSTtJQUMzQyxPQUFPSCxJQUFJSSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDakQ7QUFFQSw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLHdDQUF3QztBQUN4QyxTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsTUFBTTtJQUNyQyxJQUFLLE1BQU1DLEtBQUtELE9BQVE7UUFDcEJFLFlBQVlILFFBQVFFLEdBQUdELE1BQU0sQ0FBQ0MsRUFBRTtJQUNwQztBQUNKO0FBRUEsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCxTQUFTQyxZQUFZQyxHQUFHLEVBQUVDLElBQUksRUFBRWxCLEtBQUssRUFBRW1CLE1BQU07SUFDekNDLE9BQU9DLGNBQWMsQ0FBQ0osS0FBS0MsTUFBTTtRQUM3QmxCO1FBQ0FzQixjQUFjO1FBQ2RDLFlBQVksQ0FBQ0o7UUFDYkssVUFBVTtJQUNkO0FBQ0o7QUFFQSw4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TUFBTTtJQUNSTjtJQUNBcEI7SUFDQVU7SUFDQVo7SUFDQVg7SUFDQTdDO0lBQ0FIO0lBQ0FNO0lBQ0FXO0lBQ0FKO0lBQ0FhO0lBQ0FjO0lBQ0FHO0lBQ0FpQztBQUNKO0FBRUEsTUFBTVksV0FBVy9FLFFBQVFnRixJQUFJLENBQUMsRUFBRTtBQUVoQyx1QkFBdUI7QUFDdkJGLElBQUlHLFFBQVEsR0FBR0YsV0FBVzdGLElBQUlDLElBQUksQ0FBQytGLE9BQU8sQ0FBQ0gsWUFBWS9FLFFBQVFtRixHQUFHO0FBRWxFQyxPQUFPQyxPQUFPLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC1jb252ZXJ0ZXIvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdXRpbHMvaW5kZXguanM/ZTcyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgVml0YWx5IFRvbWlsb3ZcclxuICpcclxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cclxuICogZm9yIGxpY2Vuc2luZyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogUmVtb3ZhbCBvciBtb2RpZmljYXRpb24gb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIHByb2hpYml0ZWQuXHJcbiAqL1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgcGF0aDogcmVxdWlyZSgncGF0aCcpLFxyXG4gICAgdXRpbDogcmVxdWlyZSgndXRpbCcpLFxyXG4gICAgcGF0dGVybnM6IHJlcXVpcmUoJy4uL3BhdHRlcm5zJylcclxufTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFNpbXBsZXIgY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBWZXJpZmllcyBwYXJhbWV0ZXIgZm9yIGJlaW5nIGEgbm9uLWVtcHR5IHRleHQgc3RyaW5nO1xyXG5mdW5jdGlvbiBpc1RleHQodHh0KSB7XHJcbiAgICByZXR1cm4gdHh0ICYmIHR5cGVvZiB0eHQgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodHh0KTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQXBwcm94aW1hdGVzIHRoZSBlbnZpcm9ubWVudCBhcyBiZWluZyBmb3IgZGV2ZWxvcG1lbnQuXHJcbi8vXHJcbi8vIFByb3BlciBjb25maWd1cmF0aW9uIGlzIGhhdmluZyBOT0RFX0VOViA9ICdkZXZlbG9wbWVudCcsIGJ1dCB0aGlzXHJcbi8vIG1ldGhvZCBvbmx5IGNoZWNrcyBmb3IgJ2RldicgYmVpbmcgcHJlc2VudCwgYW5kIHJlZ2FyZGxlc3Mgb2YgdGhlIGNhc2UuXHJcbmZ1bmN0aW9uIGlzRGV2KCkge1xyXG4gICAgY29uc3QgZW52ID0gZ2xvYmFsLnByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICcnO1xyXG4gICAgcmV0dXJuIGVudi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RldicpICE9PSAtMTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEFkZHMgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0aGUgdGFyZ2V0LFxyXG4vLyBtYWtpbmcgdGhlbSByZWFkLW9ubHkgYW5kIGVudW1lcmFibGUuXHJcbmZ1bmN0aW9uIGFkZFJlYWRQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBmb3IgKGNvbnN0IHAgaW4gc291cmNlKSB7XHJcbiAgICAgICAgYWRkUmVhZFByb3AodGFyZ2V0LCBwLCBzb3VyY2VbcF0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEFkZHMgYSByZWFkLW9ubHksIG5vbi1kZWxldGFibGUgZW51bWVyYWJsZSBwcm9wZXJ0eS5cclxuZnVuY3Rpb24gYWRkUmVhZFByb3Aob2JqLCBuYW1lLCB2YWx1ZSwgaGlkZGVuKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiAhaGlkZGVuLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIENvbnZlcnRzIGEgY29ubmVjdGlvbiBzdHJpbmcgb3Igb2JqZWN0IGludG8gaXRzIHNhZmUgY29weTpcclxuLy8gaWYgcGFzc3dvcmQgaXMgcHJlc2VudCwgaXQgaXMgbWFza2VkIHdpdGggc3ltYm9sICcjJy5cclxuZnVuY3Rpb24gZ2V0U2FmZUNvbm5lY3Rpb24oY24pIHtcclxuICAgIGNvbnN0IG1hc2tQYXNzd29yZCA9IGNzID0+IGNzLnJlcGxhY2UoLzooPyFbL10pKFteQF0rKS8sIChfLCBtKSA9PiAnOicgKyBuZXcgQXJyYXkobS5sZW5ndGggKyAxKS5qb2luKCcjJykpO1xyXG4gICAgaWYgKHR5cGVvZiBjbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgY24pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29weS5wYXNzd29yZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29weS5wYXNzd29yZCA9IGNvcHkucGFzc3dvcmQucmVwbGFjZSgvLi9nLCAnIycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvcHkuY29ubmVjdGlvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29weS5jb25uZWN0aW9uU3RyaW5nID0gbWFza1Bhc3N3b3JkKGNvcHkuY29ubmVjdGlvblN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hc2tQYXNzd29yZChjbik7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUmV0dXJucyBhIHNwYWNlIGdhcCBmb3IgY29uc29sZSBvdXRwdXQ7XHJcbmZ1bmN0aW9uIG1lc3NhZ2VHYXAobGV2ZWwpIHtcclxuICAgIHJldHVybiAnICcucmVwZWF0KGxldmVsICogNCk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFByb3ZpZGVzIHBsYXRmb3JtLW5ldXRyYWwgaW5oZXJpdGFuY2U7XHJcbmZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkLCBwYXJlbnQpIHtcclxuICAgIGNoaWxkLnByb3RvdHlwZS5fX3Byb3RvX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG59XHJcblxyXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG5mdW5jdGlvbiBnZXRMb2NhbFN0YWNrKHN0YXJ0SWR4LCBtYXhMaW5lcykge1xyXG4gICAgLy8gZnJvbSB0aGUgY2FsbCBzdGFjaywgd2UgdGFrZSB1cCB0byBtYXhpbXVtIGxpbmVzLFxyXG4gICAgLy8gc3RhcnRpbmcgd2l0aCBzcGVjaWZpZWQgbGluZSBpbmRleDpcclxuICAgIHN0YXJ0SWR4ID0gc3RhcnRJZHggfHwgMDtcclxuICAgIGNvbnN0IGVuZElkeCA9IG1heExpbmVzID4gMCA/IHN0YXJ0SWR4ICsgbWF4TGluZXMgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCkuc3RhY2tcclxuICAgICAgICAuc3BsaXQoJ1xcbicpXHJcbiAgICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUubWF0Y2goL1xcKC4rXFwpLykpXHJcbiAgICAgICAgLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSW50ZXJuYWwgZXJyb3IgY29udGFpbmVyO1xyXG5mdW5jdGlvbiBJbnRlcm5hbEVycm9yKGVycm9yKSB7XHJcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFBhcnNlcyBhIHByb3BlcnR5IG5hbWUsIGFuZCBnZXRzIGl0cyBuYW1lIGZyb20gdGhlIG9iamVjdCxcclxuLy8gaWYgdGhlIHByb3BlcnR5IGV4aXN0cy4gUmV0dXJucyBvYmplY3Qge3ZhbGlkLCBoYXMsIHRhcmdldCwgdmFsdWV9OlxyXG4vLyAgLSB2YWxpZCAtIHRydWUvZmFsc2UsIHdoZXRoZXIgdGhlIHN5bnRheCBpcyB2YWxpZFxyXG4vLyAgLSBoYXMgLSBhIGZsYWcgdGhhdCBwcm9wZXJ0eSBleGlzdHM7IHNldCB3aGVuICd2YWxpZCcgPSB0cnVlXHJcbi8vICAtIHRhcmdldCAtIHRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHByb3BlcnR5OyBzZXQgd2hlbiAnaGFzJyA9IHRydWVcclxuLy8gIC0gdmFsdWUgLSB0aGUgdmFsdWU7IHNldCB3aGVuICdoYXMnID0gdHJ1ZVxyXG5mdW5jdGlvbiBnZXRJZkhhcyhvYmosIHByb3ApIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHt2YWxpZDogdHJ1ZX07XHJcbiAgICBpZiAocHJvcC5pbmRleE9mKCcuJykgPT09IC0xKSB7XHJcbiAgICAgICAgcmVzdWx0LmhhcyA9IHByb3AgaW4gb2JqO1xyXG4gICAgICAgIHJlc3VsdC50YXJnZXQgPSBvYmo7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5oYXMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gb2JqW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmFtZXMgPSBwcm9wLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgbGV0IG1pc3NpbmcsIHRhcmdldDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFuKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtaXNzaW5nICYmIGhhc1Byb3BlcnR5KG9iaiwgbikpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IG9iajtcclxuICAgICAgICAgICAgICAgIG9iaiA9IG9ialtuXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1pc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5oYXMgPSAhbWlzc2luZztcclxuICAgICAgICBpZiAocmVzdWx0Lmhhcykge1xyXG4gICAgICAgICAgICByZXN1bHQudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBDaGVja3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiB0aGUgb2JqZWN0IG9yIHZhbHVlIG9yIGl0cyBwcm90b3R5cGU7XHJcbmZ1bmN0aW9uIGhhc1Byb3BlcnR5KHZhbHVlLCBwcm9wKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgcHJvcCBpbiB2YWx1ZSkgfHxcclxuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlW3Byb3BdICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEFkZHMgcHJvdG90eXBlIGluc3BlY3Rpb25cclxuZnVuY3Rpb24gYWRkSW5zcGVjdGlvbih0eXBlLCBjYikge1xyXG4gICAgdHlwZS5wcm90b3R5cGVbbnBtLnV0aWwuaW5zcGVjdC5jdXN0b21dID0gY2I7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIElkZW50aWZpZXMgYSBnZW5lcmFsIGNvbm5lY3Rpdml0eSBlcnJvciwgYWZ0ZXIgd2hpY2ggbm8gbW9yZSBxdWVyaWVzIGNhbiBiZSBleGVjdXRlZC5cclxuLy8gVGhpcyBpcyBmb3IgZGV0ZWN0aW5nIHdoZW4gdG8gc2tpcCBleGVjdXRpbmcgUk9MTEJBQ0sgZm9yIGEgZmFpbGVkIHRyYW5zYWN0aW9uLlxyXG5mdW5jdGlvbiBpc0Nvbm5lY3Rpdml0eUVycm9yKGVycikge1xyXG4gICAgY29uc3QgY29kZSA9IGVyciAmJiB0eXBlb2YgZXJyLmNvZGUgPT09ICdzdHJpbmcnICYmIGVyci5jb2RlO1xyXG4gICAgY29uc3QgY2xzID0gY29kZSAmJiBjb2RlLnN1YnN0cigwLCAyKTsgLy8gRXJyb3IgQ2xhc3NcclxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICh3ZSBjYW5ub3QgdGVzdC1jb3ZlciBhbGwgZXJyb3IgY2FzZXMpOlxyXG4gICAgcmV0dXJuIGNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fCAoY2xzID09PSAnMDgnICYmIGNvZGUgIT09ICcwOFAwMScpIHx8IChjbHMgPT09ICc1NycgJiYgY29kZSAhPT0gJzU3MDE0Jyk7XHJcbiAgICAvLyBDb2RlICdFQ09OTlJFU0VUJyAtIENvbm5lY3Rpdml0eSBpc3N1ZSBoYW5kbGVkIGJ5IHRoZSBkcml2ZXIuXHJcbiAgICAvLyBDbGFzcyAwOCAtIENvbm5lY3Rpb24gRXhjZXB0aW9uIChleGNlcHQgZm9yIDA4UDAxLCBmb3IgcHJvdG9jb2wgdmlvbGF0aW9uKS5cclxuICAgIC8vIENsYXNzIDU3IC0gT3BlcmF0b3IgSW50ZXJ2ZW50aW9uIChleGNlcHQgZm9yIDU3MDE0LCBmb3IgY2FuY2VsbGVkIHF1ZXJpZXMpLlxyXG4gICAgLy9cclxuICAgIC8vIEVSUk9SIENPREVTOiBodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzLzkuNi9zdGF0aWMvZXJyY29kZXMtYXBwZW5kaXguaHRtbFxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gRG9lcyBKU09OLnN0cmluZ2lmeSwgd2l0aCBzdXBwb3J0IGZvciBCaWdJbnQgKGlycmV2ZXJzaWJsZSlcclxuZnVuY3Rpb24gdG9Kc29uKGRhdGEpIHtcclxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgKF8sIHYpID0+IHR5cGVvZiB2ID09PSAnYmlnaW50JyA/IGAke3Z9I2JpZ2ludGAgOiB2KVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIoLT9cXGQrKSNiaWdpbnRcIi9nLCAoXywgYSkgPT4gYSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGV4cCA9IHtcclxuICAgIHRvSnNvbixcclxuICAgIGdldElmSGFzLFxyXG4gICAgYWRkSW5zcGVjdGlvbixcclxuICAgIEludGVybmFsRXJyb3IsXHJcbiAgICBnZXRMb2NhbFN0YWNrLFxyXG4gICAgaXNUZXh0LFxyXG4gICAgaXNOdWxsLFxyXG4gICAgaXNEZXYsXHJcbiAgICBhZGRSZWFkUHJvcCxcclxuICAgIGFkZFJlYWRQcm9wZXJ0aWVzLFxyXG4gICAgZ2V0U2FmZUNvbm5lY3Rpb24sXHJcbiAgICBtZXNzYWdlR2FwLFxyXG4gICAgaW5oZXJpdHMsXHJcbiAgICBpc0Nvbm5lY3Rpdml0eUVycm9yXHJcbn07XHJcblxyXG5jb25zdCBtYWluRmlsZSA9IHByb2Nlc3MuYXJndlsxXTtcclxuXHJcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbmV4cC5zdGFydERpciA9IG1haW5GaWxlID8gbnBtLnBhdGguZGlybmFtZShtYWluRmlsZSkgOiBwcm9jZXNzLmN3ZCgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHA7XHJcbiJdLCJuYW1lcyI6WyJucG0iLCJwYXRoIiwicmVxdWlyZSIsInV0aWwiLCJwYXR0ZXJucyIsImlzTnVsbCIsInZhbHVlIiwidW5kZWZpbmVkIiwiaXNUZXh0IiwidHh0IiwidGVzdCIsImlzRGV2IiwiZW52IiwiZ2xvYmFsIiwicHJvY2VzcyIsIk5PREVfRU5WIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiYWRkUmVhZFByb3BlcnRpZXMiLCJ0YXJnZXQiLCJzb3VyY2UiLCJwIiwiYWRkUmVhZFByb3AiLCJvYmoiLCJuYW1lIiwiaGlkZGVuIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJnZXRTYWZlQ29ubmVjdGlvbiIsImNuIiwibWFza1Bhc3N3b3JkIiwiY3MiLCJyZXBsYWNlIiwiXyIsIm0iLCJBcnJheSIsImxlbmd0aCIsImpvaW4iLCJjb3B5IiwiYXNzaWduIiwicGFzc3dvcmQiLCJjb25uZWN0aW9uU3RyaW5nIiwibWVzc2FnZUdhcCIsImxldmVsIiwicmVwZWF0IiwiaW5oZXJpdHMiLCJjaGlsZCIsInBhcmVudCIsInByb3RvdHlwZSIsIl9fcHJvdG9fXyIsImdldExvY2FsU3RhY2siLCJzdGFydElkeCIsIm1heExpbmVzIiwiZW5kSWR4IiwiRXJyb3IiLCJzdGFjayIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsIm1hdGNoIiwic2xpY2UiLCJJbnRlcm5hbEVycm9yIiwiZXJyb3IiLCJnZXRJZkhhcyIsInByb3AiLCJyZXN1bHQiLCJ2YWxpZCIsImhhcyIsIm5hbWVzIiwibWlzc2luZyIsImkiLCJuIiwiaGFzUHJvcGVydHkiLCJhZGRJbnNwZWN0aW9uIiwidHlwZSIsImNiIiwiaW5zcGVjdCIsImN1c3RvbSIsImlzQ29ubmVjdGl2aXR5RXJyb3IiLCJlcnIiLCJjb2RlIiwiY2xzIiwic3Vic3RyIiwidG9Kc29uIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2IiwiYSIsImV4cCIsIm1haW5GaWxlIiwiYXJndiIsInN0YXJ0RGlyIiwiZGlybmFtZSIsImN3ZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/lib/utils/public.js":
/*!*****************************************************!*\
  !*** ./node_modules/pg-promise/lib/utils/public.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Copyright (c) 2015-present, Vitaly Tomilov\r\n *\r\n * See the LICENSE file at the top-level directory of this distribution\r\n * for licensing information.\r\n *\r\n * Removal or modification of this copyright notice is prohibited.\r\n */ \nconst { assert } = __webpack_require__(/*! ../assert */ \"(rsc)/./node_modules/pg-promise/lib/assert.js\");\nconst npm = {\n    fs: __webpack_require__(/*! fs */ \"fs\"),\n    path: __webpack_require__(/*! path */ \"path\"),\n    utils: __webpack_require__(/*! ./ */ \"(rsc)/./node_modules/pg-promise/lib/utils/index.js\"),\n    package: __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/pg-promise/package.json\")\n};\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */ function camelize(text) {\n    text = text.replace(/[-_\\s.]+(.)?/g, (_, c)=>c ? c.toUpperCase() : \"\");\n    return text.substr(0, 1).toLowerCase() + text.substr(1);\n}\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */ function camelizeVar(text) {\n    text = text.replace(/[^a-zA-Z0-9$_\\-\\s.]/g, \"\").replace(/^[0-9_\\-\\s.]+/, \"\");\n    return camelize(text);\n}\nfunction _enumSql(dir, options, cb, namePath) {\n    const tree = {};\n    npm.fs.readdirSync(dir).forEach((file)=>{\n        let stat;\n        const fullPath = npm.path.join(dir, file);\n        try {\n            stat = npm.fs.statSync(fullPath);\n        } catch (e) {\n            // while it is very easy to test manually, it is very difficult to test for\n            // access-denied errors automatically; therefore excluding from the coverage:\n            // istanbul ignore next\n            if (options.ignoreErrors) {\n                return; // on to the next file/folder;\n            }\n            // istanbul ignore next\n            throw e;\n        }\n        if (stat.isDirectory()) {\n            if (options.recursive) {\n                const dirName = camelizeVar(file);\n                const np = namePath ? namePath + \".\" + dirName : dirName;\n                const t = _enumSql(fullPath, options, cb, np);\n                if (Object.keys(t).length) {\n                    if (!dirName.length || dirName in tree) {\n                        if (!options.ignoreErrors) {\n                            throw new Error(\"Empty or duplicate camelized folder name: \" + fullPath);\n                        }\n                    }\n                    tree[dirName] = t;\n                }\n            }\n        } else {\n            if (npm.path.extname(file).toLowerCase() === \".sql\") {\n                const name = camelizeVar(file.replace(/\\.[^/.]+$/, \"\"));\n                if (!name.length || name in tree) {\n                    if (!options.ignoreErrors) {\n                        throw new Error(\"Empty or duplicate camelized file name: \" + fullPath);\n                    }\n                }\n                tree[name] = fullPath;\n                if (cb) {\n                    const result = cb(fullPath, name, namePath ? namePath + \".\" + name : name);\n                    if (result !== undefined) {\n                        tree[name] = result;\n                    }\n                }\n            }\n        }\n    });\n    return tree;\n}\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {{}} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * const sql = pgp.utils.enumSql(__dirname, {recursive: true}, file => {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * const {join: joinPath} = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * const tree = pgp.utils.enumSql('../sql', {recursive: true}, file => {\r\n *     return joinPath(__dirname, file);\r\n * });\r\n *\r\n */ function enumSql(dir, options, cb) {\n    if (!npm.utils.isText(dir)) {\n        throw new TypeError(\"Parameter 'dir' must be a non-empty text string.\");\n    }\n    options = assert(options, [\n        \"recursive\",\n        \"ignoreErrors\"\n    ]);\n    cb = typeof cb === \"function\" ? cb : null;\n    return _enumSql(dir, options, cb, \"\");\n}\n/**\r\n * @method utils.taskArgs\r\n * @description\r\n * Normalizes/prepares arguments for tasks and transactions.\r\n *\r\n * Its main purpose is to simplify adding custom methods {@link Database#task task}, {@link Database#taskIf taskIf},\r\n * {@link Database#tx tx} and {@link Database#txIf txIf} within event {@link event:extend extend}, as the those methods use fairly\r\n * complex logic for parsing inputs.\r\n *\r\n * @param args {Object}\r\n * Array-like object of `arguments` that was passed into the method. It is expected that the `arguments`\r\n * are always made of two parameters - `(options, cb)`, same as all the default task/transaction methods.\r\n *\r\n * And if your custom method needs additional parameters, they should be passed in as extra properties within `options`.\r\n *\r\n * @returns {Array}\r\n * Array of arguments that can be passed into a task or transaction.\r\n *\r\n * It is extended with properties `options` and `cb` to access the corresponding array elements `[0]` and `[1]` by name.\r\n *\r\n * @example\r\n *\r\n * // Registering a custom transaction method that assigns a default Transaction Mode:\r\n *\r\n * const initOptions = {\r\n *     extend: obj => {\r\n *         obj.myTx = function(options, cb) {\r\n *             const args = pgp.utils.taskArgs(arguments); // prepare arguments\r\n *\r\n *             if (!('mode' in args.options)) {\r\n *                 // if no 'mode' was specified, set default for transaction mode:\r\n *                 args.options.mode = myTxModeObject; // of type pgp.txMode.TransactionMode\r\n *             }\r\n *\r\n *             return obj.tx.apply(this, args);\r\n *             // or explicitly, if needed:\r\n *             // return obj.tx.call(this, args.options, args.cb);\r\n *         }\r\n *     }\r\n * };\r\n *\r\n */ function taskArgs(args) {\n    if (!args || typeof args.length !== \"number\") {\n        throw new TypeError(\"Parameter 'args' must be an array-like object of arguments.\");\n    }\n    let options = args[0], cb;\n    if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n        if (cb.name) {\n            options.tag = cb.name;\n        }\n    } else {\n        if (typeof args[1] === \"function\") {\n            cb = args[1];\n        }\n        if (typeof options === \"string\" || typeof options === \"number\") {\n            options = {\n                tag: options\n            };\n        } else {\n            options = typeof options === \"object\" && options || {};\n            if (!(\"tag\" in options) && cb && cb.name) {\n                options.tag = cb.name;\n            }\n        }\n    }\n    const res = [\n        options,\n        cb\n    ];\n    Object.defineProperty(res, \"options\", {\n        get: function() {\n            return this[0];\n        },\n        set: function(newValue) {\n            this[0] = newValue;\n        },\n        enumerable: true\n    });\n    Object.defineProperty(res, \"cb\", {\n        get: function() {\n            return this[1];\n        },\n        set: function(newValue) {\n            this[1] = newValue;\n        },\n        enumerable: true\n    });\n    return res;\n}\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} taskArgs\r\n * {@link utils.taskArgs taskArgs} - prepares arguments for tasks and transactions\r\n */ module.exports = {\n    camelize,\n    camelizeVar,\n    enumSql,\n    taskArgs\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGctcHJvbWlzZS9saWIvdXRpbHMvcHVibGljLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0NBT0M7QUFFRCxNQUFNLEVBQUNBLE1BQU0sRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQztBQUV6QixNQUFNQyxNQUFNO0lBQ1JDLElBQUlGLG1CQUFPQSxDQUFDO0lBQ1pHLE1BQU1ILG1CQUFPQSxDQUFDO0lBQ2RJLE9BQU9KLG1CQUFPQSxDQUFDO0lBQ2ZLLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3JCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0QsU0FBU00sU0FBU0MsSUFBSTtJQUNsQkEsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLGlCQUFpQixDQUFDQyxHQUFHQyxJQUFNQSxJQUFJQSxFQUFFQyxXQUFXLEtBQUs7SUFDckUsT0FBT0osS0FBS0ssTUFBTSxDQUFDLEdBQUcsR0FBR0MsV0FBVyxLQUFLTixLQUFLSyxNQUFNLENBQUM7QUFDekQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QsU0FBU0UsWUFBWVAsSUFBSTtJQUNyQkEsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLHdCQUF3QixJQUFJQSxPQUFPLENBQUMsaUJBQWlCO0lBQ3pFLE9BQU9GLFNBQVNDO0FBQ3BCO0FBRUEsU0FBU1EsU0FBU0MsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLEVBQUUsRUFBRUMsUUFBUTtJQUN4QyxNQUFNQyxPQUFPLENBQUM7SUFDZG5CLElBQUlDLEVBQUUsQ0FBQ21CLFdBQVcsQ0FBQ0wsS0FBS00sT0FBTyxDQUFDQyxDQUFBQTtRQUM1QixJQUFJQztRQUNKLE1BQU1DLFdBQVd4QixJQUFJRSxJQUFJLENBQUN1QixJQUFJLENBQUNWLEtBQUtPO1FBQ3BDLElBQUk7WUFDQUMsT0FBT3ZCLElBQUlDLEVBQUUsQ0FBQ3lCLFFBQVEsQ0FBQ0Y7UUFDM0IsRUFBRSxPQUFPRyxHQUFHO1lBQ1IsMkVBQTJFO1lBQzNFLDZFQUE2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LE9BQU0sS0FBTUMsTUFBTUEsR0FBR3NCLElBQUksRUFBRTtnQkFDdEN2QixRQUFRK0IsR0FBRyxHQUFHOUIsR0FBR3NCLElBQUk7WUFDekI7UUFDSjtJQUNKO0lBRUEsTUFBTVMsTUFBTTtRQUFDaEM7UUFBU0M7S0FBRztJQUV6QmlCLE9BQU9lLGNBQWMsQ0FBQ0QsS0FBSyxXQUFXO1FBQ2xDRSxLQUFLO1lBQ0QsT0FBTyxJQUFJLENBQUMsRUFBRTtRQUNsQjtRQUNBQyxLQUFLLFNBQVVDLFFBQVE7WUFDbkIsSUFBSSxDQUFDLEVBQUUsR0FBR0E7UUFDZDtRQUNBQyxZQUFZO0lBQ2hCO0lBRUFuQixPQUFPZSxjQUFjLENBQUNELEtBQUssTUFBTTtRQUM3QkUsS0FBSztZQUNELE9BQU8sSUFBSSxDQUFDLEVBQUU7UUFDbEI7UUFDQUMsS0FBSyxTQUFVQyxRQUFRO1lBQ25CLElBQUksQ0FBQyxFQUFFLEdBQUdBO1FBQ2Q7UUFDQUMsWUFBWTtJQUNoQjtJQUVBLE9BQU9MO0FBQ1g7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRE0sT0FBT0MsT0FBTyxHQUFHO0lBQ2JsRDtJQUNBUTtJQUNBNkI7SUFDQUc7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwtY29udmVydGVyLy4vbm9kZV9tb2R1bGVzL3BnLXByb21pc2UvbGliL3V0aWxzL3B1YmxpYy5qcz8xMjJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBWaXRhbHkgVG9taWxvdlxyXG4gKlxyXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxyXG4gKiBmb3IgbGljZW5zaW5nIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBSZW1vdmFsIG9yIG1vZGlmaWNhdGlvbiBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgcHJvaGliaXRlZC5cclxuICovXHJcblxyXG5jb25zdCB7YXNzZXJ0fSA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xyXG5cclxuY29uc3QgbnBtID0ge1xyXG4gICAgZnM6IHJlcXVpcmUoJ2ZzJyksXHJcbiAgICBwYXRoOiByZXF1aXJlKCdwYXRoJyksXHJcbiAgICB1dGlsczogcmVxdWlyZSgnLi8nKSxcclxuICAgIHBhY2thZ2U6IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpXHJcbn07XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB1dGlscy5jYW1lbGl6ZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ2FtZWxpemVzIGEgdGV4dCBzdHJpbmcuXHJcbiAqXHJcbiAqIENhc2UtY2hhbmdpbmcgY2hhcmFjdGVycyBpbmNsdWRlOlxyXG4gKiAtIF9oeXBoZW5fXHJcbiAqIC0gX3VuZGVyc2NvcmVfXHJcbiAqIC0gX3BlcmlvZF9cclxuICogLSBfc3BhY2VfXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XHJcbiAqIElucHV0IHRleHQgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBDYW1lbGl6ZWQgdGV4dCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBzZWVcclxuICoge0BsaW5rIHV0aWxzLmNhbWVsaXplVmFyIGNhbWVsaXplVmFyfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY2FtZWxpemUodGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvWy1fXFxzLl0rKC4pPy9nLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKTtcclxuICAgIHJldHVybiB0ZXh0LnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgdGV4dC5zdWJzdHIoMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHV0aWxzLmNhbWVsaXplVmFyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDYW1lbGl6ZXMgYSB0ZXh0IHN0cmluZywgd2hpbGUgbWFraW5nIGl0IGNvbXBsaWFudCB3aXRoIEphdmFTY3JpcHQgdmFyaWFibGUgbmFtZXM6XHJcbiAqIC0gY29udGFpbnMgc3ltYm9scyBgYS16YCwgYEEtWmAsIGAwLTlgLCBgX2AgYW5kIGAkYFxyXG4gKiAtIGNhbm5vdCBoYXZlIGxlYWRpbmcgZGlnaXRzXHJcbiAqXHJcbiAqIEZpcnN0LCBpdCByZW1vdmVzIGFsbCBzeW1ib2xzIHRoYXQgZG8gbm90IG1lZXQgdGhlIGFib3ZlIGNyaXRlcmlhLCBleGNlcHQgZm9yIF9oeXBoZW5fLCBfcGVyaW9kXyBhbmQgX3NwYWNlXyxcclxuICogYW5kIHRoZW4gaXQgZm9yd2FyZHMgaW50byB7QGxpbmsgdXRpbHMuY2FtZWxpemUgY2FtZWxpemV9LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gKiBJbnB1dCB0ZXh0IHN0cmluZy5cclxuICpcclxuICogSWYgaXQgZG9lc24ndCBjb250YWluIGFueSBzeW1ib2xzIHRvIG1ha2UgdXAgYSB2YWxpZCB2YXJpYWJsZSBuYW1lLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBDYW1lbGl6ZWQgdGV4dCBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvcGVuIHByb3BlcnR5IG5hbWUuXHJcbiAqXHJcbiAqIEBzZWVcclxuICoge0BsaW5rIHV0aWxzLmNhbWVsaXplIGNhbWVsaXplfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY2FtZWxpemVWYXIodGV4dCkge1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW15hLXpBLVowLTkkX1xcLVxccy5dL2csICcnKS5yZXBsYWNlKC9eWzAtOV9cXC1cXHMuXSsvLCAnJyk7XHJcbiAgICByZXR1cm4gY2FtZWxpemUodGV4dCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9lbnVtU3FsKGRpciwgb3B0aW9ucywgY2IsIG5hbWVQYXRoKSB7XHJcbiAgICBjb25zdCB0cmVlID0ge307XHJcbiAgICBucG0uZnMucmVhZGRpclN5bmMoZGlyKS5mb3JFYWNoKGZpbGUgPT4ge1xyXG4gICAgICAgIGxldCBzdGF0O1xyXG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gbnBtLnBhdGguam9pbihkaXIsIGZpbGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0YXQgPSBucG0uZnMuc3RhdFN5bmMoZnVsbFBhdGgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gd2hpbGUgaXQgaXMgdmVyeSBlYXN5IHRvIHRlc3QgbWFudWFsbHksIGl0IGlzIHZlcnkgZGlmZmljdWx0IHRvIHRlc3QgZm9yXHJcbiAgICAgICAgICAgIC8vIGFjY2Vzcy1kZW5pZWQgZXJyb3JzIGF1dG9tYXRpY2FsbHk7IHRoZXJlZm9yZSBleGNsdWRpbmcgZnJvbSB0aGUgY292ZXJhZ2U6XHJcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUVycm9ycykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBvbiB0byB0aGUgbmV4dCBmaWxlL2ZvbGRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlyTmFtZSA9IGNhbWVsaXplVmFyKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnAgPSBuYW1lUGF0aCA/IChuYW1lUGF0aCArICcuJyArIGRpck5hbWUpIDogZGlyTmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBfZW51bVNxbChmdWxsUGF0aCwgb3B0aW9ucywgY2IsIG5wKTtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpck5hbWUubGVuZ3RoIHx8IGRpck5hbWUgaW4gdHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG9yIGR1cGxpY2F0ZSBjYW1lbGl6ZWQgZm9sZGVyIG5hbWU6ICcgKyBmdWxsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZVtkaXJOYW1lXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobnBtLnBhdGguZXh0bmFtZShmaWxlKS50b0xvd2VyQ2FzZSgpID09PSAnLnNxbCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjYW1lbGl6ZVZhcihmaWxlLnJlcGxhY2UoL1xcLlteLy5dKyQvLCAnJykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCB8fCBuYW1lIGluIHRyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgb3IgZHVwbGljYXRlIGNhbWVsaXplZCBmaWxlIG5hbWU6ICcgKyBmdWxsUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJlZVtuYW1lXSA9IGZ1bGxQYXRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IoZnVsbFBhdGgsIG5hbWUsIG5hbWVQYXRoID8gKG5hbWVQYXRoICsgJy4nICsgbmFtZSkgOiBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVtuYW1lXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcblxyXG4vKipcclxuICogQG1ldGhvZCB1dGlscy5lbnVtU3FsXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTeW5jaHJvbm91c2x5IGVudW1lcmF0ZXMgYWxsIFNRTCBmaWxlcyAod2l0aGluIGEgZ2l2ZW4gZGlyZWN0b3J5KSBpbnRvIGEgY2FtZWxpemVkIFNRTCB0cmVlLlxyXG4gKlxyXG4gKiBBbGwgcHJvcGVydHkgbmFtZXMgd2l0aGluIHRoZSB0cmVlIGFyZSBjYW1lbGl6ZWQgdmlhIHtAbGluayB1dGlscy5jYW1lbGl6ZVZhciBjYW1lbGl6ZVZhcn0sXHJcbiAqIHNvIHRoZXkgY2FuIGJlIHVzZWQgaW4gdGhlIGNvZGUgZGlyZWN0bHksIGFzIG9wZW4gcHJvcGVydHkgbmFtZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJcclxuICogRGlyZWN0b3J5IHBhdGggd2hlcmUgU1FMIGZpbGVzIGFyZSBsb2NhdGVkLCBlaXRoZXIgYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBTUUwgZmlsZXMgYXJlIGlkZW50aWZpZWQgYnkgdXNpbmcgYC5zcWxgIGV4dGVuc2lvbiAoY2FzZS1pbnNlbnNpdGl2ZSkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7e319IFtvcHRpb25zXVxyXG4gKiBTZWFyY2ggb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdXHJcbiAqIEluY2x1ZGUgc3ViLWRpcmVjdG9yaWVzIGludG8gdGhlIHNlYXJjaC5cclxuICpcclxuICogU3ViLWRpcmVjdG9yaWVzIHdpdGhvdXQgU1FMIGZpbGVzIHdpbGwgYmUgc2tpcHBlZCBmcm9tIHRoZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRXJyb3JzPWZhbHNlXVxyXG4gKiBJZ25vcmUgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBlcnJvcnM6XHJcbiAqIC0gYWNjZXNzIGVycm9ycywgd2hlbiB0aGVyZSBpcyBubyByZWFkIGFjY2VzcyB0byBhIGZpbGUgb3IgZm9sZGVyXHJcbiAqIC0gZW1wdHkgb3IgZHVwbGljYXRlIGNhbWVsaXplZCBwcm9wZXJ0eSBuYW1lc1xyXG4gKlxyXG4gKiBUaGlzIGZsYWcgZG9lcyBub3QgYWZmZWN0IGVycm9ycyByZWxhdGVkIHRvIGludmFsaWQgaW5wdXQgcGFyYW1ldGVycywgb3IgaWYgeW91IHBhc3MgaW4gYVxyXG4gKiBub24tZXhpc3RpbmcgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2JdXHJcbiAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aHJlZSBhcmd1bWVudHM6XHJcbiAqIC0gYGZpbGVgIC0gU1FMIGZpbGUgcGF0aCwgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIGFjY29yZGluZyB0byBob3cgeW91IHNwZWNpZmllZCB0aGUgc2VhcmNoIGRpcmVjdG9yeVxyXG4gKiAtIGBuYW1lYCAtIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgcmVwcmVzZW50cyB0aGUgU1FMIGZpbGVcclxuICogLSBgcGF0aGAgLSBwcm9wZXJ0eSByZXNvbHV0aW9uIHBhdGggKGZ1bGwgcHJvcGVydHkgbmFtZSlcclxuICpcclxuICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYW55dGhpbmcgb3RoZXIgdGhhbiBgdW5kZWZpbmVkYCwgaXQgb3ZlcnJpZGVzIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlIGluIHRoZSB0cmVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBDYW1lbGl6ZWQgU1FMIHRyZWUgb2JqZWN0LCB3aXRoIGVhY2ggdmFsdWUgYmVpbmcgYW4gU1FMIGZpbGUgcGF0aCAodW5sZXNzIGNoYW5nZWQgdmlhIHRoZSBjYWxsYmFjaykuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIHNpbXBsZSBTUUwgdHJlZSBnZW5lcmF0aW9uIGZvciBmdXJ0aGVyIHByb2Nlc3Npbmc6XHJcbiAqIGNvbnN0IHRyZWUgPSBwZ3AudXRpbHMuZW51bVNxbCgnLi4vc3FsJywge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBnZW5lcmF0aW5nIGFuIFNRTCB0cmVlIGZvciBkeW5hbWljIHVzZSBvZiBuYW1lczpcclxuICogY29uc3Qgc3FsID0gcGdwLnV0aWxzLmVudW1TcWwoX19kaXJuYW1lLCB7cmVjdXJzaXZlOiB0cnVlfSwgZmlsZSA9PiB7XHJcbiAqICAgICByZXR1cm4gbmV3IHBncC5RdWVyeUZpbGUoZmlsZSwge21pbmlmeTogdHJ1ZX0pO1xyXG4gKiB9KTtcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogY29uc3Qge2pvaW46IGpvaW5QYXRofSA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuICpcclxuICogLy8gcmVwbGFjaW5nIGVhY2ggcmVsYXRpdmUgcGF0aCBpbiB0aGUgdHJlZSB3aXRoIGEgZnVsbCBvbmU6XHJcbiAqIGNvbnN0IHRyZWUgPSBwZ3AudXRpbHMuZW51bVNxbCgnLi4vc3FsJywge3JlY3Vyc2l2ZTogdHJ1ZX0sIGZpbGUgPT4ge1xyXG4gKiAgICAgcmV0dXJuIGpvaW5QYXRoKF9fZGlybmFtZSwgZmlsZSk7XHJcbiAqIH0pO1xyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZW51bVNxbChkaXIsIG9wdGlvbnMsIGNiKSB7XHJcbiAgICBpZiAoIW5wbS51dGlscy5pc1RleHQoZGlyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdkaXJcXCcgbXVzdCBiZSBhIG5vbi1lbXB0eSB0ZXh0IHN0cmluZy4nKTtcclxuICAgIH1cclxuICAgIG9wdGlvbnMgPSBhc3NlcnQob3B0aW9ucywgWydyZWN1cnNpdmUnLCAnaWdub3JlRXJyb3JzJ10pO1xyXG4gICAgY2IgPSAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSA/IGNiIDogbnVsbDtcclxuICAgIHJldHVybiBfZW51bVNxbChkaXIsIG9wdGlvbnMsIGNiLCAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHV0aWxzLnRhc2tBcmdzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBOb3JtYWxpemVzL3ByZXBhcmVzIGFyZ3VtZW50cyBmb3IgdGFza3MgYW5kIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogSXRzIG1haW4gcHVycG9zZSBpcyB0byBzaW1wbGlmeSBhZGRpbmcgY3VzdG9tIG1ldGhvZHMge0BsaW5rIERhdGFiYXNlI3Rhc2sgdGFza30sIHtAbGluayBEYXRhYmFzZSN0YXNrSWYgdGFza0lmfSxcclxuICoge0BsaW5rIERhdGFiYXNlI3R4IHR4fSBhbmQge0BsaW5rIERhdGFiYXNlI3R4SWYgdHhJZn0gd2l0aGluIGV2ZW50IHtAbGluayBldmVudDpleHRlbmQgZXh0ZW5kfSwgYXMgdGhlIHRob3NlIG1ldGhvZHMgdXNlIGZhaXJseVxyXG4gKiBjb21wbGV4IGxvZ2ljIGZvciBwYXJzaW5nIGlucHV0cy5cclxuICpcclxuICogQHBhcmFtIGFyZ3Mge09iamVjdH1cclxuICogQXJyYXktbGlrZSBvYmplY3Qgb2YgYGFyZ3VtZW50c2AgdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIG1ldGhvZC4gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgYGFyZ3VtZW50c2BcclxuICogYXJlIGFsd2F5cyBtYWRlIG9mIHR3byBwYXJhbWV0ZXJzIC0gYChvcHRpb25zLCBjYilgLCBzYW1lIGFzIGFsbCB0aGUgZGVmYXVsdCB0YXNrL3RyYW5zYWN0aW9uIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEFuZCBpZiB5b3VyIGN1c3RvbSBtZXRob2QgbmVlZHMgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLCB0aGV5IHNob3VsZCBiZSBwYXNzZWQgaW4gYXMgZXh0cmEgcHJvcGVydGllcyB3aXRoaW4gYG9wdGlvbnNgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEFycmF5IG9mIGFyZ3VtZW50cyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBhIHRhc2sgb3IgdHJhbnNhY3Rpb24uXHJcbiAqXHJcbiAqIEl0IGlzIGV4dGVuZGVkIHdpdGggcHJvcGVydGllcyBgb3B0aW9uc2AgYW5kIGBjYmAgdG8gYWNjZXNzIHRoZSBjb3JyZXNwb25kaW5nIGFycmF5IGVsZW1lbnRzIGBbMF1gIGFuZCBgWzFdYCBieSBuYW1lLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBSZWdpc3RlcmluZyBhIGN1c3RvbSB0cmFuc2FjdGlvbiBtZXRob2QgdGhhdCBhc3NpZ25zIGEgZGVmYXVsdCBUcmFuc2FjdGlvbiBNb2RlOlxyXG4gKlxyXG4gKiBjb25zdCBpbml0T3B0aW9ucyA9IHtcclxuICogICAgIGV4dGVuZDogb2JqID0+IHtcclxuICogICAgICAgICBvYmoubXlUeCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XHJcbiAqICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwZ3AudXRpbHMudGFza0FyZ3MoYXJndW1lbnRzKTsgLy8gcHJlcGFyZSBhcmd1bWVudHNcclxuICpcclxuICogICAgICAgICAgICAgaWYgKCEoJ21vZGUnIGluIGFyZ3Mub3B0aW9ucykpIHtcclxuICogICAgICAgICAgICAgICAgIC8vIGlmIG5vICdtb2RlJyB3YXMgc3BlY2lmaWVkLCBzZXQgZGVmYXVsdCBmb3IgdHJhbnNhY3Rpb24gbW9kZTpcclxuICogICAgICAgICAgICAgICAgIGFyZ3Mub3B0aW9ucy5tb2RlID0gbXlUeE1vZGVPYmplY3Q7IC8vIG9mIHR5cGUgcGdwLnR4TW9kZS5UcmFuc2FjdGlvbk1vZGVcclxuICogICAgICAgICAgICAgfVxyXG4gKlxyXG4gKiAgICAgICAgICAgICByZXR1cm4gb2JqLnR4LmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gKiAgICAgICAgICAgICAvLyBvciBleHBsaWNpdGx5LCBpZiBuZWVkZWQ6XHJcbiAqICAgICAgICAgICAgIC8vIHJldHVybiBvYmoudHguY2FsbCh0aGlzLCBhcmdzLm9wdGlvbnMsIGFyZ3MuY2IpO1xyXG4gKiAgICAgICAgIH1cclxuICogICAgIH1cclxuICogfTtcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRhc2tBcmdzKGFyZ3MpIHtcclxuXHJcbiAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MubGVuZ3RoICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCdhcmdzXFwnIG11c3QgYmUgYW4gYXJyYXktbGlrZSBvYmplY3Qgb2YgYXJndW1lbnRzLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSwgY2I7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjYiA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmIChjYi5uYW1lKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGFnID0gY2IubmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYiA9IGFyZ3NbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7dGFnOiBvcHRpb25zfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCEoJ3RhZycgaW4gb3B0aW9ucykgJiYgY2IgJiYgY2IubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YWcgPSBjYi5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlcyA9IFtvcHRpb25zLCBjYl07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgJ29wdGlvbnMnLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpc1swXSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgJ2NiJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1sxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXNbMV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIHV0aWxzXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBOYW1lc3BhY2UgZm9yIGdlbmVyYWwtcHVycG9zZSBzdGF0aWMgZnVuY3Rpb25zLCBhdmFpbGFibGUgYXMgYHBncC51dGlsc2AsIGJlZm9yZSBhbmQgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjYW1lbGl6ZVxyXG4gKiB7QGxpbmsgdXRpbHMuY2FtZWxpemUgY2FtZWxpemV9IC0gY2FtZWxpemVzIGEgdGV4dCBzdHJpbmdcclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY2FtZWxpemVWYXJcclxuICoge0BsaW5rIHV0aWxzLmNhbWVsaXplVmFyIGNhbWVsaXplVmFyfSAtIGNhbWVsaXplcyBhIHRleHQgc3RyaW5nIGFzIGEgdmFyaWFibGVcclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZW51bVNxbFxyXG4gKiB7QGxpbmsgdXRpbHMuZW51bVNxbCBlbnVtU3FsfSAtIGVudW1lcmF0ZXMgU1FMIGZpbGVzIGluIGEgZGlyZWN0b3J5XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHRhc2tBcmdzXHJcbiAqIHtAbGluayB1dGlscy50YXNrQXJncyB0YXNrQXJnc30gLSBwcmVwYXJlcyBhcmd1bWVudHMgZm9yIHRhc2tzIGFuZCB0cmFuc2FjdGlvbnNcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY2FtZWxpemUsXHJcbiAgICBjYW1lbGl6ZVZhcixcclxuICAgIGVudW1TcWwsXHJcbiAgICB0YXNrQXJnc1xyXG59O1xyXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIm5wbSIsImZzIiwicGF0aCIsInV0aWxzIiwicGFja2FnZSIsImNhbWVsaXplIiwidGV4dCIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwic3Vic3RyIiwidG9Mb3dlckNhc2UiLCJjYW1lbGl6ZVZhciIsIl9lbnVtU3FsIiwiZGlyIiwib3B0aW9ucyIsImNiIiwibmFtZVBhdGgiLCJ0cmVlIiwicmVhZGRpclN5bmMiLCJmb3JFYWNoIiwiZmlsZSIsInN0YXQiLCJmdWxsUGF0aCIsImpvaW4iLCJzdGF0U3luYyIsImUiLCJpZ25vcmVFcnJvcnMiLCJpc0RpcmVjdG9yeSIsInJlY3Vyc2l2ZSIsImRpck5hbWUiLCJucCIsInQiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiRXJyb3IiLCJleHRuYW1lIiwibmFtZSIsInJlc3VsdCIsInVuZGVmaW5lZCIsImVudW1TcWwiLCJpc1RleHQiLCJUeXBlRXJyb3IiLCJ0YXNrQXJncyIsImFyZ3MiLCJ0YWciLCJyZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNldCIsIm5ld1ZhbHVlIiwiZW51bWVyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pg-promise/lib/utils/public.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pg-promise/package.json":
/*!**********************************************!*\
  !*** ./node_modules/pg-promise/package.json ***!
  \**********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"pg-promise","version":"11.5.4","description":"PostgreSQL interface for Node.js","main":"lib/index.js","typings":"typescript/pg-promise.d.ts","scripts":{"spelling":"cspell --config=.cspell.json \\"**/*.{md,ts,js}\\" --no-progress","coverage":"istanbul cover ./node_modules/jasmine-node/bin/jasmine-node --captureExceptions test","doc":"jsdoc -c ./jsdoc/jsdoc.js ./jsdoc/README.md -t ./jsdoc/templates/custom","lint":"eslint ./lib ./test/*.js ./test/db --fix","test":"jasmine-node --captureExceptions test","test:init":"node test/db/init.js","test:native":"jasmine-node test --config PG_NATIVE true","tslint":"tslint ./typescript/*.ts"},"files":["lib","typescript"],"homepage":"https://github.com/vitaly-t/pg-promise","repository":{"type":"git","url":"https://github.com/vitaly-t/pg-promise.git"},"bugs":{"url":"https://github.com/vitaly-t/pg-promise/issues","email":"vitaly.tomilov@gmail.com"},"keywords":["pg","promise","postgres"],"author":{"name":"Vitaly Tomilov","email":"vitaly.tomilov@gmail.com"},"license":"MIT","engines":{"node":">=14.0"},"dependencies":{"assert-options":"0.8.1","pg":"8.11.3","pg-minify":"1.6.3","spex":"3.3.0"},"devDependencies":{"@types/node":"20.5.2","bluebird":"3.7.2","coveralls":"3.1.1","cspell":"7.0.1","eslint":"8.47.0","istanbul":"0.4.5","jasmine-node":"3.0.0","jsdoc":"4.0.2","JSONStream":"1.3.5","pg-query-stream":"4.5.3","tslint":"6.1.3","typescript":"5.1.6"}}');

/***/ })

};
;