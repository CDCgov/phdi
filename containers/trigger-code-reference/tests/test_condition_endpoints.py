import json
from pathlib import Path
from unittest.mock import patch

import pytest
from app.main import app
from fastapi.testclient import TestClient

client = TestClient(app)


@pytest.fixture
def mock_db():
    with patch("sqlite3.connect", autospec=True) as mock_connect:
        mock_conn = mock_connect.return_value
        mock_conn.__enter__.return_value = mock_conn
        mock_cursor = mock_conn.cursor.return_value
        yield mock_cursor


def _check_for_stamped_resource_in_bundle(
    stamped_message: dict, code: str, resource_type: str | None = None
) -> bool:
    """
    Testing utility that scans a provided input bundle for the first instance
    of a particular resource type, and checks whether that resource has an
    extension for a provided SNOMED code stamp. If a resource type is omitted,
    the utility checks all resources in the passed-in bundle for an extension
    stamp.

    :param bundle: The bundle generated by testing.
    :param code: The SNOMED code to check a stamp for.
    :param resource_type: Optionally, the resource type to check in the bundle.
      If omitted, all resources in the bundle are scanned for an extension.
    :return: Boolean indicating whether the first instance of the given resource
      type possesses a stamped extension of the provided code.
    """
    found_matching_extension = False
    for e in stamped_message.get("entry", []):
        if (
            resource_type is not None
            and e.get("resource").get("resourceType") != resource_type
        ):
            continue
        extensions = e.get("resource", {}).get("extension", [])
        for ext in extensions:
            if ext == {
                "url": "https://reportstream.cdc.gov/fhir/StructureDefinition/condition-code",
                "coding": [{"code": code, "system": "http://snomed.info/sct"}],
            }:
                found_matching_extension = True
                break
    return found_matching_extension


def test_health_check():
    actual_response = client.get("/")
    assert actual_response.status_code == 200
    assert actual_response.json() == {
        "status": "OK",
    }


def test_get_value_sets_for_condition(mock_db):
    mocked_db_response = [
        ("dxtc", "A36.3|A36", "http://hl7.org/fhir/sid/icd-10-cm"),
        ("sdtc", "772150003", "http://snomed.info/sct"),
    ]
    mock_db.fetchall.return_value = mocked_db_response
    response = client.get("/get-value-sets/?condition_code=276197005")
    expected_result = {
        "dxtc": [
            {"codes": ["A36.3", "A36"], "system": "http://hl7.org/fhir/sid/icd-10-cm"}
        ],
        "sdtc": [{"codes": ["772150003"], "system": "http://snomed.info/sct"}],
    }
    assert response.json() == expected_result


def test_stamp_conditions_bad_input():
    input = {"bundle": {"test_key": "test_val"}, "conditions": []}
    response = client.post("/stamp-condition-extensions", json=input)
    assert response.status_code == 422
    assert (
        response.json()["detail"][0]["msg"]
        == "Supplied list of SNOMED conditions "
        + "must contain one or more elements; given list was empty."
    )


# Note: This function is defined in utils, but we mock it in the namespace
# coming from main because that's where the endpoint is invoking it from
@patch("app.main.get_clinical_services_list")
def test_stamp_conditions_no_resources_to_stamp(patched_get_services_list):
    # We don't stamp patient resources, bundle should be a no-op
    message = json.load(open(Path(__file__).parent / "assets" / "sample_ecr.json"))
    message["entry"] = [
        e
        for e in message["entry"]
        if e.get("resource").get("resourceType") == "Patient"
    ]

    patched_get_services_list.return_value = [
        ("dxtc", "A36.3|A36", "http://hl7.org/fhir/sid/icd-10-cm"),
        ("sdtc", "772150003", "http://snomed.info/sct"),
    ]
    input = {"bundle": message, "conditions": ["276197005"]}
    response = client.post("/stamp-condition-extensions", json=input)
    assert response.status_code == 200
    stamped_message = response.json()["extended_bundle"]
    found_matching_extension = _check_for_stamped_resource_in_bundle(
        stamped_message, "276197005"
    )
    assert not found_matching_extension


@patch("app.main.get_clinical_services_list")
def test_stamp_condition_extensions(patched_get_services_list):
    # We'll just try stamping one of each resource type, no need
    # to see 47 observations
    message = json.load(open(Path(__file__).parent / "assets" / "sample_ecr.json"))
    obs_e = [
        e
        for e in message["entry"]
        if e.get("resource").get("resourceType") == "Observation"
    ][0]
    cond_e = [
        e
        for e in message["entry"]
        if e.get("resource").get("resourceType") == "Condition"
    ][0]
    imm_e = [
        e
        for e in message["entry"]
        if e.get("resource").get("resourceType") == "Immunization"
    ][3]
    message["entry"] = [obs_e, cond_e, imm_e]

    # Note: obviously not real conditions, we're just simulating stamping different
    # resource types according to different condition criteria
    patched_get_services_list.return_value = [
        ("dxtc", "1234567|9999999999|64572001", "code-sys-1"),
        ("dxtc", "8971234987123", "code-sys-2"),
        ("lotc", "72391283|8916394-2|24", "code-sys-1"),
    ]
    input = {"bundle": message, "conditions": ["99999-9"]}
    response = client.post("/stamp-condition-extensions", json=input)
    assert response.status_code == 200
    stamped_message = response.json()["extended_bundle"]

    # Check observation: diagnostic code value came back successful
    found_matching_extension = _check_for_stamped_resource_in_bundle(
        stamped_message, "99999-9", "Observation"
    )
    assert found_matching_extension

    # Check condition: no value set cross-referenced for this bundle, no stamp
    found_matching_extension = _check_for_stamped_resource_in_bundle(
        stamped_message, "99999-9", "Condition"
    )
    assert not found_matching_extension

    # Check immunization: we did find a referenced immunization code, so it should be there
    found_matching_extension = _check_for_stamped_resource_in_bundle(
        stamped_message, "99999-9", "Immunization"
    )
    assert found_matching_extension
